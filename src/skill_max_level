11.c:	obj = create_object( objindex, ch->top_level );
11.c:	for(rch = proom->first_person; rch; rch = rch->next_in_room)
11.c:		fobj = create_object( fObjIndex, ch->top_level );
11.c:    switch( ch->substate )
11.c:                if ( !IS_SET( ch->in_room->room_flags, ROOM_FACTORY ) )
11.c:                for ( obj = ch->last_carrying; obj; obj = obj->prev_content )     
11.c:    	        chance = IS_NPC(ch) ? ch->top_level
11.c:	                 : (int) (ch->pcdata->learned[gsn_makegoggles]);
11.c:    		   ch->dest_buf = str_dup(arg);
11.c:    		   ch->dest_buf_2 = str_dup(arg2);
11.c:    		if ( !ch->dest_buf )
11.c:    		if ( !ch->dest_buf_2 )
11.c:    		strcpy(arg, ch->dest_buf);
11.c:    		DISPOSE( ch->dest_buf);
11.c:    		strcpy(arg2, ch->dest_buf_2);
11.c:    		DISPOSE( ch->dest_buf_2);
11.c:    		DISPOSE( ch->dest_buf );
11.c:    		DISPOSE( ch->dest_buf_2 );
11.c:    		ch->substate = SUB_NONE;    		                                   
11.c:    ch->substate = SUB_NONE;
11.c:    level = IS_NPC(ch) ? ch->top_level : (int) (ch->pcdata->learned[gsn_makegoggles]);
11.c:    for ( obj = ch->last_carrying; obj; obj = obj->prev_content )     
11.c:    chance = IS_NPC(ch) ? ch->top_level
11.c:                : (int) (ch->pcdata->learned[gsn_makegoggles]) ;
11.c:    obj->level = ch->top_level;
11.c:    obj->value[0] = ch->top_level;
11.c:	 obj->value[4] = ch->pcdata->learned[gsn_makegoggles]/10;
11.c:         xpgain = UMIN( obj->cost*100 ,( exp_level(ch->skill_level[ENGINEERING_ABILITY]+1) - exp_level(ch->skill_level[ENGINEERING_ABILITY]) ) );
11.c:    switch( ch->substate )
11.c:                if ( !IS_SET( ch->in_room->room_flags, ROOM_FACTORY ) )
11.c:                for ( obj = ch->last_carrying; obj; obj = obj->prev_content )     
11.c:    	        chance = IS_NPC(ch) ? ch->top_level
11.c:	                 : (int) (ch->pcdata->learned[gsn_makemissile]);
11.c:    		   ch->dest_buf   = str_dup(arg);
11.c:    		if ( !ch->dest_buf )
11.c:    		strcpy(arg, ch->dest_buf);
11.c:    		DISPOSE( ch->dest_buf);
11.c:    		DISPOSE( ch->dest_buf );
11.c:    		ch->substate = SUB_NONE;    		                                   
11.c:    ch->substate = SUB_NONE;
11.c:    level = IS_NPC(ch) ? ch->top_level : (int) (ch->pcdata->learned[gsn_makemissile]);
11.c:    for ( obj = ch->last_carrying; obj; obj = obj->prev_content )     
11.c:    chance = IS_NPC(ch) ? ch->top_level
11.c:                : (int) (ch->pcdata->learned[gsn_makemissile]) ;
11.c:    obj->value[1] = ch->pcdata->learned[gsn_makemissile];
11.c:    obj->value[2] = number_range(ch->pcdata->learned[gsn_makemissile], ch->pcdata->learned[gsn_makemissile]+100);
11.c:         xpgain = UMIN( obj->cost*50 ,( exp_level(ch->skill_level[ENGINEERING_ABILITY]+1) - exp_level(ch->skill_level[ENGINEERING_ABILITY]) ) );
11.c:   if ( IS_SET( ch->in_room->room_flags, ROOM_SAFE ) )
11.c:   if( wield->value[2] == 1 && !ch->aiming_at && arg2[0] != '\0')
11.c:   if ( ( pexit = get_exit( ch->in_room, dir ) ) == NULL )
11.c:					explode_emissile(ch, ch->in_room, wield->value[3], wield->value[4], 1);
11.c:					explode_emissile(ch, ch->in_room, wield->value[3], wield->value[4], 0);
11.c:	for(pexit = ch->in_room->first_exit; pexit; pexit = pexit->next)
11.c:					for(rch = ch->in_room->first_person; rch; rch = rch->next_in_room)
11.c:						explode_emissile(ch, ch->in_room, wield->value[3], wield->value[4], 1);
11.c:						explode_emissile(ch, ch->in_room, wield->value[3], wield->value[4], 0);
11.c:    					for ( rch = ch->in_room->first_person ; rch ;  rch = rch->next_in_room )
11.c:							rch->position = POS_SITTING;
11.c:					for(rch = ch->in_room->first_person; rch; rch = rch->next_in_room)
11.c:						explode_emissile(ch, ch->in_room, wield->value[3], wield->value[4], 1);
11.c:						explode_emissile(ch, ch->in_room, wield->value[3], wield->value[4], 0);
11.c:		for(rch = proom->first_person; rch; rch = rch->next_in_room) // Target?
11.c:			if(ch->aiming_at == rch) // Laser guidance on launcher, like having 100% launchers
11.c:					chance = 100 - rch->pcdata->learned[gsn_dodge];
11.c:					chance = ch->pcdata->learned[gsn_launchers] - rch->pcdata->learned[gsn_dodge];
11.c:			if(number_range(-15, chance+(rch->perm_lck - 12)) >= 0) // Direct hit
11.c:				for(zch = proom->first_person; zch; zch = zch->next_in_room)
11.c:			else if(number_range(-15, chance+(rch->perm_lck - 12)) >= -5) // Miss, but still damages
11.c:				for(zch = proom->first_person; zch; zch = zch->next_in_room)
11.c:				for(zch = proom->first_person; zch; zch = zch->next_in_room)
11.c:			if(ch->aiming_at)
11.c:				ch->aiming_at = NULL;
11.c:				for(rch = proom->first_person; rch; rch = rch->next_in_room)
11.c:				for(rch = proom->first_person; rch; rch = rch->next_in_room)
11.c:    		for ( rch = proom->first_person ; rch ;  rch = rch->next_in_room )
11.c:					for(zch = proom->first_person; zch; zch = zch->next_in_room)					
11.c:					rch->position = POS_SITTING;
11.c:			for(zch = proom->first_person; zch; zch = zch->next_in_room)
11.c:			for(zch = proom->first_person; zch; zch = zch->next_in_room)
11.c:		for(zch = proom->first_person; zch; zch = zch->next_in_room)
11.c:    if ( ( pexit = get_exit( ch->in_room, dir ) ) == NULL )
11.c:    for(rch = ch->in_room->first_person; rch; rch = rch->next_in_room)
11.c:    obj = create_object( get_obj_index(80), ch->top_level );    
11.c:    obj->level = ch->top_level;
11.c:    for(rch = ch->in_room->first_person; rch; rch = rch->next_in_room)
11.c: if( (ship = ship_from_gunseat(ch->in_room->vnum)) == NULL )
11.c: if( (ship = ship_from_gunseat(ch->in_room->vnum)) == NULL )
11.c: if( (ship = ship_from_cockpit(ch->in_room->vnum)) == NULL )
11.c: switch(ch->substate)
11.c:	chance = IS_NPC(ch) ? ch->top_level*2 : ch->pcdata->learned[gsn_barrelroll];
11.c:	ch->substate = SUB_NONE;
11.c:	if(( ship = ship_from_cockpit(ch->in_room->vnum) ) == NULL)  return;
11.c:	ch->substate = SUB_NONE;
11.c:	if(( ship = ship_from_cockpit(ch->in_room->vnum) ) == NULL)  return;
11.c: if( (ship = ship_from_cockpit(ch->in_room->vnum)) == NULL )
11.c: switch(ch->substate)
11.c:	chance = IS_NPC(ch) ? ch->top_level*2 : ch->pcdata->learned[gsn_juke];
11.c:	ch->substate = SUB_NONE;
11.c:	if(( ship = ship_from_cockpit(ch->in_room->vnum) ) == NULL)  return;
11.c:	ch->substate = SUB_NONE;
11.c:	if(( ship = ship_from_cockpit(ch->in_room->vnum) ) == NULL)  return;
act_comm.c: if(ch->comfreq)
act_comm.c:   STRFREE(ch->comfreq);
act_comm.c: ch->comfreq = STRALLOC(buf);
act_comm.c:    REMOVE_BIT( ch->deaf, CHANNEL_TELLS );
act_comm.c:    if ( IS_SET( ch->in_room->room_flags, ROOM_SILENCE ) )
act_comm.c:        && ( IS_SET(ch->act, PLR_SILENCE)
act_comm.c:        ||   IS_SET(ch->act, PLR_NO_TELL) ) )
act_comm.c:    if (!IS_NPC(ch) && IS_SET(ch->pcdata->act2, ACT_GAGGED))
act_comm.c:       || ( IS_NPC(victim) && victim->in_room != ch->in_room ) 
act_comm.c:      for ( obj = ch->last_carrying; obj; obj = obj->prev_content )
act_comm.c:    if ( knows_language( victim, ch->speaking, ch )
act_comm.c:    ||  (IS_NPC(ch) && !ch->speaking) )
act_comm.c:	act( AT_WHITE, "$n manda un beep: '$t'", ch, scramble(argument, ch->speaking), victim, TO_VICT );
act_comm.c:  if ( IS_NPC( ch ) || !ch->pcdata ) return (char *) argument;
act_comm.c:  drunk = ch->pcdata->condition[COND_DRUNK];
act_comm.c:    SHIP_DATA *ship = ship_from_cockpit( ch->in_room->vnum);
act_comm.c:    if(ch->comfreq == NULL || !str_cmp(ch->comfreq, "(null)")
act_comm.c:	 || (strlen(ch->comfreq) != 7))
act_comm.c:        for ( obj = ch->last_carrying; obj; obj = obj->prev_content )
act_comm.c:        if ( ch->pcdata->clan->mainclan )
act_comm.c:           clan = ch->pcdata->clan->mainclan;
act_comm.c:           clan = ch->pcdata->clan;
act_comm.c:    if ( IS_SET( ch->in_room->room_flags, ROOM_SILENCE ) )
act_comm.c:      if ( ch->master )
act_comm.c:	    send_to_char( "No lo creo...\n\r", ch->master );
act_comm.c:    if ( !IS_NPC(ch) && IS_SET(ch->act, PLR_SILENCE) )
act_comm.c:    if (!IS_NPC(ch) && IS_SET(ch->pcdata->act2, ACT_GAGGED) && channel != CHANNEL_OOC)
act_comm.c:    REMOVE_BIT(ch->deaf, channel);
act_comm.c:      	 ch_printf( ch, "&R(&YFrec &w%s&R) &W%sEnvías: %s\n\r", ch->comfreq, color_str(AT_CHAT, ch), argument );
act_comm.c:	     ch_printf( ch, "&G(&gPregunta: &G&W%s&G) &W'%s'\n\r", ch->name, argument );
act_comm.c:	     ch_printf( ch, "(NOVATO) %s: %s\n\r", ch->name, argument );
act_comm.c:          if (ch->top_level < LEVEL_IMMORTAL)
act_comm.c:             ch_printf(ch,"&Y(&OOOC&Y) &G&W%s%s: %s\n\r", color_str(AT_OOC,ch),ch->name, argument);
act_comm.c:             ch_printf(ch,"&Y(&OIMM&Y)&Y(&OOOC&Y) &G&W%s%s: %s\n\r", color_str(AT_OOC, ch), IS_SET(ch->act, PLR_WIZINVIS) ? "Immortal" : ch->name,  argument);
act_comm.c:          position        = ch->position;
act_comm.c:          ch->position    = POS_STANDING;        
act_comm.c:	      ch->position    = position;
act_comm.c:               ch_printf( ch, "&R[&W%sAVTALK: %s&R] &W%s%s\n\r", color_str(AT_IMMTALK, ch), ch->name,color_str(AT_IMMTALK, ch), argument );
act_comm.c:               ch_printf( ch, "&R[&W%sIMM: %s&R] &W%s%s\n\r", color_str(AT_IMMTALK, ch), ch->name,color_str(AT_IMMTALK, ch), argument );
act_comm.c:               ch_printf( ch, "&R[&W%si103: %s&R] &W%s%s\n\r", color_str(AT_IMMTALK, ch), ch->name,color_str(AT_IMMTALK, ch), argument );
act_comm.c:               ch_printf( ch, "&R[&W%si104: %s&R] &W%s%s\n\r", color_str(AT_IMMTALK, ch), ch->name,color_str(AT_IMMTALK, ch), argument );
act_comm.c:                       ch_printf( ch, "\n\r&G&w&g[&w&W%sAdmin&g] &w&W%s%s&w&g: &w&W%s%s&w&g\n\r", color_str(AT_AVATAR, ch), color_str(AT_AVATAR, ch), ch->name, color_str(AT_AVATAR, ch), argument );
act_comm.c:              position  = ch->position;
act_comm.c:              ch->position      = POS_STANDING;
act_comm.c:              ch->position      = position;
act_comm.c:    if ( IS_SET( ch->in_room->room_flags, ROOM_LOGSPEECH ) )
act_comm.c:	sprintf( buf2, "%s: %s (%s)", IS_NPC( ch ) ? ch->short_descr : ch->name,
act_comm.c:	&&  !IS_SET(och->deaf, channel) )
act_comm.c:	if ( !str_cmp( vch->name, ch->name ))
act_comm.c:	     sprintf( buf, "&G(&gPregunta: &G&W%s&G) &W'%s'\n\r", ch->name, argument );
act_comm.c:          if (ch->top_level < LEVEL_IMMORTAL)
act_comm.c:             sprintf( buf, "&Y(&OOOC&Y) &G&W%s%s: $t", color_str(AT_OOC,vch), ch->name);
act_comm.c:              sprintf( buf, "&Y(&OIMM&Y)&Y(&OOOC&Y) &G&W%s%s: $t", color_str(AT_OOC,vch), IS_SET(ch->act, PLR_WIZINVIS) ? "Immortal" : ch->name );  
act_comm.c:               for ( obj = och->last_carrying; obj; obj = obj->prev_content )
act_comm.c:           if ( IS_SET( vch->in_room->room_flags, ROOM_SILENCE ) )
act_comm.c:	      if ( ch->in_room != och->in_room )
act_comm.c:		if ( !vch->pcdata->clan )
act_comm.c:		if ( vch->pcdata->clan != clan && vch->pcdata->clan->mainclan != clan )
act_comm.c:                SHIP_DATA *ship = ship_from_cockpit( ch->in_room->vnum );
act_comm.c:                if ( !vch->in_room )
act_comm.c:                target = ship_from_cockpit( vch->in_room->vnum );
act_comm.c:                for ( obj = vch->last_carrying; obj; obj = obj->prev_content )
act_comm.c:		  chance = IS_NPC(vch) ? vch->top_level
act_comm.c:    		    : (int)  (vch->pcdata->learned[gsn_commsystem]) ;
act_comm.c:              if(vch->top_level < 32)
act_comm.c:                SHIP_DATA *ship = ship_from_room( ch->in_room->vnum );
act_comm.c:                if ( !vch->in_room )
act_comm.c:                target = ship_from_room( vch->in_room->vnum );
act_comm.c:	    position		= vch->position;
act_comm.c:		vch->position	= POS_STANDING;
act_comm.c:	    if ( !knows_language( vch, ch->speaking, ch ) &&
act_comm.c:			 (!IS_NPC(ch) || ch->speaking != 0)   &&
act_comm.c:			sbuf = scramble(argument, ch->speaking);
act_comm.c:		ch_printf( vch, "&R(&YFrec: &w%s&R)&W%s%s%s%s: %s\n\r", ch->comfreq, color_str(AT_CHAT, vch),
act_comm.c:          IS_IMMORTAL(vch) ? ch->name : "",
act_comm.c:	    vch->position	= position;
act_comm.c:  if(ch->main_ability != SLICER_ABILITY)
act_comm.c:  if(ch->skill_level[SLICER_ABILITY] < 20)
act_comm.c:  STRFREE(ch->comfreq);
act_comm.c:  ch->comfreq = STRALLOC(argument);
act_comm.c:  ch_printf(ch, "&wSintonizas tu sistema de enlaces que muestra: &z(&gFrecuencia:&G %s&z)&w.\n\r", ch->comfreq);
act_comm.c: if(ch->comfreq)
act_comm.c:  STRFREE(ch->comfreq);
act_comm.c: ch->comfreq = STRALLOC(buf);
act_comm.c: ch_printf(ch, "&R&wJugueteas con tu sistema de enlaces un poco, y este muestra &z(&gFrecuencia:&G %s&z)&w.\n\r", ch->comfreq);
act_comm.c:	&&  !IS_SET(och->deaf, channel)
act_comm.c:     if ( (ship = ship_from_cockpit(ch->in_room->vnum)) == NULL )  
act_comm.c:     if ( (ship = ship_from_cockpit(ch->in_room->vnum)) == NULL )  
act_comm.c:     if ( (ship = ship_from_cockpit(ch->in_room->vnum)) == NULL )  
act_comm.c:  if (!IS_NPC (ch) && (IS_SET(ch->act, PLR_NO_EMOTE) || IS_SET(ch->act, PLR_SILENCE)))
act_comm.c:  switch (ch->position)
act_comm.c:  if (!IS_NPC (ch) && (IS_SET(ch->act, PLR_NO_EMOTE) || IS_SET(ch->act, PLR_SILENCE)))
act_comm.c:      sprintf(buf, "&Y(&OOOC&Y) &W%s %s\n\r", ch->name, argument);
act_comm.c:    if ( IS_NPC( ch ) || !ch->pcdata->clan )
act_comm.c:    if ( ch->top_level > 5 )
act_comm.c:    if ( IS_SET( ch->in_room->room_flags, ROOM_SILENCE ) )
act_comm.c:    actflags = ch->act;
act_comm.c:    if ( IS_NPC( ch ) ) REMOVE_BIT( ch->act, ACT_SECRETIVE );
act_comm.c:	for ( vch = ch->in_room->first_person; vch; vch = vch->next_in_room )
act_comm.c:		if ( !knows_language(vch, ch->speaking, ch) &&
act_comm.c:			 (!IS_NPC(ch) || ch->speaking != 0) )
act_comm.c:			sbuf = scramble(argument, ch->speaking);
act_comm.c:        if( ch && ch->pcdata && IS_SET(ch->pcdata->act2, ACT_GAGGED))
act_comm.c:    ch->act = actflags;
act_comm.c:    if ( IS_SET( ch->in_room->room_flags, ROOM_LOGSPEECH ) )
act_comm.c:	sprintf( buf, "%s: %s", IS_NPC( ch ) ? ch->short_descr : ch->name,
act_comm.c:    if ( IS_SET( ch->deaf, CHANNEL_TELLS ) 
act_comm.c:    if ( IS_SET( ch->in_room->room_flags, ROOM_SILENCE ) )
act_comm.c:    && ( IS_SET(ch->act, PLR_SILENCE)
act_comm.c:    ||   IS_SET(ch->act, PLR_NO_TELL) ) )
act_comm.c:    if (!IS_NPC(ch) && IS_SET(ch->pcdata->act2, ACT_GAGGED))
act_comm.c:       || ( IS_NPC(victim) && victim->in_room != ch->in_room ) 
act_comm.c:    if (victim->in_room != ch->in_room && !IS_IMMORTAL(ch) )
act_comm.c:      for ( obj = ch->last_carrying; obj; obj = obj->prev_content )
act_comm.c:            if (och->pcdata->tell_snoop == ch->name && !IS_IMMORTAL(och) && !IS_IMMORTAL(victim) && !IS_IMMORTAL(ch))
act_comm.c:              	sprintf(buf, "&B[&cINTERCEPTED MESSAGE&b]\n\r&B(&YSent: &G&W%s&B) (&Yto: &G&W%s&B) (&Ymessage&B) &G&W %s\n\r", ch->name, victim->name, argument);
act_comm.c:            if (och->pcdata->tell_snoop == victim->name && !IS_IMMORTAL(och) && !IS_IMMORTAL(victim) && !IS_IMMORTAL(ch))
act_comm.c:              	sprintf(buf, "&B[&cINTERCEPTED MESSAGE&b]\n\r&B(&YSent: &G&W%s&B) (&Yto: &G&W%s&B) (&Ymessage&B)&G&W %s\n\r", ch->name, victim->name, argument);
act_comm.c:    if ( knows_language( victim, ch->speaking, ch )
act_comm.c:    ||  (IS_NPC(ch) && !ch->speaking) )
act_comm.c:	act( AT_TELL, "&W&G[&WTell&G] &G(&WFrom: $n&G)&W '$t'", ch, scramble(argument, ch->speaking), victim, TO_VICT );
act_comm.c:    if ( IS_SET( ch->in_room->room_flags, ROOM_LOGSPEECH ) )
act_comm.c:		 IS_NPC( ch ) ? ch->short_descr : ch->name,
act_comm.c:    if ( IS_SET( ch->deaf, CHANNEL_TELLS ) 
act_comm.c:    if ( IS_SET( ch->in_room->room_flags, ROOM_SILENCE ) )
act_comm.c:    && ( IS_SET(ch->act, PLR_SILENCE)
act_comm.c:    ||   IS_SET(ch->act, PLR_NO_TELL) ) )
act_comm.c:    if (!IS_NPC(ch) && IS_SET(ch->pcdata->act2, ACT_GAGGED))
act_comm.c:       || ( IS_NPC(victim) && victim->in_room != ch->in_room ) 
act_comm.c:    if (victim->in_room != ch->in_room && !IS_IMMORTAL(ch) )
act_comm.c:      for ( obj = ch->last_carrying; obj; obj = obj->prev_content )
act_comm.c:   if(knows_language(vict2, ch->speaking, ch) || (IS_NPC(ch) && !ch->speaking))
act_comm.c:		IS_IMMORTAL(ch) ? ch->name :
act_comm.c:	    IS_IMMORTAL(vict2) ? ch->name : ch->comfreq, argument);
act_comm.c:	    IS_IMMORTAL(ch) ? ch->name :
act_comm.c:	    IS_IMMORTAL(vict2) ? ch->name : ch->comfreq, argument);
act_comm.c:	    ch->name,  color_str(AT_TELL, victim),argument);
act_comm.c:    if ( IS_SET( ch->in_room->room_flags, ROOM_LOGSPEECH ) )
act_comm.c:		 IS_NPC( ch ) ? ch->short_descr : ch->name,
act_comm.c:    REMOVE_BIT( ch->deaf, CHANNEL_TELLS );
act_comm.c:    if ( IS_SET( ch->in_room->room_flags, ROOM_SILENCE ) )
act_comm.c:    if ( !IS_NPC(ch) && IS_SET(ch->act, PLR_SILENCE) )
act_comm.c:    if (!IS_NPC(ch) && IS_SET(ch->pcdata->act2, ACT_GAGGED))
act_comm.c:    if ( ( victim = ch->reply ) == NULL )
act_comm.c:    if (victim->in_room != ch->in_room && !IS_IMMORTAL(ch) )
act_comm.c:      for ( obj = ch->last_carrying; obj; obj = obj->prev_content )
act_comm.c:            if (och->pcdata->tell_snoop == ch->name && !IS_IMMORTAL(och) && !IS_IMMORTAL(victim) && !IS_IMMORTAL(ch))
act_comm.c:              	sprintf(buf, "&B[&cINTERCEPTED MESSAGE&b]\n\r&B(&YSent: &G&W%s&B) (&Yto: &G&W%s&B) (&Ymessage&B) &G&W %s\n\r", ch->name, victim->name, argument);
act_comm.c:            if (och->pcdata->tell_snoop == victim->name && !IS_IMMORTAL(och) && !IS_IMMORTAL(victim) && !IS_IMMORTAL(ch))
act_comm.c:              	sprintf(buf, "&B[&cINTERCEPTED MESSAGE&b]\n\r&B(&YSent: &G&W%s&B) (&Yto: &G&W%s&B) (&Ymessage&B)&G&W %s\n\r", ch->name, victim->name, argument);
act_comm.c:    if ( knows_language( victim, ch->speaking, ch )
act_comm.c:    ||  (IS_NPC(ch) && !ch->speaking) )
act_comm.c:        act( AT_TELL, "&W&G[&WTell&G] &G(&WFrom: $n&G)&W '$t'", ch, scramble(argument,ch->speaking), victim, TO_VICT);
act_comm.c:    if ( IS_SET( ch->in_room->room_flags, ROOM_LOGSPEECH ) )
act_comm.c:		 IS_NPC( ch ) ? ch->short_descr : ch->name,
act_comm.c:    REMOVE_BIT( ch->deaf, CHANNEL_TELLS );
act_comm.c:    if ( IS_SET( ch->in_room->room_flags, ROOM_SILENCE ) )
act_comm.c:    if ( !IS_NPC(ch) && IS_SET(ch->act, PLR_SILENCE) )
act_comm.c:    if (!IS_NPC(ch) && IS_SET(ch->pcdata->act2, ACT_GAGGED))
act_comm.c:    if ( ( victim = ch->reply ) == NULL )
act_comm.c:    if (victim->in_room != ch->in_room && !IS_IMMORTAL(ch) )
act_comm.c:      for ( obj = ch->last_carrying; obj; obj = obj->prev_content )
act_comm.c:   if(knows_language(victim, ch->speaking, ch) || (IS_NPC(ch) && !ch->speaking))
act_comm.c:		IS_IMMORTAL(ch) ? ch->name :
act_comm.c:	    IS_IMMORTAL(victim) ? ch->name : ch->comfreq, argument);
act_comm.c:	    IS_IMMORTAL(ch) ? ch->name :
act_comm.c:	    IS_IMMORTAL(victim) ? ch->name : ch->comfreq, argument);
act_comm.c:    if ( IS_SET( ch->in_room->room_flags, ROOM_LOGSPEECH ) )
act_comm.c:		 IS_NPC( ch ) ? ch->short_descr : ch->name,
act_comm.c:    if ( !IS_NPC(ch) && IS_SET(ch->act, PLR_NO_EMOTE) )
act_comm.c:    actflags = ch->act;
act_comm.c:    if ( IS_NPC( ch ) ) REMOVE_BIT( ch->act, ACT_SECRETIVE );
act_comm.c:    ch->act = actflags;
act_comm.c:    if ( IS_SET( ch->in_room->room_flags, ROOM_LOGSPEECH ) )
act_comm.c:	sprintf( buf, "%s %s (emote)", IS_NPC( ch ) ? ch->short_descr : ch->name,
act_comm.c:    if ( IS_NPC(ch) && IS_SET(ch->act, ACT_POLYMORPHED))
act_comm.c:    if ( ch->position == POS_FIGHTING )
act_comm.c:    if ( ch->position  < POS_STUNNED  )
act_comm.c:    if ( !IS_IMMORTAL(ch) && ch->in_room && !IS_SET( ch->in_room->room_flags , ROOM_HOTEL ) && !NOT_AUTHED(ch) )
act_comm.c:    ch_printf(ch, "Una extraña voz te dice 'Esperamos tu regreso, %s...'", ch->name);
act_comm.c:    if ( ch->challenged )
act_comm.c:      sprintf(qbuf,"¡%s ha salido! ¡La arena está vacía!",ch->name);
act_comm.c:      ch->challenged=NULL;
act_comm.c:    for ( fch = first_char; fch; fch = fch->next )
act_comm.c:	if(fch->challenged && fch->challenged == ch)
act_comm.c:	  fch->challenged=NULL;
act_comm.c:    sprintf( log_buf, "%s has quit.", ch->name );
act_comm.c:    if ( ch->plr_home )
act_comm.c:      for ( obj = ch->plr_home->first_content; obj; obj = obj_next )
act_comm.c:      write_to_buffer(ch->desc,BUFF,num);
act_comm.c:      write_to_buffer(ch->desc,BUFF,num);
act_comm.c:      write_to_buffer(ch->desc,BUFF,num);
act_comm.c:      write_to_buffer(ch->desc,BUFF,num);
act_comm.c:	SET_BIT(ch->act,PLR_ANSI);
act_comm.c:	SET_BIT(ch->act,PLR_ANSI);
act_comm.c:	REMOVE_BIT(ch->act,PLR_ANSI);
act_comm.c:	SET_BIT(ch->act,PLR_SOUND);
act_comm.c:	REMOVE_BIT(ch->act,PLR_SOUND);
act_comm.c:    if ( IS_NPC(ch) && IS_SET(ch->act, ACT_POLYMORPHED))
act_comm.c:    if ( !IS_SET( ch->affected_by, race_table[ch->race].affected ) )
act_comm.c:	SET_BIT( ch->affected_by, race_table[ch->race].affected );
act_comm.c:    if ( !IS_SET( ch->resistant, race_table[ch->race].resist ) )
act_comm.c:	SET_BIT( ch->resistant, race_table[ch->race].resist );
act_comm.c:    if ( !IS_SET( ch->susceptible, race_table[ch->race].suscept ) )
act_comm.c:	SET_BIT( ch->susceptible, race_table[ch->race].suscept );	   
act_comm.c:    sprintf( strsave, "%s%c/%s", PLAYER_DIR, tolower(ch->name[0]),
act_comm.c:                                 capitalize( ch->name ) );
act_comm.c:    sprintf( strback, "%s%c/%s", BACKUP_DIR, tolower(ch->name[0]),
act_comm.c:                                 capitalize( ch->name ) );
act_comm.c:    if(ch->top_level > 10)
act_comm.c:    if ( IS_AFFECTED(ch, AFF_CHARM) && ch->master )
act_comm.c:	act( AT_PLAIN, "¡Prefieres seguir a $N!", ch, NULL, ch->master, TO_CHAR );
act_comm.c:	if ( !ch->master )
act_comm.c:    if ( ch->master )
act_comm.c:    if ( ch->master )
act_comm.c:    ch->master        = master;
act_comm.c:    ch->leader        = NULL;
act_comm.c:    if ( !ch->master )
act_comm.c:	REMOVE_BIT( ch->affected_by, AFF_CHARM );
act_comm.c:    if(ch->master)
act_comm.c:      if ( can_see( ch->master, ch ) )
act_comm.c:        act( AT_ACTION, "$n deja de seguirte.",     ch, NULL, ch->master, TO_VICT    );
act_comm.c:      act( AT_ACTION, "Dejas de seguir a $N.",      ch, NULL, ch->master, TO_CHAR    );
act_comm.c:    ch->master = NULL;
act_comm.c:    ch->leader = NULL;
act_comm.c:    if ( ch->master )
act_comm.c:    ch->leader = NULL;
act_comm.c:    for ( fch = first_char; fch; fch = fch->next )
act_comm.c:	if ( fch->master == ch )
act_comm.c:	if ( fch->leader == ch )
act_comm.c:	    fch->leader = fch;
act_comm.c:    for ( och = ch->in_room->first_person; och; och = och_next )
act_comm.c:	och_next = och->next_in_room;
act_comm.c:	&&   och->master == ch
act_comm.c:        sprintf( log_buf, "%s: order %s.", ch->name, argbuf );
act_comm.c:        log_string_plus( log_buf, LOG_NORMAL, ch->top_level );
act_comm.c:	leader = ch->leader ? ch->leader : ch;
act_comm.c:	for ( gch = first_char; gch; gch = gch->next )
act_comm.c:		    gch->top_level,
act_comm.c:		    IS_NPC(gch) ? "Mob" : race_table[gch->race].race_name,
act_comm.c:		    gch->top_level,
act_comm.c:		    IS_NPC(gch) ? "Mob" : race_table[gch->race].race_name,
act_comm.c:		    gch->hit,   
act_comm.c:		    gch->max_hit,
act_comm.c:		    gch->move,  
act_comm.c:		    gch->max_move   );
act_comm.c:	if ( ch->leader || ch->master )
act_comm.c:	for ( gch = first_char; gch; gch = gch->next )
act_comm.c:		gch->leader = NULL;
act_comm.c:		gch->master = NULL;
act_comm.c:        for ( rch = ch->in_room->first_person; rch; rch = rch->next_in_room )
act_comm.c:	   &&   rch->master == ch
act_comm.c:	   &&   !ch->master
act_comm.c:	   &&   !ch->leader
act_comm.c:		rch->leader = ch;
act_comm.c:    if ( ch->master || ( ch->leader && ch->leader != ch ) )
act_comm.c:    if ( ch->gold < amount )
act_comm.c:    for ( gch = ch->in_room->first_person; gch; gch = gch->next_in_room )
act_comm.c:    if (( IS_SET(ch->act, PLR_AUTOGOLD)) && (members < 2))
act_comm.c:    ch->gold -= amount;
act_comm.c:    ch->gold += share + extra;
act_comm.c:    for ( gch = ch->in_room->first_person; gch; gch = gch->next_in_room )
act_comm.c:	    gch->gold += share;
act_comm.c:    if ( IS_SET( ch->act, PLR_NO_TELL ) )
act_comm.c:/*    sprintf( buf, "%s tells the group '%s'.\n\r", ch->name, argument );*/
act_comm.c:    for ( gch = first_char; gch; gch = gch->next )
act_comm.c:	    if ( knows_language( gch, ch->speaking, gch )
act_comm.c:	    ||  (IS_NPC(ch) && !ch->speaking) )
act_comm.c:		ch_printf( gch, "&G&g(&G&W%sGrupo: %s&g)&G&W %s%s\n\r",color_str(AT_GTELL, gch), PERS(ch, gch), color_str(AT_GTELL, gch), scramble(argument, ch->speaking) );
act_comm.c:    if ( ach->leader ) ach = ach->leader;
act_comm.c:    if ( bch->leader ) bch = bch->leader;
act_comm.c:	if ( IS_NPC(ch) && !ch->speaks ) /* No langs = knows all for npcs */
act_comm.c:	if ( IS_NPC(ch) && IS_SET(ch->speaks, (language & ~LANG_CLAN)) )
act_comm.c:		if ( ch->pcdata->clan == cch->pcdata->clan &&
act_comm.c:			 ch->pcdata->clan != NULL )
act_comm.c:	    if ( IS_SET(race_table[ch->race].language, language) )
act_comm.c:	      	   IS_SET(ch->speaks, lang_array[lang]) )
act_comm.c:		  &&    ch->pcdata->learned[sn] >= 60 )
act_comm.c:	if ( race_table[ch->race].language & language )
act_comm.c:	if ( ch->speaks & language )
act_comm.c:				if ( ch->pcdata->learned[sn] >= 99 )
act_comm.c:		ch->speaking = ~LANG_CLAN;
act_comm.c:	if ( !str_prefix( arg, "basico" ) && ch->race == RACE_WOOKIEE )
act_comm.c:	if ( !str_prefix( arg, "twilek" ) && ch->race != RACE_TWI_LEK )
act_comm.c:					(IS_NPC(ch) || !ch->pcdata->clan) )
act_comm.c:				ch->speaking = lang_array[langs];
act_comm.c:		if ( race_table[ch->race].language & lang_array[lang] ||
act_comm.c:			 ch->pcdata->learned[sn] >= 99 )
act_comm.c:		for ( sch = ch->in_room->first_person; sch; sch = sch->next )
act_comm.c:			if ( IS_NPC(sch) && IS_SET(sch->act, ACT_SCHOLAR) &&
act_comm.c:					knows_language( sch, ch->speaking, ch ) &&
act_comm.c:					(!sch->speaking || knows_language( ch, sch->speaking, sch )) )
act_comm.c:		ch->pcdata->learned[sn] += prct;
act_comm.c:		ch->pcdata->learned[sn] = UMIN(ch->pcdata->learned[sn], 99);
act_comm.c:		SET_BIT( ch->speaks, lang_array[lang] );
act_comm.c:		if ( ch->pcdata->learned[sn] == prct )
act_comm.c:		else if ( ch->pcdata->learned[sn] < 60 )
act_comm.c:		else if ( ch->pcdata->learned[sn] < 60 + prct )
act_comm.c:		else if ( ch->pcdata->learned[sn] < 99 )
act_comm.c:			if ( ch->speaking & lang_array[lang] ||
act_comm.c:				(IS_NPC(ch) && !ch->speaking) )
act_comm.c:			   ch_printf( ch , "(%3d) ", ch->pcdata->learned[sn] );
act_comm.c: for(och = first_char; och; och = och->next)
act_comm.c:   if(IS_NPC(och) || !och->comfreq)
act_comm.c:   if(!str_cmp(och->pcdata->tell_snoop, ch->comfreq) || !str_cmp(och->pcdata->tell_snoop, victim->comfreq))
act_comm.c:     ch_printf(och, "&B[&cMensaje interceptado&b]\n\r&B(&YEnviado: &G&W%s&B) (&Ya: &G&W%s&B) (&Ymessage&B) &G&W %s\n\r", ch->comfreq, victim->comfreq, tell);
act_info.c:    if ( !ch->desc )
act_info.c:	   if ( IS_NPC(ch) || IS_SET(ch->act, PLR_COMBINE) )
act_info.c:    ms  = (ch->mental_state ? ch->mental_state : 1)
act_info.c:	* (IS_NPC(ch) ? 1 : (ch->pcdata->condition[COND_DRUNK] ? (ch->pcdata->condition[COND_DRUNK]/12) : 1));
act_info.c:	   if ( IS_NPC(ch) || IS_SET(ch->act, PLR_COMBINE) )
act_info.c:	    if ( IS_NPC(ch) || IS_SET(ch->act, PLR_COMBINE) )
act_info.c:/*	if ( IS_NPC(ch) || IS_SET(ch->act, PLR_COMBINE) ) */
act_info.c:	if ( IS_NPC(ch) || IS_SET(ch->act, PLR_COMBINE) )
act_info.c:          if (ch->position == POS_SITTING
act_info.c:          ||  ch->position == POS_RESTING )
act_info.c:          if (ch->position == POS_RESTING)
act_info.c:	  if (ch->position == POS_MOUNTED)
act_info.c:	ch_printf(ch, "Eres de complexión %s y tu altura es %s.\n\r", build_name[ch->build], height_name[ch->pheight]);
act_info.c:	ch_printf(ch, "Tu aspecto es %s y %s.\n\r", droid_name[ch->build], height_name[ch->pheight]);
act_info.c:     if(ch->pcdata->disguise && ch->pcdata->disguise[0] != '\0')
act_info.c:	ch_printf(ch, "Te has disfrazado de %s\n\r", ch->pcdata->disguise);
act_info.c:    if ( number_percent( ) < ch->pcdata->learned[gsn_peek] )
act_info.c:      if ( ch->pcdata->learned[gsn_peek] )
act_info.c:    for ( rch = list; rch; rch = rch->next_in_room )
act_info.c:	else if ( rch->race == RACE_DEFEL )
act_info.c:	else if ( room_is_dark( ch->in_room )
act_info.c:    if ( !IS_NPC(ch) && IS_SET(ch->act, PLR_HOLYLIGHT) )
act_info.c:    if ( !ch->desc )
act_info.c:    if ( ch->position < POS_SLEEPING )
act_info.c:    if ( ch->position == POS_SLEEPING )
act_info.c:    &&   !IS_SET(ch->act, PLR_HOLYLIGHT)
act_info.c:    &&   room_is_dark( ch->in_room ) )
act_info.c:	show_char_to_char( ch->in_room->first_person, ch );
act_info.c:	ch_printf(ch, "&R-=&r( &G&W%s%s &G&r)&R=-&C&w ", color_str( AT_RMNAME, ch), ch->in_room->name);
act_info.c:	//send_to_char( ch->in_room->name, ch);
act_info.c:        if ( !ch->desc->original )
act_info.c:  	  if ((get_trust(ch) >= LEVEL_IMMORTAL) && (IS_SET(ch->pcdata->flags, PCFLAG_ROOM)))
act_info.c:                 if( IS_SET( ch->act, PLR_ROOMVNUM ) )
act_info.c:                     ch_printf( ch, "&G&W%s%d", color_str(AT_RVNUM, ch), ch->in_room->vnum );
act_info.c:                 if( IS_SET( ch->pcdata->flags, PCFLAG_ROOM ) )
act_info.c:                     send_to_char( flag_string( ch->in_room->room_flags, r_flags ), ch );
act_info.c:                     if( ch->in_room->room_flags2 != 0 )
act_info.c:                        send_to_char( flag_string( ch->in_room->room_flags2, r_flags2 ), ch );
act_info.c:	|| ( !IS_NPC(ch) && !IS_SET(ch->act, PLR_BRIEF) ) )
act_info.c:	    send_to_char( ch->in_room->description, ch );
act_info.c:        if( !IS_NPC(ch) && IS_SET(ch->act, PLR_AUTOEXIT) )
act_info.c:         if ( IS_SET(ch->pcdata->flags, PCFLAG_MAP))
act_info.c:	show_ships_to_char( ch->in_room->first_ship, ch );
act_info.c:        show_list_to_char( ch->in_room->first_content, ch, FALSE, FALSE );
act_info.c:        show_char_to_char( ch->in_room->first_person, ch );
act_info.c:	if (   (ship = ship_from_cockpit(ch->in_room->vnum))  != NULL )
act_info.c:	            original = ch->in_room;
act_info.c:	if ( ch->carry_weight + obj->weight > can_carry_w( ch ) )
act_info.c:	    for ( pexit = ch->in_room->first_exit; pexit; pexit = pexit->next )
act_info.c:		    original = ch->in_room;
act_info.c:    if ( (pdesc=get_extra_descr(arg1, ch->in_room->first_extradesc)) != NULL )
act_info.c:            int percent = ch->pcdata->learned[ skill_lookup("scry") ];
act_info.c:        original = ch->in_room;
act_info.c:           if ( (to_room=generate_exit(ch->in_room, &pexit)) != NULL )
act_info.c:    for ( cnt = 0, obj = ch->last_carrying; obj; obj = obj->prev_content )
act_info.c:    for ( obj = ch->in_room->last_content; obj; obj = obj->prev_content )
act_info.c:  if ( !ch->desc )
act_info.c:  if ( ch->position < POS_SLEEPING )
act_info.c:  if ( ch->position == POS_SLEEPING )
act_info.c:    save_act = ch->act;
act_info.c:    SET_BIT( ch->act, PLR_BRIEF );
act_info.c:    ch->act = save_act;
act_info.c:       && !IS_SET( ch->act, PLR_HOLYLIGHT )
act_info.c:       && !IS_AFFECTED( ch, AFF_TRUESIGHT ) && !IS_AFFECTED( ch, AFF_INFRARED ) && room_is_dark( ch->in_room ) )
act_info.c:    for ( pexit = ch->in_room->first_exit; pexit; pexit = pexit->next )
act_info.c:    if ( !IS_NPC(ch) && IS_SET( ch->act , PLR_SOUND ) )
act_info.c:    if ( !ch->desc )
act_info.c:    switch( ch->substate )
act_info.c:	  if ( (pHelp = ch->dest_buf) == NULL )
act_info.c:		bug( "hedit: sub_help_edit: NULL ch->dest_buf", 0 );
act_info.c:    ch->substate = SUB_HELP_EDIT;
act_info.c:    ch->dest_buf = pHelp;
act_info.c:	if ( wch->top_level < iLevelLower
act_info.c:	||   wch->top_level > iLevelUpper 
act_info.c:	|| ( fImmortalOnly  && wch->top_level < LEVEL_IMMORTAL )
act_info.c:	|| ( fRaceRestrict && !rgfRace[wch->race] ))
act_info.c:	&&   wch->pcdata->homepage
act_info.c:	&&   wch->pcdata->homepage[0] != '\0' )
act_info.c:		show_tilde( wch->pcdata->homepage ), wch->name );
act_info.c:    if((wch->rank == NULL || !str_cmp(wch->rank, "(null)")) && !IS_IMMORTAL(wch)) 
act_info.c:                wch->rank = str_dup("   "); 
act_info.c:	sprintf( race_text, "&G&w%s&G&c &G&w", wch->rank);
act_info.c:      if ( !wch->rank || (wch->rank[0] == '\0')  ) 	//If the imm has set thier rank show it instead --Odis ->KeB
act_info.c:			switch ( wch->top_level )
act_info.c:        if ( ch && !nifty_is_name(wch->name, remand(wch->pcdata->title)) && ch->top_level > wch->top_level )
act_info.c:          sprintf( extra_title , " [%s]" , wch->name );
act_info.c:	else if ( wch->rank && wch->rank[0] != '\0' )
act_info.c:	  race = wch->rank;
act_info.c:if (ch && ch->pcdata && ch->pcdata->clan && wch->pcdata->clan 
act_info.c:    && (ch->pcdata->clan == wch->pcdata->clan 
act_info.c:    || ch->top_level >= LEVEL_IMMORTAL))  
act_info.c:          CLAN_DATA *pclan = wch->pcdata->clan;
act_info.c:	    if ( !str_cmp( wch->name, pclan->leader ) )
act_info.c:            if ( !str_cmp( wch->name, pclan->number1 ) )
act_info.c:            if ( !str_cmp( wch->name, pclan->number2 ) )
act_info.c:	if ( IS_SET(wch->act, PLR_WIZINVIS) )
act_info.c:	  sprintf( invis_str, "(%d)", wch->pcdata->wizinvis );
act_info.c:	    IS_SET(wch->act, PLR_AFK) ? "[AFK]" : "",
act_info.c:	    wch->pcdata->title,
act_info.c:        if( !ch->pcdata->clan)
act_info.c:	if(!ch->pcdata->clan && str_cmp(arg1, "self"))
act_info.c:	if(str_cmp(ch->pcdata->clan->leader, ch->name) && str_cmp(ch->pcdata->clan->number1, ch->name) && !IS_IMMORTAL(ch))
act_info.c:	if(ch->pcdata->clan != vict->pcdata->clan && !IS_IMMORTAL(ch))
act_info.c:	if(ch->pcdata->clan && !isleader && !str_cmp(arg1, "self"))
act_info.c:	if((ch->pcdata->clan && isleader && !str_cmp(arg1,"self")) || (!ch->pcdata->clan && !str_cmp(arg1, "self")))
act_info.c:	for ( obj2 = ch->first_carrying; obj2; obj2 = obj2->next_content )
act_info.c:           pager_printf( ch, "Players near you in %s:\n\r", ch->in_room->area->name );
act_info.c:	    &&   (victim->in_room->area == ch->in_room->area || get_trust(ch) >= LEVEL_IMMORTAL )
act_info.c:	    &&   victim->in_room->area == ch->in_room->area
act_info.c:    diff = ch->hit * 100 / con_hp;
act_info.c:    diff = victim->armor - ch->armor;
act_info.c:    diff = victim->top_level - ch->top_level + GET_HITROLL(victim) - GET_HITROLL(ch);
act_info.c:    diff = victim->top_level - ch->top_level + GET_DAMROLL(victim) - GET_DAMROLL(ch);
act_info.c:	    if (  ch->pcdata->learned[sn] <= 0  &&  ch->skill_level[skill_table[sn]->guild] < skill_table[sn]->min_level )
act_info.c:	    if ( ch->pcdata->learned[sn] == 0
act_info.c:		 ch->pcdata->learned[sn],skill_table[sn]->alignment == 0 ? "&G" : skill_table[sn]->alignment == -1001 ? "&R" : "&B",skill_table[sn]->name );
act_info.c:	for ( mob = ch->in_room->first_person; mob; mob = mob->next_in_room )
act_info.c:	&&   ch->skill_level[skill_table[sn]->guild] < skill_table[sn]->min_level )
act_info.c:	if ( ch->pcdata->learned[sn] >= adept )
act_info.c:	    ch->pcdata->learned[sn] += int_app[get_curr_int(ch)].learn;
act_info.c:	    if ( ch->pcdata->learned[sn] >= adept )
act_info.c:		ch->pcdata->learned[sn] = adept;
act_info.c:	if ( ch->pcdata->learned[sn] < 100 )
act_info.c:	wimpy = (int) ch->max_hit / 5;
act_info.c:    if ( wimpy > ch->max_hit )
act_info.c:    ch->wimpy	= wimpy;
act_info.c:    if ( strcmp( smaug_crypt( arg1 ), ch->pcdata->pwd ) )
act_info.c:        log_string( ch->pcdata->pwd );
act_info.c:    DISPOSE( ch->pcdata->pwd );
act_info.c:    ch->pcdata->pwd = str_dup( pwdnew );
act_info.c:	if ( !IS_NPC(ch) && IS_SET(ch->act, PLR_SILENCE) )
act_info.c:	 send_to_char( !IS_SET(ch->deaf, CHANNEL_AUCTION)
act_info.c:	send_to_char( !IS_SET(ch->deaf, CHANNEL_CHAT)
act_info.c:        send_to_char( !IS_SET(ch->deaf, CHANNEL_OOC)
act_info.c:	if ( !IS_NPC( ch ) && ch->pcdata->clan )
act_info.c: 	    send_to_char( !IS_SET(ch->deaf, CHANNEL_CLAN)
act_info.c:	send_to_char( !IS_SET(ch->deaf, CHANNEL_QUEST)
act_info.c:	send_to_char( !IS_SET( ch->deaf, CHANNEL_TELLS )
act_info.c:        send_to_char( !IS_SET( ch->deaf, CHANNEL_WARTALK )
act_info.c:	    send_to_char( !IS_SET(ch->deaf, CHANNEL_AVTALK)
act_info.c:	    send_to_char( !IS_SET(ch->deaf, CHANNEL_IMMTALK)
act_info.c:	    send_to_char( !IS_SET(ch->deaf, CHANNEL_PRAY)
act_info.c:	send_to_char( !IS_SET(ch->deaf, CHANNEL_MUSIC)
act_info.c:	send_to_char( !IS_SET(ch->deaf, CHANNEL_ASK)
act_info.c:	send_to_char( !IS_SET(ch->deaf, CHANNEL_SHOUT)
act_info.c:	send_to_char( !IS_SET(ch->deaf, CHANNEL_YELL)
act_info.c:	    send_to_char( !IS_SET(ch->deaf, CHANNEL_MONITOR)
act_info.c:	send_to_char( !IS_SET(ch->deaf, CHANNEL_NEWBIE)
act_info.c:	send_to_char( !IS_SET(ch->deaf, CHANNEL_SPORTS)
act_info.c:	send_to_char( !IS_SET(ch->deaf, CHANNEL_HOLONET)
act_info.c:	    send_to_char( !IS_SET(ch->deaf, CHANNEL_LOG)
act_info.c:	    send_to_char( !IS_SET(ch->deaf, CHANNEL_BUILD)
act_info.c:            send_to_char( !IS_SET(ch->deaf, CHANNEL_COMM)
act_info.c:            REMOVE_BIT (ch->deaf, CHANNEL_AUCTION);
act_info.c:            REMOVE_BIT (ch->deaf, CHANNEL_CHAT);
act_info.c:            REMOVE_BIT (ch->deaf, CHANNEL_QUEST);
act_info.c:       /*     REMOVE_BIT (ch->deaf, CHANNEL_IMMTALK); */
act_info.c:            REMOVE_BIT (ch->deaf, CHANNEL_PRAY);
act_info.c:            REMOVE_BIT (ch->deaf, CHANNEL_MUSIC);
act_info.c:            REMOVE_BIT (ch->deaf, CHANNEL_ASK);
act_info.c:            REMOVE_BIT (ch->deaf, CHANNEL_SHOUT);
act_info.c:            REMOVE_BIT (ch->deaf, CHANNEL_YELL);
act_info.c:            REMOVE_BIT (ch->deaf, CHANNEL_SPORTS);
act_info.c:            REMOVE_BIT (ch->deaf, CHANNEL_HOLONET);
act_info.c:       /*     if (ch->pcdata->clan)
act_info.c:              REMOVE_BIT (ch->deaf, CHANNEL_CLAN);
act_info.c:            if (ch->pcdata->guild)
act_info.c:              REMOVE_BIT (ch->deaf, CHANNEL_GUILD);
act_info.c:            if (ch->top_level >= LEVEL_IMMORTAL)
act_info.c:              REMOVE_BIT (ch->deaf, CHANNEL_AVTALK);
act_info.c:	    if (ch->top_level >= sysdata.log_level )
act_info.c:	      REMOVE_BIT (ch->deaf, CHANNEL_COMM);
act_info.c:            SET_BIT (ch->deaf, CHANNEL_AUCTION);
act_info.c:            SET_BIT (ch->deaf, CHANNEL_CHAT);
act_info.c:            SET_BIT (ch->deaf, CHANNEL_QUEST);
act_info.c:       /*     SET_BIT (ch->deaf, CHANNEL_IMMTALK); */
act_info.c:            SET_BIT (ch->deaf, CHANNEL_PRAY);
act_info.c:            SET_BIT (ch->deaf, CHANNEL_MUSIC);
act_info.c:            SET_BIT (ch->deaf, CHANNEL_ASK);
act_info.c:            SET_BIT (ch->deaf, CHANNEL_SHOUT);
act_info.c:            SET_BIT (ch->deaf, CHANNEL_YELL);
act_info.c:            if (ch->top_level >= LEVEL_IMMORTAL)
act_info.c:              SET_BIT (ch->deaf, CHANNEL_AVTALK);
act_info.c:	    if (ch->top_level >= sysdata.log_level)
act_info.c:	      SET_BIT (ch->deaf, CHANNEL_COMM);
act_info.c:	    REMOVE_BIT (ch->deaf, bit);
act_info.c:	    SET_BIT    (ch->deaf, bit);
act_info.c:	/*send_to_char(  IS_SET(ch->pcdata->flags, PCFLAG_NORECALL)
act_info.c:	send_to_char(  IS_SET(ch->act, PLR_AUTOEXIT)
act_info.c:        send_to_char( IS_SET(ch->pcdata->flags, PCFLAG_MAP)
act_info.c:	send_to_char(  IS_SET(ch->act, PLR_AUTOLOOT)
act_info.c:/*	send_to_char(  IS_SET(ch->act, PLR_AUTOSAC)
act_info.c:	send_to_char(  IS_SET(ch->act, PLR_AUTOGOLD)
act_info.c:        send_to_char(  IS_SET(ch->pcdata->flags, PCFLAG_GAG)       
act_info.c:        send_to_char(  IS_SET(ch->pcdata->flags, PCFLAG_PAGERON)
act_info.c:	send_to_char(  IS_SET(ch->act, PLR_BLANK)
act_info.c:	send_to_char(  IS_SET(ch->act, PLR_BRIEF)
act_info.c:	send_to_char(  IS_SET(ch->act, PLR_COMBINE)
act_info.c:	send_to_char(  IS_SET(ch->pcdata->flags, PCFLAG_NOINTRO)
act_info.c:	send_to_char(  IS_SET(ch->act, PLR_PROMPT)
act_info.c:	send_to_char(  IS_SET(ch->act, PLR_TELNET_GA)
act_info.c:	send_to_char(  IS_SET(ch->act, PLR_ANSI)
act_info.c:	send_to_char(  IS_SET(ch->act, PLR_SOUND)
act_info.c:	send_to_char(  IS_SET(ch->act, PLR_SHOVEDRAG)
act_info.c:	  send_to_char(  IS_SET(ch->act, PLR_ROOMVNUM)
act_info.c:	  send_to_char( IS_SET(ch->pcdata->flags, PCFLAG_ROOM)
act_info.c:	send_to_char(  IS_SET(ch->act, PLR_SILENCE)
act_info.c:	send_to_char( !IS_SET(ch->act, PLR_NO_EMOTE)
act_info.c:	send_to_char( !IS_SET(ch->act, PLR_NO_TELL)
act_info.c:	send_to_char( !IS_SET(ch->act, PLR_LITTERBUG)
act_info.c:	    SET_BIT    (ch->act, bit);
act_info.c:	    REMOVE_BIT (ch->act, bit);
act_info.c:	    SET_BIT    (ch->pcdata->flags, bit);
act_info.c:	    REMOVE_BIT (ch->pcdata->flags, bit);
act_info.c:     if IS_SET(ch->act, PLR_AFK)
act_info.c:    	REMOVE_BIT(ch->act, PLR_AFK);
act_info.c:	SET_BIT(ch->act, PLR_AFK);
act_info.c:	    if ( ch->pcdata->learned[sn] == 0
act_info.c:    if ( IS_SET(ch->pcdata->flags, PCFLAG_PAGERON) )
act_info.c:  ch->pcdata->pagerlen = atoi(arg);
act_info.c:  if ( ch->pcdata->pagerlen < 5 )
act_info.c:    ch->pcdata->pagerlen = 5;
act_info.c:  ch_printf( ch, "Pausa extablecida a %d líneas.\n\r", ch->pcdata->pagerlen );
act_info.c:        if ( !str_cmp( argument , wch->name ) )
act_info.c:     if IS_SET(ch->act, PLR_WHOINVIS)
act_info.c:    	REMOVE_BIT(ch->act, PLR_WHOINVIS);
act_info.c:	SET_BIT(ch->act, PLR_WHOINVIS);
act_info.c:   if (ch->pcdata->disguise[0] != '\0')
act_info.c:        for ( rch = ch->in_room->first_person; rch; rch = rch->next_in_room )
act_info.c:            sprintf(buf, "__%s ", rch->name);
act_info.c:      if(!str_cmp(vfellow->victim, ch->name))
act_info.c:       fellow->victim = STRALLOC(ch->name);
act_info.c:   for(fellow=ch->first_fellow; fellow; fellow=fellow->next)
act_info.c:       LINK(nfellow, ch->first_fellow, ch->last_fellow,next, prev);
act_info.c:   for(fellow=ch->first_fellow; fellow; fellow=fellow->next)
act_info.c:    for ( pexit = ch->in_room->first_exit; pexit; pexit = pexit->next )
act_move.c:    if( ch->plr_home )
act_move.c:      return ch->plr_home->vnum;
act_move.c:    if( ch->race  == RACE_HUMAN)
act_move.c:    if( ch->race  == RACE_WOOKIEE)
act_move.c:    if( ch->race  == RACE_RODIAN)
act_move.c:    if( ch->race  == RACE_MON_CALAMARI)
act_move.c:    if( ch->race  == RACE_TWI_LEK)
act_move.c:    if( ch->race  == RACE_HUTT)
act_move.c:    if( ch->race  == RACE_GAMORREAN)
act_move.c:    if( ch->race  == RACE_JAWA)
act_move.c:    if( ch->race  == RACE_ADARIAN)
act_move.c:    if( ch->race  == RACE_EWOK)
act_move.c:    if( ch->race  == RACE_VERPINE)
act_move.c:    if( ch->race  == RACE_DEFEL)
act_move.c:    if( ch->race  == RACE_TRANDOSHAN)
act_move.c:    if( ch->race  == RACE_HAPAN)
act_move.c:    if( ch->race  == RACE_QUARREN)
act_move.c:    if( ch->race  == RACE_NOGHRI)
act_move.c:    cur = ch->carry_weight;
act_move.c:    if ( IS_SET( ch->in_room->room_flags, ROOM_NOFLOOR )
act_move.c:    || ( ch->mount && !IS_AFFECTED( ch->mount, AFF_FLYING ) ) ) )
act_move.c:	   bug( "Falling (in a loop?) more than 80 rooms: vnum %d", ch->in_room->vnum );
act_move.c:	move_char( ch, get_exit(ch->in_room, DIR_DOWN), ++fall );
act_move.c:      if ( IS_DRUNK( ch, 2 ) && ( ch->position != POS_SHOVE )
act_move.c:	&& ( ch->position != POS_DRAG ) )
act_move.c:      pexit = get_exit( ch->in_room, door );
act_move.c:	sprintf( buf, "move_char: %s to door %d", ch->name, pexit->vdir );
act_move.c:    if ( IS_NPC(ch) && IS_SET( ch->act, ACT_MOUNTED ) )
act_move.c:    in_room = ch->in_room;
act_move.c:    &&   ch->master
act_move.c:    &&   in_room == ch->master->in_room )
act_move.c:    if ( room_is_private( ch, to_room ) && (ch->top_level < sysdata.privwoverride)  )
act_move.c:    if ( room_is_private( ch, to_room ) && (ch->top_level > sysdata.privwoverride)  )
act_move.c:    &&  ch->in_room->area != to_room->area )
act_move.c:	if ( ch->top_level < to_room->area->low_hard_range )
act_move.c:	    switch( to_room->area->low_hard_range - ch->top_level )
act_move.c:	if ( ch->top_level > to_room->area->hi_hard_range )
act_move.c:	    if ( iClass != ch->class
act_move.c:	    if ( ch->mount && !IS_AFFECTED( ch->mount, AFF_FLYING ) )
act_move.c:	    if ( !ch->mount && !IS_AFFECTED(ch, AFF_FLYING) )
act_move.c:	    if ( ch->mount )
act_move.c:		if ( IS_AFFECTED( ch->mount, AFF_FLYING )
act_move.c:		||   IS_AFFECTED( ch->mount, AFF_FLOATING ) )
act_move.c:	      for ( obj = ch->first_carrying; obj; obj = obj->next_content )
act_move.c:	    if ( ch->mount && IS_AFFECTED( ch->mount, AFF_FLYING ) )
act_move.c:	    if ( !found && !ch->mount )
act_move.c:		if ( ( !IS_NPC(ch) && number_percent( ) > ch->pcdata->learned[gsn_climb] )
act_move.c:		||      drunk || ch->mental_state < -90 )
act_move.c:	if ( ch->mount )
act_move.c:	  switch (ch->mount->position)
act_move.c:	  if ( !IS_AFFECTED(ch->mount, AFF_FLYING)
act_move.c:	  &&   !IS_AFFECTED(ch->mount, AFF_FLOATING) )
act_move.c:	  if ( ch->mount->move < move )
act_move.c:	  if ( ch->move < move )
act_move.c:	if ( ch->mount )
act_move.c:	  ch->mount->move -= move;
act_move.c:	  ch->move -= move;
act_move.c:	int count = ch->mount ? 1 : 0;
act_move.c:		if ( ch->mount && count == to_room->tunnel )
act_move.c:    && ( IS_NPC(ch) || !IS_SET(ch->act, PLR_WIZINVIS) ) )
act_move.c:        if ( ch->mount )
act_move.c:	  if ( IS_AFFECTED( ch->mount, AFF_FLOATING ) )
act_move.c:	  if ( IS_AFFECTED( ch->mount, AFF_FLYING ) )
act_move.c:          if ( ch->position == POS_SHOVE )
act_move.c:	  if ( ch->position == POS_DRAG )
act_move.c:		if(ch->race == RACE_ASTROMECH_DROID)
act_move.c:      if ( ch->mount )
act_move.c:	act( AT_ACTION, buf, ch, NULL, ch->mount, TO_NOTVICT );
act_move.c:   if ( ch->mount )
act_move.c:      rprog_leave_trigger( ch->mount );
act_move.c:      if( char_died(ch->mount) )
act_move.c:      if( ch->mount )
act_move.c:        char_from_room( ch->mount );
act_move.c:        char_to_room( ch->mount, to_room );
act_move.c:    && ( IS_NPC(ch) || !IS_SET(ch->act, PLR_WIZINVIS) ) )
act_move.c:      if ( ch->mount )
act_move.c:	if ( IS_AFFECTED( ch->mount, AFF_FLOATING ) )
act_move.c:	if ( IS_AFFECTED( ch->mount, AFF_FLYING ) )
act_move.c:	if ( ch->position == POS_SHOVE )
act_move.c:	if ( ch->position == POS_DRAG )
act_move.c:            if(ch->race == RACE_ASTROMECH_DROID) 
act_move.c:      if ( ch->mount )
act_move.c:	act( AT_ACTION, buf, ch, NULL, ch->mount, TO_ROOM );
act_move.c:    &&  ch->in_room->area != to_room->area )
act_move.c:	if ( ch->top_level < to_room->area->low_soft_range )
act_move.c:	if ( ch->top_level > to_room->area->hi_soft_range )
act_move.c:      SET_BIT( ch->act, PLR_BRIEF );
act_move.c:      for ( fch = from_room->first_person; fch; fch = fch->next_in_room )
act_move.c:	nextinroom = fch->next_in_room;
act_move.c:	&& fch->master == ch
act_move.c:	&& fch->position == POS_STANDING )
act_move.c:    if ( ch->in_room->first_content )
act_move.c:	|| ( ch->mount && !IS_AFFECTED( ch->mount, AFF_FLOATING ) ) )
act_move.c:    if (!IS_NPC(ch) && IS_SET(ch->pcdata->act2, ACT_BOUND))
act_move.c:    move_char( ch, get_exit(ch->in_room, DIR_NORTH), 0 );
act_move.c:    if (!IS_NPC(ch) && IS_SET(ch->pcdata->act2, ACT_BOUND))
act_move.c:    move_char( ch, get_exit(ch->in_room, DIR_EAST), 0 );
act_move.c:    if (!IS_NPC(ch) && IS_SET(ch->pcdata->act2, ACT_BOUND))
act_move.c:    move_char( ch, get_exit(ch->in_room, DIR_SOUTH), 0 );
act_move.c:    if (!IS_NPC(ch) && IS_SET(ch->pcdata->act2, ACT_BOUND))
act_move.c:    move_char( ch, get_exit(ch->in_room, DIR_WEST), 0 );
act_move.c:    if (!IS_NPC(ch) && IS_SET(ch->pcdata->act2, ACT_BOUND))
act_move.c:    move_char( ch, get_exit(ch->in_room, DIR_UP), 0 );
act_move.c:    if (!IS_NPC(ch) && IS_SET(ch->pcdata->act2, ACT_BOUND))
act_move.c:    move_char( ch, get_exit(ch->in_room, DIR_DOWN), 0 );
act_move.c:    if (!IS_NPC(ch) && IS_SET(ch->pcdata->act2, ACT_BOUND))
act_move.c:    move_char( ch, get_exit(ch->in_room, DIR_NORTHEAST), 0 );
act_move.c:    if (!IS_NPC(ch) && IS_SET(ch->pcdata->act2, ACT_BOUND))
act_move.c:    move_char( ch, get_exit(ch->in_room, DIR_NORTHWEST), 0 );
act_move.c:    if (!IS_NPC(ch) && IS_SET(ch->pcdata->act2, ACT_BOUND))
act_move.c:    move_char( ch, get_exit(ch->in_room, DIR_SOUTHEAST), 0 );
act_move.c:    if (!IS_NPC(ch) && IS_SET(ch->pcdata->act2, ACT_BOUND))
act_move.c:    move_char( ch, get_exit(ch->in_room, DIR_SOUTHWEST), 0 );
act_move.c:	for ( pexit = ch->in_room->first_exit; pexit; pexit = pexit->next )
act_move.c:    if ( (pexit = get_exit( ch->in_room, door )) == NULL )
act_move.c:	    &&   pexit_rev->to_room == ch->in_room )
act_move.c:		for ( rch = pexit->to_room->first_person; rch; rch = rch->next_in_room )
act_move.c:            sound_to_room( ch->in_room , "!!SOUND(door)" );
act_move.c:	&&   pexit_rev->to_room == ch->in_room )
act_move.c:	    for ( rch = pexit->to_room->first_person; rch; rch = rch->next_in_room )
act_move.c:    for ( obj = ch->first_carrying; obj; obj = obj->next_content )
act_move.c:	&&  ch->pcdata->learned[gsn_bashdoor] <= 0  )
act_move.c:	if ( ch->fighting )
act_move.c:		chance = ch->pcdata->learned[gsn_bashdoor] / 2;
act_move.c:	    &&   ch->move >= 15
act_move.c:		&&    pexit_rev->to_room	== ch->in_room )
act_move.c:			for ( rch = to_room->first_person; rch; rch = rch->next_in_room )
act_move.c:		damage( ch, ch, ( ch->max_hit / 20 ), gsn_bashdoor );
act_move.c:		damage( ch, ch, ( ch->max_hit / 20 ) + 10, gsn_bashdoor );
act_move.c:	    damage( ch, ch, ( ch->max_hit / 20 ) + 10, gsn_bashdoor );
act_move.c:	   for ( gch = ch->in_room->first_person; gch; gch = gch->next_in_room )
act_move.c:		 && !gch->fighting
act_move.c:		 && ( ch->top_level - gch->top_level <= 4 )
act_move.c:   if (ch->position == POS_FIGHTING)
act_move.c:   if (ch->position == POS_MOUNTED)
act_move.c:      obj = get_obj_list(ch, argument, ch->in_room->first_content);
act_move.c:      if (ch->on != obj && count_users(obj) >= val0)
act_move.c:      if (ch->on == obj)
act_move.c:         ch->on = obj;
act_move.c:   switch (ch->position)
act_move.c:            ch->on = NULL;
act_move.c:         ch->position = POS_STANDING;
act_move.c:            ch->on = NULL;
act_move.c:         ch->position = POS_STANDING;
act_move.c:         else if (ch->on != NULL && obj == NULL)
act_move.c:            act(AT_ACTION, "Te bajas de $p y quedas de pie en el suelo.", ch, ch->on, NULL, TO_CHAR);
act_move.c:            act(AT_ACTION, "$n se baja de $p y queda de pie en el suelo.", ch, ch->on, NULL, TO_ROOM);
act_move.c:            ch->on = NULL;
act_move.c:         act(AT_ACTION, "$n pesa mucho para subirse a $p y lo rompe.", ch, ch->on, NULL, TO_ROOM);
act_move.c:         act(AT_ACTION, "Lo intentas, pero tu peso hace que $p se rompa.", ch, ch->on, NULL, TO_CHAR);
act_move.c:         for (fch = obj->in_room->first_person; fch != NULL; fch = fch->next_in_room)
act_move.c:            if (fch->on == obj)
act_move.c:               if (fch->position == POS_RESTING)
act_move.c:                  fch->hit = (fch->hit - 30);
act_move.c:                  if (fch->hit <= 0)
act_move.c:                     fch->hit = 1;
act_move.c:                  act(AT_ACTION, "Tu descanso se interrumpe cuando caes al suelo al romperse $p.", fch, fch->on, NULL, TO_CHAR);
act_move.c:               if (fch->position == POS_SLEEPING)
act_move.c:                  fch->hit = (fch->hit - 40);
act_move.c:                  if (fch->hit <= 0)
act_move.c:                     fch->hit = 1;
act_move.c:                  fch->position = POS_RESTING;
act_move.c:                  act(AT_ACTION, "Tu sueño se interrumpe cuando caes al suelo al romperse $p.", fch, fch->on, NULL, TO_CHAR);
act_move.c:               if (fch->position == POS_SITTING)
act_move.c:                  fch->hit = (fch->hit - 5);
act_move.c:                  if (fch->hit <= 0)
act_move.c:                     fch->hit = 1;
act_move.c:                  act(AT_ACTION, "$p se rompe y caes al suelo.", fch, fch->on, NULL, TO_CHAR);
act_move.c:               if (fch->position == POS_STANDING)
act_move.c:                  fch->hit = (fch->hit - 55);
act_move.c:                  if (fch->hit <= 0)
act_move.c:                     fch->hit = 1;
act_move.c:                  act(AT_ACTION, "Caes al suelo cuando $p se rompe.", fch, fch->on, NULL, TO_CHAR);
act_move.c:               fch->on = NULL;
act_move.c:   if (ch->position == POS_FIGHTING)
act_move.c:   if (ch->position == POS_MOUNTED)
act_move.c:      obj = get_obj_list(ch, argument, ch->in_room->first_content);
act_move.c:      if (ch->on != obj && count_users(obj) >= val0)
act_move.c:      if (ch->on == obj)
act_move.c:         ch->on = obj;
act_move.c:   if (ch->on && argument[0] == '\0')
act_move.c:      if (!IS_SET(ch->on->value[2], SIT_AT) && !IS_SET(ch->on->value[2], SIT_ON) &&
act_move.c:          !IS_SET(ch->on->value[2], SIT_IN))
act_move.c:   switch (ch->position)
act_move.c:            ch->on = NULL;
act_move.c:         ch->position = POS_SITTING;
act_move.c:            ch->on = NULL;
act_move.c:         ch->position = POS_SITTING;
act_move.c:         else if (ch->on != NULL && obj == NULL)
act_move.c:            act(AT_ACTION, "Te bajas de $p y te sientas en el suelo.", ch, ch->on, NULL, TO_CHAR);
act_move.c:            act(AT_ACTION, "$n se baja de $p y se sienta en el suelo.", ch, ch->on, NULL, TO_ROOM);
act_move.c:            ch->on = NULL;
act_move.c:            ch->on = NULL;
act_move.c:         ch->position = POS_SITTING;
act_move.c:         act(AT_ACTION, "El peso de $n es demasiado para $p.", ch, ch->on, NULL, TO_ROOM);
act_move.c:         act(AT_ACTION, "Tu intento de sentarte sobre $p causa que se rompa.", ch, ch->on, NULL, TO_CHAR);
act_move.c:         for (fch = obj->in_room->first_person; fch != NULL; fch = fch->next_in_room)
act_move.c:            if (fch->on == obj)
act_move.c:               if (fch->position == POS_RESTING)
act_move.c:                  fch->hit = (fch->hit - 30);
act_move.c:                  if (fch->hit <= 0)
act_move.c:                     fch->hit = 1;
act_move.c:                  act(AT_ACTION, "Tu descanso es interrumpido cuando $p se rompe.", fch, fch->on, NULL, TO_CHAR);
act_move.c:               if (fch->position == POS_SLEEPING)
act_move.c:                  fch->hit = (fch->hit - 40);
act_move.c:                  if (fch->hit <= 0)
act_move.c:                     fch->hit = 1;
act_move.c:                  fch->position = POS_RESTING;
act_move.c:                  act(AT_ACTION, "Tu sueño es interrumpido cuando $p se rompe.", fch, fch->on, NULL, TO_CHAR);
act_move.c:               if (fch->position == POS_SITTING)
act_move.c:                  fch->hit = (fch->hit - 5);
act_move.c:                  if (fch->hit <= 0)
act_move.c:                     fch->hit = 1;
act_move.c:                  act(AT_ACTION, "Tu descanso es interrumpido cuando $p se rompe.", fch, fch->on, NULL, TO_CHAR);
act_move.c:               if (fch->position == POS_STANDING)
act_move.c:                  fch->hit = (fch->hit - 55);
act_move.c:                  if (fch->hit <= 0)
act_move.c:                     fch->hit = 1;
act_move.c:                  act(AT_ACTION, "Caes al suelo cuando $p se compe.", fch, fch->on, NULL, TO_CHAR);
act_move.c:               fch->on = NULL;
act_move.c:   if (ch->position == POS_FIGHTING)
act_move.c:   if (ch->position == POS_MOUNTED)
act_move.c:      obj = get_obj_list(ch, argument, ch->in_room->first_content);
act_move.c:      if (ch->on != obj && count_users(obj) >= val0)
act_move.c:      if (ch->on == obj)
act_move.c:         ch->on = obj;
act_move.c:   if (ch->on && argument[0] == '\0')
act_move.c:      if (!IS_SET(ch->on->value[2], REST_AT) && !IS_SET(ch->on->value[2], REST_ON) &&
act_move.c:          !IS_SET(ch->on->value[2], REST_IN))
act_move.c:   switch (ch->position)
act_move.c:            ch->on = NULL;
act_move.c:         ch->position = POS_RESTING;
act_move.c:         else if (ch->on != NULL && obj == NULL)
act_move.c:            act(AT_ACTION, "Te bajas de $p y comienzas a descansar en el suelo.", ch, ch->on, NULL, TO_CHAR);
act_move.c:            act(AT_ACTION, "$n se baja de $p y comienza a descansar en el suelo.", ch, ch->on, NULL, TO_ROOM);
act_move.c:            ch->on = NULL;
act_move.c:            ch->on = NULL;
act_move.c:         ch->position = POS_RESTING;
act_move.c:            ch->on = NULL;
act_move.c:         ch->position = POS_RESTING;
act_move.c:         act(AT_ACTION, "El peso de $n es demasiado para $p.", ch, ch->on, NULL, TO_ROOM);
act_move.c:         act(AT_ACTION, "Tu intento de sentarte sobre $p causa que se rompa.", ch, ch->on, NULL, TO_CHAR);
act_move.c:         for (fch = obj->in_room->first_person; fch != NULL; fch = fch->next_in_room)
act_move.c:            if (fch->on == obj)
act_move.c:               if (fch->position == POS_RESTING)
act_move.c:                  fch->hit = (fch->hit - 30);
act_move.c:                  if (fch->hit <= 0)
act_move.c:                     fch->hit = 1;
act_move.c:                  act(AT_ACTION, "Tu descanso se interrumpe cuando caes al suelo al romperse $p.", fch, fch->on, NULL, TO_CHAR);
act_move.c:               if (fch->position == POS_SLEEPING)
act_move.c:                  fch->hit = (fch->hit - 40);
act_move.c:                  if (fch->hit <= 0)
act_move.c:                     fch->hit = 1;
act_move.c:                  fch->position = POS_RESTING;
act_move.c:                  act(AT_ACTION, "Tu sueño se interrumpe cuando caes al suelo después de que $p se rompa.", fch, fch->on, NULL, TO_CHAR);
act_move.c:               if (fch->position == POS_SITTING)
act_move.c:                  fch->hit = (fch->hit - 5);
act_move.c:                  if (fch->hit <= 0)
act_move.c:                     fch->hit = 1;
act_move.c:                  act(AT_ACTION, "Tu descanso se interrumpe cuando $p se rompe y caes al suelo.", fch, fch->on, NULL, TO_CHAR);
act_move.c:               if (fch->position == POS_STANDING)
act_move.c:                  fch->hit = (fch->hit - 55);
act_move.c:                  if (fch->hit <= 0)
act_move.c:                     fch->hit = 1;
act_move.c:                  act(AT_ACTION, "Caes al suelo cuando $p se rompe.", fch, fch->on, NULL, TO_CHAR);
act_move.c:               fch->on = NULL;
act_move.c:   if (ch->position == POS_FIGHTING)
act_move.c:   if (ch->position == POS_MOUNTED)
act_move.c:      obj = get_obj_list(ch, argument, ch->in_room->first_content);
act_move.c:      if (ch->on != obj && count_users(obj) >= val0)
act_move.c:      if (ch->on == obj)
act_move.c:         ch->on = obj;
act_move.c:   if (ch->on && argument[0] == '\0')
act_move.c:      if (!IS_SET(ch->on->value[2], SLEEP_AT) && !IS_SET(ch->on->value[2], SLEEP_ON) &&
act_move.c:          !IS_SET(ch->on->value[2], SLEEP_IN))
act_move.c:   switch (ch->position)
act_move.c:         else if (ch->on != NULL && obj == NULL)
act_move.c:            act(AT_ACTION, "Te bajas de $p e intentas dormir en el suelo.", ch, ch->on, NULL, TO_CHAR);
act_move.c:            act(AT_ACTION, "$n se baja de $p e intenta dormir en el suelo.", ch, ch->on, NULL, TO_ROOM);
act_move.c:            ch->on = NULL;
act_move.c:            ch->on = NULL;
act_move.c:         ch->position = POS_SLEEPING;
act_move.c:            ch->on = NULL;
act_move.c:         ch->position = POS_SLEEPING;
act_move.c:            ch->on = NULL;
act_move.c:         ch->position = POS_SLEEPING;
act_move.c:         act(AT_ACTION, "El peso de $n es demasiado para $p.", ch, ch->on, NULL, TO_ROOM);
act_move.c:         act(AT_ACTION, "Tu intento de dormir en $p causa que se rompa.", ch, ch->on, NULL, TO_CHAR);
act_move.c:         for (fch = obj->in_room->first_person; fch != NULL; fch = fch->next_in_room)
act_move.c:            if (fch->on == obj)
act_move.c:               if (fch->position == POS_RESTING)
act_move.c:                  fch->hit = (fch->hit - 30);
act_move.c:                  if (fch->hit <= 0)
act_move.c:                     fch->hit = 1;
act_move.c:                  act(AT_ACTION, "Tu descanso se interrumpe cuando caes al suelo al romperse $p.", fch, fch->on, NULL, TO_CHAR);
act_move.c:               if (fch->position == POS_SLEEPING)
act_move.c:                  fch->hit = (fch->hit - 40);
act_move.c:                  if (fch->hit <= 0)
act_move.c:                     fch->hit = 1;
act_move.c:                  fch->position = POS_RESTING;
act_move.c:                  act(AT_ACTION, "Tu sueño se interrumpe cuando caes al suelo al romperse $p.", fch, fch->on, NULL, TO_CHAR);
act_move.c:               if (fch->position == POS_SITTING)
act_move.c:                  fch->hit = (fch->hit - 5);
act_move.c:                  if (fch->hit <= 0)
act_move.c:                     fch->hit = 1;
act_move.c:                  act(AT_ACTION, "Tu descanso se interrumpe cuando caes al suelo al romperse $p.", fch, fch->on, NULL, TO_CHAR);
act_move.c:               if (fch->position == POS_STANDING)
act_move.c:                  fch->hit = (fch->hit - 55);
act_move.c:                  if (fch->hit <= 0)
act_move.c:                     fch->hit = 1;
act_move.c:                  act(AT_ACTION, "Caes al suelo cuando $p se rompe.", fch, fch->on, NULL, TO_CHAR);
act_move.c:               fch->on = NULL;
act_move.c:   ch->on = NULL;
act_move.c:    for ( nch = ch->in_room->first_person; nch; nch = nch_next )
act_move.c:	nch_next = nch->next_in_room;
act_move.c:	for ( pexit = ch->in_room->first_exit; pexit; pexit = pexit->next )
act_move.c:	for ( pexit = ch->in_room->first_exit; pexit; pexit = pexit->next )
act_move.c:	for ( pexit = ch->in_room->first_exit; pexit; pexit = pexit->next )
act_obj.c:       && (ch->top_level < sysdata.level_getobjnotake )  )
act_obj.c:    if ( (ch->carry_number + get_obj_number( obj ) > can_carry_n( ch )))
act_obj.c:    if ( ch->carry_weight + weight > can_carry_w( ch ) )
act_obj.c:    if ( IS_SET(ch->in_room->room_flags, ROOM_CLANSTOREROOM) 
act_obj.c:	  if ( clan->storeroom == ch->in_room->vnum )
act_obj.c:	ch->gold += obj->value[0];
act_obj.c:	if ( (ch->carry_number + number) > can_carry_n(ch) )
act_obj.c:	    obj = get_obj_list( ch, arg1, ch->in_room->first_content );
act_obj.c:	    if ( IS_SET( ch->in_room->room_flags, ROOM_DONATION ) )
act_obj.c:	    for ( obj = ch->in_room->first_content; obj; obj = obj_next )
act_obj.c:		    ||   ch->carry_number >= can_carry_n( ch )
act_obj.c:		    ||   ch->carry_weight >= can_carry_w( ch )
act_obj.c:	    if ( ch->carry_weight + container->weight > can_carry_w( ch ) )
act_obj.c:		    ||   ch->carry_number >= can_carry_n( ch )
act_obj.c:		    ||   ch->carry_weight >= can_carry_w( ch )
act_obj.c:	if ( ch->carry_weight + container->weight > can_carry_w( ch ) )
act_obj.c:	    if ( ch->gold < number )
act_obj.c:	    if (!IS_NPC(ch) && ch->top_level < 11)
act_obj.c:	    ch->gold -= number;
act_obj.c:	if ( IS_SET(ch->in_room->room_flags, ROOM_CLANSTOREROOM) 
act_obj.c:	      if ( clan->storeroom == ch->in_room->vnum )
act_obj.c:	for ( obj = ch->first_carrying; obj; obj = obj_next )
act_obj.c:        if ( IS_SET(ch->in_room->room_flags, ROOM_CLANSTOREROOM) 
act_obj.c:	     if ( clan->storeroom == ch->in_room->vnum )
act_obj.c:    if ( IS_SET( ch->in_room->room_flags, ROOM_NODROP )
act_obj.c:    ||   ( !IS_NPC(ch) && IS_SET( ch->act, PLR_LITTERBUG )) )
act_obj.c:	    if ( ch->gold < number )
act_obj.c:	    if (!IS_NPC(ch) && ch->top_level < 11)
act_obj.c:	    ch->gold -= number;
act_obj.c:	    for ( obj = ch->in_room->first_content; obj; obj = obj_next )
act_obj.c:	    obj_to_room( create_money( number ), ch->in_room );
act_obj.c:		sprintf(logbuf, "%s dropped %d credits.", ch->name, number);
act_obj.c:		sprintf(logbuf, "%s dropped %s.", ch->name, obj->short_descr);
act_obj.c:	obj = obj_to_room( obj, ch->in_room );
act_obj.c:	if ( IS_SET(ch->in_room->room_flags, ROOM_CLANSTOREROOM) )
act_obj.c: 	      if ( clan->storeroom == ch->in_room->vnum )
act_obj.c:	if ( IS_SET( ch->in_room->room_flags, ROOM_NODROPALL ) )
act_obj.c:	for ( obj = ch->first_carrying; obj; obj = obj_next )
act_obj.c:		     obj_next = ch->first_carrying;
act_obj.c:		obj = obj_to_room( obj, ch->in_room );
act_obj.c:			sprintf(logbuf, "%s dropped %s.", ch->name, obj->short_descr);
act_obj.c:        if ( IS_SET(ch->in_room->room_flags, ROOM_CLANSTOREROOM) )
act_obj.c: 	      if ( clan->storeroom == ch->in_room->vnum )
act_obj.c:	if ( ch->gold < amount )
act_obj.c:	if (!IS_NPC(ch) && ch->top_level < 11)
act_obj.c:	ch->gold     -= amount;
act_obj.c:	 sprintf(logbuf, "%s gives %s %d credits.", ch->name, victim->name, amount);
act_obj.c:	 sprintf(logbuf, "%s gives %s to %s.", ch->name, obj->short_descr, victim->name);
act_obj.c:	    ch->armor += apply_ac( obj, obj->wear_loc );
act_obj.c:	    ch->armor -= apply_ac( obj, obj->wear_loc );
act_obj.c:    &&   ch->carry_number + get_obj_number( obj ) > can_carry_n( ch ) )
act_obj.c:  if ( ch->pcdata->learned[gsn_dual_wield] )
act_obj.c:    for ( otmp = ch->first_carrying; otmp; otmp = otmp->next_content )
act_obj.c:    else if ( ch->race == RACE_DEFEL )
act_obj.c:      switch (ch->race)
act_obj.c:    if ( ch->race == RACE_DEFEL )
act_obj.c:	    if ( ch->race == RACE_VERPINE || ch->race == RACE_TWI_LEK )
act_obj.c:	    if ( ch->race == RACE_VERPINE )
act_obj.c:	    if ( ch->race == RACE_HUTT )
act_obj.c:	    if ( ch->race == RACE_HUTT )
act_obj.c:	for ( obj = ch->first_carrying; obj; obj = obj_next )
act_obj.c:      for ( obj = ch->first_carrying; obj != NULL ; obj = obj_next )
act_obj.c:    for ( obj = ch->first_carrying; obj; obj = obj->next_content )
act_obj.c:    obj = get_obj_list_rev( ch, arg, ch->in_room->last_content );
act_obj.c:    switch( ch->in_room->sector_type )
act_obj.c:    if ( move > ch->move )
act_obj.c:    ch->move -= move;
act_obj.c:    if ( arg[0] == '\0' || !str_cmp( arg, ch->name ) )
act_obj.c:    obj = get_obj_list_rev( ch, arg, ch->in_room->last_content );
act_obj.c:	for ( vch = ch->in_room->first_person; vch; vch = vch_next )
act_obj.c:	    vch_next	= vch->next_in_room;
act_obj.c:            if ( !IS_NPC( vch ) && IS_SET( vch->act, PLR_WIZINVIS ) 
act_obj.c:                  && vch->pcdata->wizinvis >= LEVEL_IMMORTAL )
act_obj.c:    if ( arg[0] == '\0' && !ch->fighting )
act_obj.c:	if ( ch->fighting )
act_obj.c:	templvl = ch->top_level;
act_obj.c:	ch->top_level = LEVEL_HERO;		/* make sure EQ doesn't get lost */
act_obj.c:        contents = ch->in_room->last_content;
act_obj.c:	ch->top_level = templvl;
act_obj.c:            if (newbet > ch->gold)
act_obj.c:            ch->gold -= newbet; /* substract the gold - important :) */
act_obj.c:				rch = rch->next_in_room, chcnt++ )
act_obj.c:			damage( vch, vch, dam*vch->top_level, TYPE_UNDEFINED );
act_wiz.c:	     ch->name, cmd->name, level );
act_wiz.c:	victim->pcdata->authed_by = QUICKLINK( ch->name );
act_wiz.c:	sprintf( buf, "%s authorized %s", ch->name,
act_wiz.c:	to_channel( buf, CHANNEL_MONITOR, "Monitor", ch->top_level );
act_wiz.c:	sprintf( buf, "%s denied authorization to %s", ch->name,
act_wiz.c:	to_channel( buf, CHANNEL_MONITOR, "Monitor", ch->top_level );
act_wiz.c:	sprintf( buf, "%s has denied %s's name", ch->name,
act_wiz.c:	to_channel( buf, CHANNEL_MONITOR, "Monitor", ch->top_level );
act_wiz.c:	DISPOSE( ch->pcdata->bamfin );
act_wiz.c:	ch->pcdata->bamfin = str_dup( argument );
act_wiz.c:	DISPOSE( ch->pcdata->bamfout );
act_wiz.c:	ch->pcdata->bamfout = str_dup( argument );
act_wiz.c:    ch->rank = str_dup( "" );
act_wiz.c:    ch->rank = str_dup( centertext(argument, 19) );
act_wiz.c:      ch_printf( victim, "%s brings you back from retirement.\n\r", ch->name );
act_wiz.c:      ch_printf( victim, "Courtesy of %s, you are now a retired immortal.\n\r", ch->name );
act_wiz.c:    if ( IS_SET(ch->act, PLR_NO_EMOTE) )
act_wiz.c:    if ( IS_SET(ch->act, PLR_NO_EMOTE) )
act_wiz.c:       echo_to_room ( color, ch->in_room, argument );
act_wiz.c:       echo_to_room ( AT_IMMORT, ch->in_room, argument );
act_wiz.c:      location = ch->in_room;
act_wiz.c:	sprintf(buf, "%d", ch->regoto);
act_wiz.c:    original = ch->in_room;
act_wiz.c:    for ( wch = first_char; wch; wch = wch->next )
act_wiz.c:    original = ch->in_room;
act_wiz.c:        if ( !ch->pcdata || !(pArea=ch->pcdata->area) )
act_wiz.c:        if ( ch->in_room->vnum < pArea->low_r_vnum
act_wiz.c:	||  ch->in_room->vnum > pArea->hi_r_vnum )
act_wiz.c:	location = ch->in_room;
act_wiz.c:    location = ( arg[0] == '\0' ) ? ch->in_room : find_location( ch, arg );
act_wiz.c:    if ( ch->in_room != location && room_is_private( ch, location ) )
act_wiz.c:    for ( rch = location->first_person; rch; rch = rch->next_in_room )
act_wiz.c:	  one_argument( rch->name, buf );
act_wiz.c:    sprintf( buf, "Reboot by %s.", ch->name );
act_wiz.c:	for ( vch = first_char; vch; vch = vch->next )
act_wiz.c:    sprintf( buf, "Shutdown by %s.", ch->name );
act_wiz.c:	for ( vch = first_char; vch; vch = vch->next )
act_wiz.c:	    if ( d->snoop_by == ch->desc )
act_wiz.c:    if ( ch->desc )
act_wiz.c:	for ( d = ch->desc->snoop_by; d; d = d->snoop_by )
act_wiz.c:    victim->desc->snoop_by = ch->desc;
act_wiz.c:    if ( !ch->desc )
act_wiz.c:    if ( ch->desc->original )
act_wiz.c:    ch->desc->character = victim;
act_wiz.c:    ch->desc->original  = ch;
act_wiz.c:    victim->desc        = ch->desc;
act_wiz.c:    ch->desc            = NULL;
act_wiz.c:    ch->switched	= victim;
act_wiz.c:    if ( !ch->desc )
act_wiz.c:    if ( !ch->desc->original )
act_wiz.c:    if (IS_SET(ch->act, ACT_POLYMORPHED))
act_wiz.c:		REMOVE_BIT( ch->affected_by, AFF_POSSESS );
act_wiz.c:/*    if ( IS_NPC( ch->desc->character ) )
act_wiz.c:      REMOVE_BIT( ch->desc->character->affected_by, AFF_POSSESS );*/
act_wiz.c:    ch->desc->character       = ch->desc->original;
act_wiz.c:    ch->desc->original        = NULL;
act_wiz.c:    ch->desc->character->desc = ch->desc;
act_wiz.c:    ch->desc->character->switched = NULL;
act_wiz.c:    ch->desc                  = NULL;
act_wiz.c:	if ( !ch->pcdata || !(pArea=ch->pcdata->area) )
act_wiz.c:    char_to_room( victim, ch->in_room );
act_wiz.c:	if ( !ch->pcdata || !(pArea=ch->pcdata->area) )
act_wiz.c:	obj = obj_to_room( obj, ch->in_room );
act_wiz.c:	for ( victim = ch->in_room->first_person; victim; victim = vnext )
act_wiz.c:	for ( obj = ch->in_room->first_content; obj; obj = obj_next )
act_wiz.c:      sprintf( buf2, "%s balzhuring %s", ch->name, buf );
act_wiz.c:          sprintf( buf2, "%s destroying %s", ch->name, buf );
act_wiz.c:     if (!str_cmp(arg2, "all") && (ch->top_level == LEVEL_IMPLEMENTOR) )
act_wiz.c:        if ( !ch->pcdata )
act_wiz.c:        ch->pcdata->restore_time = current_time;
act_wiz.c:	    vch_next = vch->next;
act_wiz.c:   		vch->hit = vch->max_hit;
act_wiz.c:		vch->mana = vch->max_mana;
act_wiz.c:		vch->move = vch->max_move;
act_wiz.c:		vch->pcdata->condition[COND_BLOODTHIRST] = (10 + vch->top_level);
act_wiz.c:  if ( !ch->pcdata )
act_wiz.c:  if ( !ch->pcdata->restore_time )
act_wiz.c:  time_passed = current_time - ch->pcdata->restore_time;
act_wiz.c:    for ( rch = ch->in_room->first_person; rch; rch = rch->next_in_room )
act_wiz.c:	if ( rch->fighting )
act_wiz.c:	    vch_next = vch->next;
act_wiz.c:	  ch->pcdata->wizinvis = level;
act_wiz.c:          ch->mobinvis = level;
act_wiz.c:      if( ch->mobinvis < 2 )
act_wiz.c:         ch->mobinvis = ch->top_level;
act_wiz.c:   if( ch->pcdata->wizinvis < 2 )
act_wiz.c:      ch->pcdata->wizinvis = ch->top_level;
act_wiz.c:    if ( IS_SET(ch->act, PLR_WIZINVIS) )
act_wiz.c:	REMOVE_BIT(ch->act, PLR_WIZINVIS);
act_wiz.c:	SET_BIT(ch->act, PLR_WIZINVIS);
act_wiz.c:    if ( IS_SET(ch->act, PLR_HOLYLIGHT) )
act_wiz.c:	REMOVE_BIT(ch->act, PLR_HOLYLIGHT);
act_wiz.c:	SET_BIT(ch->act, PLR_HOLYLIGHT);
act_wiz.c:      ch_printf( victim, "%s has removed your vnum range.\r\n", ch->name );
act_wiz.c:   ch_printf( victim, "%s has assigned you the vnum range %d - %d.\r\n", ch->name, lo, hi );
act_wiz.c:	char_to_room( d->character, ch->in_room );
act_wiz.c:             ch->name, argument );
act_wiz.c:        ch_printf( victim, "%s has removed your bestowed commands.\n\r", ch->name );
act_wiz.c:    ch_printf( victim, "%s has bestowed on you the command(s): %s\n\r", ch->name, arg_buf );
act_wiz.c:    ech_next = ech->next;
act_wiz.c:      if( ech->fighting )
act_wiz.c:        if( URANGE( pArea->low_m_vnum, ech->pIndexData->vnum, pArea->hi_m_vnum ) == ech->pIndexData->vnum
act_wiz.c:      || ( ech->in_room && ech->in_room->area == pArea ) )
act_wiz.c:      if( ech->in_room && ech->in_room->area == pArea )
act_wiz.c:      sprintf( buf2, "%s destroying %s", ch->name, buf );
act_wiz.c:          sprintf( buf2, "%s destroying %s", ch->name, buf );
act_wiz.c:    sprintf( buf, "%s destroying %s", ch->name, argument );
act_wiz.c:		return ch->name;
act_wiz.c:	one_argument (ch->name, name); /* copy the first word into name */
act_wiz.c:	for (rch = ch->in_room->first_person; rch && (rch != ch);rch = 
act_wiz.c:	    rch->next_in_room)
act_wiz.c:		if (is_name (name, rch->name))
act_wiz.c:				old_room = ch->in_room;
act_wiz.c:					old_room = ch->in_room;
act_wiz.c:  victim->pcdata->helled_by = STRALLOC(ch->name);
act_wiz.c:  location = ch->in_room;
act_wiz.c:  ch->in_room = get_room_index(6);
act_wiz.c:  ch->in_room = location;            /* The case of unhell self, etc. */
act_wiz.c:    location = ch->in_room;
act_wiz.c:    if( str_cmp(ch->name, victim->pcdata->helled_by) )
act_wiz.c:  AREA_DATA *pArea = ch->in_room->area;
act_wiz.c:   if( ( ch->pcdata->pwd != '\0' ) && ( arg1[0] == '\0' || arg2[0] == '\0' ) )
act_wiz.c:   if( ch->top_level < LEVEL_SUB_IMPLEM  )
act_wiz.c:      if( victim->top_level >= ch->top_level )
act_wiz.c:   ch_printf( victim, "&R%s has changed your password to: %s\n\r&w", ch->name, arg2 );
act_wiz.c:   if (ch->pcdata->area)
act_wiz.c:                if(ch->rank) DISPOSE(ch->rank); //Thanks Odis
act_wiz.c:                ch->rank = str_dup("");
act_wiz.c:  ch->rank = str_dup(buf);
boards.c:    if ( is_name( ch->name, board->extra_removers ) )
boards.c:    if ( ch->pcdata->clan && !str_cmp( ch->pcdata->clan->name, board->read_group ) ) 
boards.c:    if ( ch->pcdata->clan && ch->pcdata->clan->mainclan && !str_cmp( ch->pcdata->clan->mainclan->name, board->read_group ) ) 
boards.c:    if ( is_name( ch->name, board->extra_readers ) )
boards.c:    if ( ch->pcdata->clan && !str_cmp( ch->pcdata->clan->name, board->post_group ) ) 
boards.c:    if ( ch->pcdata->clan && ch->pcdata->clan->mainclan && !str_cmp( ch->pcdata->clan->mainclan->name, board->post_group ) ) 
boards.c:    for ( obj = ch->in_room->first_content;
boards.c:    if ( !str_cmp( ch->name, pnote->sender ) )
boards.c:    if ( is_name( ch->name, pnote->to_list ) )
boards.c:    if ( ch->pnote )
boards.c:    pnote->sender	= QUICKLINK( ch->name );
boards.c:    ch->pnote		= pnote;
boards.c:    for ( quill = ch->last_carrying; quill; quill = quill->prev_content )
boards.c:    switch( ch->substate )
boards.c:    switch( ch->substate )
boards.c:    if ( !ch->desc )
boards.c:    switch( ch->substate )
boards.c:	  ed = ch->dest_buf;
boards.c:			if ( ch->gold < 10
boards.c:			   ch->gold -= 10;
boards.c:	    if ( str_cmp( ch->name, pnote->sender ) )
boards.c:	    if ( str_cmp( ch->name, pnote->sender ) )
boards.c:	if ( is_name( ch->name, buf ) )
boards.c:	    sprintf( buf, "%s %s", pnote->yesvotes, ch->name );
boards.c:	    sprintf( buf, "%s %s", pnote->novotes, ch->name );
boards.c:	    sprintf( buf, "%s %s", pnote->abstentions, ch->name );
boards.c:	if ( ch->substate == SUB_RESTRICTED )
boards.c:	    ch->substate = SUB_WRITING_NOTE;
boards.c:	    ch->dest_buf = ed;
boards.c:	    ch->name,
boards.c:	pnote->sender  = QUICKLINK( ch->name );
boards.c:		    if ( ch->gold < 50 && get_trust(ch) < sysdata.read_mail_free )
boards.c:		      ch->gold -= 50;
bounty.c:    if ( ch->pcdata && ch->pcdata->clan && !str_cmp(ch->pcdata->clan->name, "the hunters guild"))
bounty.c:/*    if ( !ch->in_room || ch->in_room->vnum != 6604 )
bounty.c:    if (ch->gold < amount)
bounty.c:    ch->gold = ch->gold - amount;
bounty.c:        if (bounty && !ch->pcdata) 
bounty.c:		exp = (exp_level( ch->skill_level[ASSASSIN_ABILITY]+1) - exp_level( ch->skill_level[ASSASSIN_ABILITY])) ;
bounty.c:		exp = (exp_level( ch->skill_level[ASSASSIN_ABILITY]+1) - exp_level( ch->skill_level[ASSASSIN_ABILITY])) ;
bounty.c:	       exp = URANGE(1, xp_compute(ch, victim) , ( exp_level(ch->skill_level[HUNTING_ABILITY]+1) - exp_level(ch->skill_level[HUNTING_ABILITY]) ));	
bounty.c:	        SET_BIT(ch->act, PLR_KILLER );
bounty.c:	ch->gold += bounty->amount;	
bounty.c:        exp = URANGE(1, bounty->amount + xp_compute(ch, victim) , ( exp_level(ch->skill_level[HUNTING_ABILITY]+1) - exp_level(ch->skill_level[HUNTING_ABILITY]) ));	
bounty.c:	       SET_BIT(ch->act, PLR_KILLER );
build.c:	if ( !ch->pcdata || !(pArea=ch->pcdata->area) )
build.c:	if ( !ch->pcdata || !(pArea=ch->pcdata->area) )
build.c:	if ( !ch->pcdata || !(pArea=ch->pcdata->area) )
build.c:	if ( !ch->pcdata || !(pArea=ch->pcdata->area) )
build.c:	if ( !ch->pcdata || !(pArea=ch->pcdata->area) )
build.c:	if ( !ch->desc )
build.c:	if ( ch->substate == SUB_RESTRICTED )
build.c:	   bug( "NOT GOOD: start_editing: ch->substate == SUB_RESTRICTED", 0 );
build.c:	if ( ch->editor )
build.c:	ch->editor = edit;
build.c:	ch->desc->connected = CON_EDITING;
build.c:   if ( !ch->editor )
build.c:   for ( x = 0; x < ch->editor->numlines; x++ )
build.c:      strcpy( tmp, ch->editor->line[x] );
build.c:    DISPOSE( ch->editor );
build.c:    ch->editor = NULL;
build.c:    ch->dest_buf  = NULL;
build.c:    ch->spare_ptr = NULL;
build.c:    ch->substate  = SUB_NONE;
build.c:    if ( !ch->desc )
build.c:    ch->desc->connected = CON_PLAYING;
build.c:	if ( vnum < 1 || IS_NPC(ch) || !ch->pcdata->area )
build.c:	if ( !ch->pcdata || !(pArea=ch->pcdata->area) )
build.c:	location = make_room( vnum, ch->pcdata->area );
build.c:	location->area = ch->pcdata->area;
build.c:        if ( !ch->pcdata || !(pArea=ch->pcdata->area) )
build.c:	if ( ( ch->in_room->vnum < pArea->low_r_vnum
build.c:	||   ch->in_room->vnum > pArea->hi_r_vnum ) && !IS_SET(ch->in_room->room_flags , ROOM_HOTEL) )
build.c:    in_room = ch->in_room;
build.c:    if ( ch->fighting )
build.c:    if ( !IS_SET(ch->act, PLR_WIZINVIS) ){
build.c:         if (ch->pcdata && ch->pcdata->bamfout[0] != '\0')
build.c:               act( AT_IMMORT, "$T", ch, NULL, ch->pcdata->bamfout ,  TO_ROOM );
build.c:    ch->regoto = ch->in_room->vnum;
build.c:    if ( ch->mount )
build.c:	char_from_room( ch->mount );
build.c:	char_to_room( ch->mount, location );
build.c:   if ( ch->on )
build.c:       ch->on = NULL;
build.c:       ch->position = POS_STANDING;
build.c:    if (ch->position != POS_STANDING)
build.c:       ch->position = POS_STANDING;
build.c:   if ( !IS_SET(ch->act, PLR_WIZINVIS) ){
build.c:         if (ch->pcdata && ch->pcdata->bamfin[0] != '\0')
build.c:             act( AT_IMMORT, "$T", ch, NULL, ch->pcdata->bamfin ,  TO_ROOM );
build.c:    if ( ch->in_room == in_room )
build.c:	fch_next = fch->next_in_room;
build.c:	if ( fch->master == ch && IS_IMMORTAL(fch) )
build.c:	if ( !ch->pcdata || !(pArea=ch->pcdata->area) )
build.c:   if( !ch->desc )
build.c:   switch ( ch->substate )
build.c:         if( !ch->dest_buf )
build.c:            bug( "do_mset: sub_mob_desc: NULL ch->dest_buf", 0 );
build.c:            ch->substate = SUB_NONE;
build.c:         victim = ch->dest_buf;
build.c:         ch->substate = ch->tempnum;
build.c:   if( ch->substate == SUB_REPEATCMD )
build.c:      victim = ch->dest_buf;
build.c:         if( ch->dest_buf )
build.c:            RelDestroy( relMSET_ON, ch, ch->dest_buf );
build.c:         ch->substate = SUB_NONE;
build.c:         ch->dest_buf = NULL;
build.c:         if( ch->pcdata && ch->pcdata->subprompt )
build.c:            STRFREE( ch->pcdata->subprompt );
build.c:   if( arg1[0] == '\0' || ( arg2[0] == '\0' && ch->substate != SUB_REPEATCMD ) || !str_cmp( arg1, "?" ) )
build.c:      if( ch->substate == SUB_REPEATCMD )
build.c:      ch->dest_buf = NULL;
build.c:      ch->dest_buf = NULL;
build.c:      ch->dest_buf = NULL;
build.c:      ch->dest_buf = victim;
build.c:      ch->substate = SUB_REPEATCMD;
build.c:      ch->dest_buf = victim;
build.c:      if( ch->pcdata )
build.c:         if( ch->pcdata->subprompt )
build.c:            STRFREE( ch->pcdata->subprompt );
build.c:         ch->pcdata->subprompt = STRALLOC( buf );
build.c:      if( ch->substate == SUB_REPEATCMD )
build.c:         ch->tempnum = SUB_REPEATCMD;
build.c:         ch->tempnum = SUB_NONE;
build.c:      ch->substate = SUB_MOB_DESC;
build.c:      ch->dest_buf = victim;
build.c:            else if( 1 << value == ACT_PROTOTYPE && ch->top_level < sysdata.level_modify_proto )
build.c:   if( ch->substate == SUB_REPEATCMD )
build.c:      ch->substate = SUB_RESTRICTED;
build.c:      ch->substate = SUB_REPEATCMD;
build.c:      ch->last_cmd = do_mset;
build.c:   if( !ch->desc )
build.c:   switch ( ch->substate )
build.c:         if( !ch->dest_buf )
build.c:            bug( "do_oset: sub_obj_extra: NULL ch->dest_buf", 0 );
build.c:            ch->substate = SUB_NONE;
build.c:         ed = ch->dest_buf;
build.c:         tmpobj = ch->spare_ptr;
build.c:         ch->dest_buf = tmpobj;
build.c:         ch->substate = ch->tempnum;
build.c:         if( !ch->dest_buf )
build.c:            bug( "do_oset: sub_obj_long: NULL ch->dest_buf", 0 );
build.c:            ch->substate = SUB_NONE;
build.c:         obj = ch->dest_buf;
build.c:         tmpobj = ch->spare_ptr;
build.c:         ch->substate = ch->tempnum;
build.c:         ch->dest_buf = tmpobj;
build.c:   if( ch->substate == SUB_REPEATCMD )
build.c:      obj = ch->dest_buf;
build.c:         if( ch->dest_buf )
build.c:            RelDestroy( relOSET_ON, ch, ch->dest_buf );
build.c:         ch->substate = SUB_NONE;
build.c:         ch->dest_buf = NULL;
build.c:         if( ch->pcdata && ch->pcdata->subprompt )
build.c:            STRFREE( ch->pcdata->subprompt );
build.c:      if( ch->substate == SUB_REPEATCMD )
build.c:      ch->dest_buf = obj;
build.c:      ch->substate = SUB_REPEATCMD;
build.c:      ch->dest_buf = obj;
build.c:      if( ch->pcdata )
build.c:         if( ch->pcdata->subprompt )
build.c:            STRFREE( ch->pcdata->subprompt );
build.c:         ch->pcdata->subprompt = STRALLOC( buf );
build.c:      if( ch->substate == SUB_REPEATCMD )
build.c:         ch->tempnum = SUB_REPEATCMD;
build.c:         ch->tempnum = SUB_NONE;
build.c:         ch->spare_ptr = obj;
build.c:         ch->spare_ptr = NULL;
build.c:      ch->substate = SUB_OBJ_LONG;
build.c:      ch->dest_buf = obj;
build.c:            for( vch = first_char; vch; vch = vch->next )
build.c:               for( eq = vch->first_carrying; eq; eq = eq->next_content )
build.c:                  for( vch = first_char; vch; vch = vch->next )
build.c:                     for( eq = vch->first_carrying; eq; eq = eq->next_content )
build.c:      if( ch->substate == SUB_REPEATCMD )
build.c:         ch->tempnum = SUB_REPEATCMD;
build.c:         ch->tempnum = SUB_NONE;
build.c:         ch->spare_ptr = obj;
build.c:         ch->spare_ptr = NULL;
build.c:      ch->substate = SUB_OBJ_EXTRA;
build.c:      ch->dest_buf = ed;
build.c:      if( ch->substate == SUB_REPEATCMD )
build.c:         ch->tempnum = SUB_REPEATCMD;
build.c:         ch->tempnum = SUB_NONE;
build.c:         ch->spare_ptr = obj;
build.c:         ch->spare_ptr = NULL;
build.c:      ch->substate = SUB_OBJ_EXTRA;
build.c:      ch->dest_buf = ed;
build.c:   if( ch->substate == SUB_REPEATCMD )
build.c:      ch->substate = SUB_RESTRICTED;
build.c:      ch->substate = SUB_REPEATCMD;
build.c:      ch->last_cmd = do_oset;
build.c:   if( !ch->desc )
build.c:   switch ( ch->substate )
build.c:         location = ch->dest_buf;
build.c:            bug( "redit: sub_room_desc: NULL ch->dest_buf", 0 );
build.c:            location = ch->in_room;
build.c:         ch->substate = ch->tempnum;
build.c:         ed = ch->dest_buf;
build.c:            bug( "redit: sub_room_extra: NULL ch->dest_buf", 0 );
build.c:         ch->substate = ch->tempnum;
build.c:   location = ch->in_room;
build.c:   if( ch->substate == SUB_REPEATCMD )
build.c:         if( ch->pcdata && ch->pcdata->subprompt )
build.c:            STRFREE( ch->pcdata->subprompt );
build.c:         ch->substate = SUB_NONE;
build.c:      if( ch->substate == SUB_REPEATCMD )
build.c:      ch->substate = SUB_REPEATCMD;
build.c:      if( ch->pcdata )
build.c:         if( ch->pcdata->subprompt )
build.c:            STRFREE( ch->pcdata->subprompt );
build.c:         ch->pcdata->subprompt = STRALLOC( "<&CRedit &W#%r&w> %i" );
build.c:      if( ch->substate == SUB_REPEATCMD )
build.c:         ch->tempnum = SUB_REPEATCMD;
build.c:         ch->tempnum = SUB_NONE;
build.c:      ch->substate = SUB_ROOM_DESC;
build.c:      ch->dest_buf = location;
build.c:      if( ch->substate == SUB_REPEATCMD )
build.c:         ch->tempnum = SUB_REPEATCMD;
build.c:         ch->tempnum = SUB_NONE;
build.c:      ch->substate = SUB_ROOM_EXTRA;
build.c:      ch->dest_buf = ed;
build.c:   if( ch->substate == SUB_REPEATCMD )
build.c:      ch->substate = SUB_RESTRICTED;
build.c:      ch->substate = SUB_REPEATCMD;
build.c:      ch->last_cmd = do_redit;
build.c:	if ( !ch->pcdata || !(pArea=ch->pcdata->area) )
build.c:	if ( !ch->pcdata || !(pArea=ch->pcdata->area) )
build.c:    char_to_room( mob, ch->in_room );
build.c:    if ( (d = ch->desc) == NULL )
build.c:   if ( ch->substate <= SUB_PAUSE )
build.c:	bug( "Edit_buffer: illegal ch->substate (%d)", ch->substate );
build.c:   if ( !ch->editor )
build.c:   edit = ch->editor;
build.c:   if ( ch->substate == SUB_MPROG_EDIT || ch->substate == SUB_HELP_EDIT )
build.c:	    int substate = ch->substate;
build.c:	    last_cmd = ch->last_cmd;
build.c:	    ch->substate = SUB_RESTRICTED;
build.c:	    ch->substate = substate;
build.c:	    ch->last_cmd = last_cmd;
build.c:	    if ( !ch->last_cmd )
build.c:	    (*ch->last_cmd) ( ch, "" );
build.c:      if ( !ch->last_cmd )
build.c:      (*ch->last_cmd) ( ch, "" );
build.c:	&&   ch->pcdata->r_range_lo
build.c:	&&   ch->pcdata->r_range_hi )
build.c:	  tarea = ch->pcdata->area;
build.c:	  sprintf( taf, "%s.are", capitalize( ch->name ) );
build.c:	    sprintf( buf, "Creating area entry for %s", ch->name );
build.c:	    log_string_plus( buf, LOG_NORMAL, ch->top_level );
build.c:	    sprintf( buf, "{PROTO} %s's area in progress", ch->name );
build.c:	    sprintf( buf2, "%s", ch->name );
build.c:	    sprintf( buf, "Updating area entry for %s", ch->name );
build.c:	    log_string_plus( buf, LOG_NORMAL, ch->top_level );
build.c:	  tarea->low_r_vnum	= ch->pcdata->r_range_lo;
build.c:	  tarea->low_o_vnum	= ch->pcdata->o_range_lo;
build.c:	  tarea->low_m_vnum	= ch->pcdata->m_range_lo;
build.c:	  tarea->hi_r_vnum	= ch->pcdata->r_range_hi;
build.c:	  tarea->hi_o_vnum	= ch->pcdata->o_range_hi;
build.c:	  tarea->hi_m_vnum	= ch->pcdata->m_range_hi;
build.c:	  ch->pcdata->area	= tarea;
build.c:	    ch->pcdata->area = NULL;
build.c:	    if ( !ch->pcdata->area )
build.c:        ||  (is_name( buf, ch->pcdata->bestowments )
build.c:	        ||   is_name( tmp->filename, ch->pcdata->bestowments ) )
build.c:	ch->pcdata->area = tarea;
build.c:    if ( IS_NPC(ch) || get_trust( ch ) < LEVEL_AVATAR || !ch->pcdata
build.c:    ||  ( argument[0] == '\0' && !ch->pcdata->area) )
build.c:	tarea = ch->pcdata->area;
build.c:    if ( IS_NPC(ch) || get_trust( ch ) < LEVEL_AVATAR || !ch->pcdata
build.c:    ||  ( argument[0] == '\0' && !ch->pcdata->area) )
build.c:	tarea = ch->pcdata->area;
build.c:      	    if (!ch->in_room->area){
build.c:        tarea = ch->in_room->area;
build.c:    if ( IS_NPC(ch) || get_trust( ch ) < LEVEL_AVATAR || !ch->pcdata
build.c:    || ( !ch->pcdata->area && get_trust( ch ) < LEVEL_GREATER ) )
build.c:    tarea = ch->pcdata->area;
build.c:    if ( IS_NPC(ch) || get_trust( ch ) < LEVEL_CREATOR || !ch->pcdata
build.c:    || ( !ch->pcdata->area && get_trust( ch ) < LEVEL_GREATER ) )
build.c:    tarea = ch->pcdata->area;
build.c:    if ( IS_NPC(ch) || get_trust( ch ) < LEVEL_CREATOR || !ch->pcdata
build.c:    ||  ( !ch->pcdata->area && get_trust( ch ) < LEVEL_GREATER ) )
build.c:    tarea = ch->pcdata->area;
build.c:	ch->substate = SUB_MPROG_EDIT;
build.c:	ch->dest_buf = mprg;
build.c:    if ( !ch->desc )
build.c:    switch( ch->substate )
build.c:	  if ( !ch->dest_buf )
build.c:		bug( "do_mpedit: sub_mprog_edit: NULL ch->dest_buf", 0 );
build.c:		ch->substate = SUB_NONE;
build.c:	  mprog	 = ch->dest_buf;
build.c:    if ( !ch->desc )
build.c:    switch( ch->substate )
build.c:	  if ( !ch->dest_buf )
build.c:		bug( "do_opedit: sub_oprog_edit: NULL ch->dest_buf", 0 );
build.c:		ch->substate = SUB_NONE;
build.c:	  mprog	 = ch->dest_buf;
build.c:	ch->substate = SUB_MPROG_EDIT;
build.c:	ch->dest_buf = mprg;
build.c:    if ( !ch->desc )
build.c:    switch( ch->substate )
build.c:	  if ( !ch->dest_buf )
build.c:		bug( "do_opedit: sub_oprog_edit: NULL ch->dest_buf", 0 );
build.c:		ch->substate = SUB_NONE;
build.c:	  mprog	 = ch->dest_buf;
build.c:    if ( !can_rmodify( ch, ch->in_room ) )
build.c:    mprog = ch->in_room->mudprogs;
build.c:		ch->in_room->progtypes = 0;
build.c:		   ch->in_room->progtypes |= mprg->type;
build.c:	   mprg_next = ch->in_room->mudprogs;
build.c:	   ch->in_room->mudprogs = mprg_next->next;
build.c:	  REMOVE_BIT( ch->in_room->progtypes, mptype );
build.c:	   ch->in_room->progtypes |= ( 1 << mptype );
build.c:	   ch->in_room->mudprogs = mprg;
build.c:		ch->in_room->progtypes |= ( 1 << mptype );
build.c:	  ch->in_room->mudprogs	= mprg;
build.c:	ch->in_room->progtypes |= ( 1 << mptype );
build.c:    && ( location->vnum < ch->pcdata->r_range_lo || 
build.c:         location->vnum > ch->pcdata->r_range_hi ) )
build.c:    && ( obj->vnum < ch->pcdata->o_range_lo || 
build.c:         obj->vnum > ch->pcdata->o_range_hi ) )
build.c:    && ( mob->vnum < ch->pcdata->m_range_lo || 
build.c:         mob->vnum > ch->pcdata->m_range_hi ) )
build.c: location = ch->in_room;
build.c:    if ( !ch->desc )
build.c:        for ( victim = ch->in_room->first_person; victim; victim = vnext )
build.c:        for ( obj = ch->in_room->first_content; obj; obj = obj_next )
changes.c:    changes_table[maxChanges-1].coder   = str_dup( ch->name );
changes.c:    if (!ch->desc || NULLSTR(arg1) )
clans.c:    if ( IS_NPC( ch ) || !ch->pcdata->clan )
clans.c:    clan = ch->pcdata->clan;
clans.c:    if ( (ch->pcdata && ch->pcdata->bestowments
clans.c:    &&    is_name("induct", ch->pcdata->bestowments))
clans.c:    ||   !str_cmp( ch->name, clan->leader  )
clans.c:    ||   !str_cmp( ch->name, clan->number1 )
clans.c:    ||   !str_cmp( ch->name, clan->number2 ) )
clans.c:   if( !str_cmp( ch->name, clan->leader ) )
clans.c:   if( !str_cmp( ch->name, clan->number1 ) )
clans.c:   if( !str_cmp( ch->name, clan->number2 ) )
clans.c:    if ( IS_NPC( ch ) || !ch->pcdata->clan )
clans.c:    clan = ch->pcdata->clan;
clans.c:    if ( (ch->pcdata && ch->pcdata->bestowments
clans.c:    &&    is_name("outcast", ch->pcdata->bestowments))
clans.c:    ||   !str_cmp( ch->name, clan->leader  )
clans.c:    ||   !str_cmp( ch->name, clan->number1 )
clans.c:    ||   !str_cmp( ch->name, clan->number2 ) )
clans.c:    if ( victim->pcdata->clan != ch->pcdata->clan )
clans.c:    if ( !str_cmp( victim->name, ch->pcdata->clan->number1 ) )
clans.c:	STRFREE( ch->pcdata->clan->number1 );
clans.c:	ch->pcdata->clan->number1 = STRALLOC( "" );
clans.c:    if ( !str_cmp( victim->name, ch->pcdata->clan->number2 ) )
clans.c:	STRFREE( ch->pcdata->clan->number2 );
clans.c:	ch->pcdata->clan->number2 = STRALLOC( "" );
clans.c:  clan = ch->pcdata->clan;
clans.c:    if ( (ch->pcdata && ch->pcdata->bestowments
clans.c:    &&    is_name("induct", ch->pcdata->bestowments))
clans.c:    ||   !str_cmp( ch->name, clan->leader  )
clans.c:    ||   !str_cmp( ch->name, clan->number1 )
clans.c:    ||   !str_cmp( ch->name, clan->number2 ) )
clans.c:	ch->hit -= 10;
clans.c:      if ( ( pexit = get_exit( ch->in_room, dir ) ) == NULL )
clans.c:		if (ch->in_room->area != to_room->area
clans.c:		chance += (ch->top_level - victim->top_level);
clans.c:		move_char( victim, get_exit(ch->in_room,dir), 0);
clans.c:		if ( IS_SET(ch->in_room->room_flags, ROOM_SAFE)
clans.c:     if (( ship = ship_in_room( ch->in_room , arg2 ) ) == NULL )
clans.c:       	echo_to_room(AT_PLAIN, ch->in_room, buf);
clans.c:	ch->hit -= 1;
clans.c:    else if((pexit = get_exit(ch->in_room, (exit_dir = get_dir( arg2 )))) == NULL)
clans.c:    if (ch->in_room->area != to_room->area
clans.c:chance += (ch->top_level - victim->top_level);
clans.c:    move_char( victim, get_exit(ch->in_room,exit_dir), 0);
clans.c:    if ( IS_SET(ch->in_room->room_flags, ROOM_SAFE)
clans.c:    if ((pexit = get_exit(ch->in_room, exit_dir)) == NULL )
clans.c:    if (ch->in_room->area != to_room->area
clans.c:sprintf(buf, "Drag percentage of %s = %d", ch->name, chance);
clans.c:	move_char( victim, get_exit(ch->in_room,exit_dir), 0);
clans.c:	move_char( ch, get_exit(ch->in_room,exit_dir), 0);
clans.c:	if ( IS_NPC(ch) || !ch->pcdata )
clans.c:        if ( ch->pcdata->clan )
clans.c:            ch_printf( ch , "Debes dimitir de %s antes de alistarte en una nueva organización.\n\r", ch->pcdata->clan->name );
clans.c:        if ( IS_SET( ch->in_room->room_flags , ROOM_R_RECRUIT ) )
clans.c:        else if ( IS_SET( ch->in_room->room_flags , ROOM_E_RECRUIT ) )
clans.c:/*        SET_BIT( ch->speaks, LANG_CLAN );*/
clans.c:        add_member(ch->name, clan->shortname);
clans.c:	STRFREE( ch->pcdata->clan_name );
clans.c:	ch->pcdata->clan_name = QUICKLINK( clan->name );
clans.c:	ch->pcdata->clan = clan;
clans.c:        if ( IS_NPC(ch) || !ch->pcdata )
clans.c:        clan =  ch->pcdata->clan;
clans.c:       if ( !str_cmp( ch->name, ch->pcdata->clan->leader ) )
clans.c:/*    if ( ch->speaking & LANG_CLAN )
clans.c:      ch->speaking = LANG_BASIC;
clans.c:    REMOVE_BIT( ch->speaks, LANG_CLAN );*/
clans.c:    if ( !str_cmp( ch->name, ch->pcdata->clan->number1 ) )
clans.c:	STRFREE( ch->pcdata->clan->number1 );
clans.c:	ch->pcdata->clan->number1 = STRALLOC( "" );
clans.c:    if ( !str_cmp( ch->name, ch->pcdata->clan->number2 ) )
clans.c:	STRFREE( ch->pcdata->clan->number2 );
clans.c:	ch->pcdata->clan->number2 = STRALLOC( "" );
clans.c:	    if(!str_cmp(ch->pcdata->clan->name, d->character->pcdata->clan->name))
clans.c:	    	ch_printf(d->character, "&B%s ha dimitido de %s.\n\r", ch->name, ch->pcdata->clan->name);
clans.c:    remove_member(ch->name, ch->pcdata->clan->shortname);
clans.c:    ch->pcdata->clan = NULL;
clans.c:    STRFREE(ch->pcdata->clan_name);
clans.c:    ch->pcdata->clan_name = STRALLOC( "" );
clans.c:    lose_exp = UMAX( ch->experience[POLITICIAN_ABILITY] - exp_level( ch->skill_level[POLITICIAN_ABILITY]  ) , 0 );
clans.c:    ch->experience[POLITICIAN_ABILITY] -= lose_exp;
clans.c:    DISPOSE( ch->pcdata->bestowments );
clans.c:    ch->pcdata->bestowments = str_dup("");
clans.c:    if( ch->pcdata->salary)
clans.c:        ch->pcdata->salary = 0;
clans.c:    if ( IS_NPC( ch ) || !ch->pcdata->clan )
clans.c:    if (!ch->in_room || !IS_SET(ch->in_room->room_flags, ROOM_BANK) )
clans.c:    if ( (ch->pcdata && ch->pcdata->bestowments
clans.c:    &&    is_name("withdraw", ch->pcdata->bestowments))
clans.c:    ||   !str_cmp( ch->name, ch->pcdata->clan->leader  ))
clans.c:    clan = ch->pcdata->clan;
clans.c:    ch->gold += amount;
clans.c:    if ( IS_NPC( ch ) || !ch->pcdata->clan )
clans.c:    if ( (ch->pcdata && ch->pcdata->bestowments
clans.c:    &&    is_name("clanbuyship", ch->pcdata->bestowments))
clans.c:    ||   !str_cmp( ch->name, ch->pcdata->clan->leader  ))
clans.c:    clan = ch->pcdata->clan;
clans.c:    if ( IS_NPC( ch ) || !ch->pcdata->clan )
clans.c:    if (!ch->in_room || !IS_SET(ch->in_room->room_flags, ROOM_BANK) )
clans.c:    clan = ch->pcdata->clan;
clans.c:    if ( amount > ch->gold )
clans.c:    ch->gold -= amount;
clans.c:    if ( IS_NPC( ch ) || !ch->pcdata )
clans.c:    if ( !ch->pcdata->clan )
clans.c:    if (  str_cmp( ch->name, ch->pcdata->clan->leader  )  )
clans.c:         if ( ch->pcdata->clan->number1 && str_cmp( ch->pcdata->clan->number1 , "" ) )
clans.c:         STRFREE( ch->pcdata->clan->number1 );
clans.c:         ch->pcdata->clan->number1 = STRALLOC( arg );
clans.c:         if ( ch->pcdata->clan->number2 && str_cmp( ch->pcdata->clan->number2 , "" ))
clans.c:         STRFREE( ch->pcdata->clan->number2 );
clans.c:         ch->pcdata->clan->number2 = STRALLOC( arg );
clans.c:    save_clan ( ch->pcdata->clan );
clans.c:    if ( IS_NPC( ch ) || !ch->pcdata )
clans.c:    if ( !ch->pcdata->clan )
clans.c:    if (  str_cmp( ch->name, ch->pcdata->clan->leader  )  )
clans.c:    if ( !str_cmp( argument , ch->pcdata->clan->number1 )  )
clans.c:         STRFREE( ch->pcdata->clan->number1 );
clans.c:         ch->pcdata->clan->number1 = STRALLOC( "" );
clans.c:    else if ( !str_cmp( argument , ch->pcdata->clan->number2 )  )
clans.c:         STRFREE( ch->pcdata->clan->number2 );
clans.c:         ch->pcdata->clan->number2 = STRALLOC( "" );
clans.c:    save_clan ( ch->pcdata->clan );
clans.c:    if ( IS_NPC( ch ) || !ch->pcdata || !ch->pcdata->clan )
clans.c:    clan = ch->pcdata->clan;
clans.c:    if ( ( ch->pcdata->bestowments
clans.c:    &&    is_name("war", ch->pcdata->bestowments))
clans.c:    || nifty_is_name( ch->name, clan->leader  ) )
clans.c:    if ( IS_NPC( ch ) || !ch->pcdata->clan )
clans.c:    clan = ch->pcdata->clan;
clans.c:    if ( (ch->pcdata && ch->pcdata->bestowments
clans.c:    &&    is_name("withdraw", ch->pcdata->bestowments))
clans.c:    || !str_cmp( ch->name, clan->leader  ) )
clans.c:    if ( victim->pcdata->clan != ch->pcdata->clan )
clans.c:        ch_printf( victim, "%s ha eliminado todos tus permisos del clan.\n\r", ch->name );
clans.c:             ch->name );
clans.c:             ch->name );
clans.c:             ch->name );
clans.c:             ch->name );
clans.c:      ch_printf( victim, "%s te ha dado permiso para decidir a quién se busca por asesinato.\n\r", ch->name);
clans.c:    if ( IS_NPC( ch ) || !ch->pcdata->clan )
clans.c:    clan = ch->pcdata->clan;
clans.c:    if ( (ch->pcdata && ch->pcdata->bestowments
clans.c:    &&    is_name("outlaw", ch->pcdata->bestowments))
clans.c:    ||   !str_cmp( ch->name, clan->leader  )
clans.c:    ||   !str_cmp( ch->name, clan->number1 )
clans.c:    ||   !str_cmp( ch->name, clan->number2 ) );
clans.c:    if ( IS_NPC( ch ) || !ch->pcdata->clan )
clans.c:    clan = ch->pcdata->clan;
clans.c:    if ( (ch->pcdata && ch->pcdata->bestowments
clans.c:    &&    is_name("unoutlaw", ch->pcdata->bestowments))
clans.c:    ||   !str_cmp( ch->name, clan->leader  )
clans.c:    ||   !str_cmp( ch->name, clan->number1 )
clans.c:    ||   !str_cmp( ch->name, clan->number2 ) );
clans.c:   if(!ch->pcdata->clan)
clans.c:   clan = ch->pcdata->clan;
clans.c:    if ( IS_NPC( ch ) || !ch->pcdata->clan )
clans.c:    clan = ch->pcdata->clan;
clans.c:    if ( str_cmp( ch->name, clan->leader  )
clans.c:    &&   str_cmp( ch->name, clan->number1 )
clans.c:    &&   str_cmp( ch->name, clan->number2 ) )
clans.c:     if ( str_cmp( ch->name, clan->leader  ))
clans.c:    if ( clan->number2 == ch->name && clan->number1 == victim->name )
clans.c:    if ( victim->pcdata->clan != ch->pcdata->clan )
clans.c: if(!ch->pcdata->clan)
clans.c: if(!ch->pcdata->clan->shortname)
clans.c: clan = ch->pcdata->clan;
color.c:	write_to_buffer( ch->desc, log_buf, 0 );
color.c:	write_to_buffer( ch->desc, log_buf, 0 );
color.c:	write_to_buffer( ch->desc, log_buf, 0 );
color.c:	write_to_buffer( ch->desc, log_buf, 0 );
color.c:	write_to_buffer( ch->desc, log_buf, 0 );
color.c:	write_to_buffer( ch->desc, log_buf, 0 );
color.c:	write_to_buffer( ch->desc, log_buf, 0 );
color.c:	write_to_buffer( ch->desc, log_buf, 0 );
color.c:	write_to_buffer( ch->desc, log_buf, 0 );
color.c:	write_to_buffer( ch->desc, log_buf, 0 );
color.c:	write_to_buffer( ch->desc, log_buf, 0 );
color.c:	write_to_buffer( ch->desc, log_buf, 0 );
color.c:	write_to_buffer( ch->desc, log_buf, 0 );
color.c:	write_to_buffer( ch->desc, log_buf, 0 );
color.c:	write_to_buffer( ch->desc, log_buf, 0 );
color.c:	write_to_buffer( ch->desc, log_buf, 0 );
color.c:	write_to_buffer( ch->desc, log_buf, 0 );
color.c:	write_to_buffer( ch->desc, log_buf, 0 );
color.c:	write_to_buffer( ch->desc, log_buf, 0 );
color.c:	write_to_buffer( ch->desc, log_buf, 0 );
color.c:	write_to_buffer( ch->desc, log_buf, 0 );
color.c:	write_to_buffer( ch->desc, log_buf, 0 );
color.c:	write_to_buffer( ch->desc, log_buf, 0 );
color.c:	write_to_buffer( ch->desc, log_buf, 0 );
color.c:	write_to_buffer( ch->desc, log_buf, 0 );
color.c:	write_to_buffer( ch->desc, log_buf, 0 );
color.c:	write_to_buffer( ch->desc, log_buf, 0 );
color.c:	write_to_buffer( ch->desc, log_buf, 0 );
color.c:	write_to_buffer( ch->desc, log_buf, 0 );
color.c:	write_to_buffer( ch->desc, log_buf, 0 );
color.c:	write_to_buffer( ch->desc, log_buf, 0 );
color.c:	write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, ANSI_RESET, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:	write_to_buffer( ch->desc, ANSI_RESET, 0 );
color.c:       ch->colors[count] = default_set[count];
color.c:       ch->colors[ccount] = y;
color.c:     ch->colors[count] = y;
color.c:   memcpy( &ch->colors, &default_set, sizeof(default_set) );
color.c:   if( IS_NPC(ch) || !IS_SET( ch->act, PLR_ANSI ) )
color.c:   switch( ch->colors[AType] )
color.c:	ansi = ( !IS_NPC(ch) && IS_SET( ch->act, PLR_ANSI ) );
color.c:         strncat( code, color_str( ch->desc->pagecolor, ch ), 20 ); 
color.c:   if ( !ch || !ch->desc )
color.c:   write_to_buffer( ch->desc, color_str( AType, ch ), 0 );
color.c:   if( !ch->desc )
color.c:	bug( "set_char_color: NULL descriptor after WTB! CH: %s", ch->name ? ch->name : "Unknown?!?" );
color.c:       ch->desc->pagecolor = ch->colors[AType];
color.c:   if ( !ch || !ch->desc )
color.c:      write_to_pager( ch->desc, color_str( 9, ch), 0 );
color.c:      write_to_pager( ch->desc, color_str( AType, ch ), 0 );
color.c:   if( !ch->desc )
color.c:	bug( "set_pager_color: NULL descriptor after WTP! CH: %s", ch->name ? ch->name : "Unknown?!?" );
color.c:   ch->desc->pagecolor = ch->colors[AType];
color.c:   if( txt && ch->desc )
color.c:            write_to_buffer( ch->desc, prevstr, ( colstr-prevstr ) );
color.c:            write_to_buffer( ch->desc, colbuf, ln );
color.c:         write_to_buffer( ch->desc, prevstr, 0 );
color.c:   if ( txt && ch->desc )
color.c:      DESCRIPTOR_DATA *d = ch->desc;
color.c:      if ( IS_NPC(ch) || !IS_SET( ch->pcdata->flags, PCFLAG_PAGERON ) )
color.c:            write_to_pager( ch->desc, prevstr, ( colstr-prevstr ) );
color.c:            write_to_pager( ch->desc, colbuf, ln );
color.c:         write_to_pager( ch->desc, prevstr, 0 );
comm.c:  for ( ch = first_char; ch; ch = ch->next )
comm.c:    		ch->name, ch->in_room->vnum );
comm.c:		ch ? ch->name : d->host, dclose, first_descriptor );
comm.c:		    ch ? ch->name : d->host, dclose, dp );
comm.c:		    ch ? ch->name : dclose->host, dclose );
comm.c:		ch ? ch->name : d->host, dclose, last_descriptor );
comm.c:		    ch ? ch->name : d->host, dclose, dn );
comm.c:		    ch ? ch->name : dclose->host, dclose );
comm.c:	sprintf( log_buf, "Closing link to %s.", ch->name );
comm.c:	log_string_plus( log_buf, LOG_COMM, UMAX( sysdata.log_level, ch->top_level ) );
comm.c:	if ( ch->top_level < LEVEL_DEMI )
comm.c:	  to_channel( log_buf, CHANNEL_MONITOR, "Monitor", ch->top_level );
comm.c:	    ch->desc = NULL;
comm.c:    if( ch && ch->fighting && ch->fighting->who )
comm.c:         show_condition( ch, ch->fighting->who );
comm.c:	if ( IS_SET(ch->act, PLR_BLANK) )
comm.c:	if ( IS_SET(ch->act, PLR_PROMPT) )
comm.c:	if ( IS_SET(ch->act, PLR_TELNET_GA) )
comm.c:    if ( !IS_SET( ch->pcdata->flags, PCFLAG_NOINTRO ) )
comm.c:	if (IS_SET(ch->act, PLR_ANSI))
comm.c:	  && pban->level >= ch->top_level )
comm.c:	if ( IS_SET(ch->act, PLR_DENY) )
comm.c://        bug(crypt(argument, ch->pcdata->pwd), 0);
comm.c:        if ( strcmp( smaug_crypt( argument ), ch->pcdata->pwd ) )
comm.c:            sprintf(buf, "%s@%s: Invalid password.", ch->name, d->host);
comm.c:	if ( check_playing( d, ch->name, TRUE ) )
comm.c:	chk = check_reconnect( d, ch->name, TRUE );
comm.c:        if ( check_multi( d , ch->name  ) )
comm.c:	sprintf( buf, ch->name );
comm.c:	sprintf( log_buf, "%s@%s(%s) has connected.", ch->name, d->host, d->user );
comm.c:	if ( ch->top_level < LEVEL_DEMI )
comm.c:	  /*to_channel( log_buf, CHANNEL_MONITOR, "Monitor", ch->top_level );*/
comm.c:	  log_string_plus( log_buf, LOG_COMM, ch->top_level );
comm.c:           sprintf(log_buf, "%-20s     %-24s    %s", ch->name, day, d->host);
comm.c:	if ( ch->pcdata->area )
comm.c:        if( ch->max_mana != (ch->force_control + ch->force_sense + ch->force_alter) * 3 * ch->force_level_status)
comm.c:             ch->max_mana = (ch->force_control + ch->force_sense + ch->force_alter) * 3 * ch->force_level_status;
comm.c:        ch->mana = ch->max_mana;
comm.c:        if(ch->force_identified == 1 && ch->force_level_status == FORCE_MASTER)
comm.c:            if(ch->force_skill[FORCE_SKILL_PARRY] < 50)
comm.c:                ch->force_skill[FORCE_SKILL_PARRY] = 50;
comm.c:            ft = ch->force_type;
comm.c:            	if((skill->type == ft || skill->type == FORCE_GENERAL) && ch->force_skill[skill->index] < 50 && (strcmp(skill->name,"master") && strcmp(skill->name,"student") && strcmp(skill->name,"promote") && strcmp(skill->name,"instruct")))
comm.c:                    ch->force_skill[skill->index] = 50;
comm.c:		ch->name, echo_off_str );
comm.c:	DISPOSE( ch->pcdata->pwd );
comm.c:	ch->pcdata->pwd	= str_dup( pwdnew );
comm.c:	if ( strcmp( smaug_crypt( argument ), ch->pcdata->pwd ) )
comm.c:	case 'm': case 'M': ch->sex = SEX_MALE;    break;
comm.c:	case 'f': case 'F': ch->sex = SEX_FEMALE;  break;
comm.c:	case 'n': case 'N': ch->sex = SEX_NEUTRAL; break;
comm.c:		ch->race = iRace;
comm.c:		ch->main_ability = iClass;
comm.c:	  if (ability_name[iClass] && ability_name[iClass][0] != '\0' && str_cmp(ability_name[iClass], "force") && ch->main_ability != iClass)
comm.c:	    &&   !str_prefix( arg, ability_name[iClass] )  && str_prefix(arg, "force") && ch->main_ability != iClass)
comm.c:		ch->secondary_ability = iClass;
comm.c:	    ch->perm_str = number_range(1, 6)+number_range(1, 6)+number_range(1, 6);
comm.c:	    ch->perm_int = number_range(3, 6)+number_range(1, 6)+number_range(1, 6);
comm.c:	    ch->perm_wis = number_range(3, 6)+number_range(1, 6)+number_range(1, 6);
comm.c:	    ch->perm_dex = number_range(3, 6)+number_range(1, 6)+number_range(1, 6);
comm.c:	    ch->perm_con = number_range(3, 6)+number_range(1, 6)+number_range(1, 6);
comm.c:	    ch->perm_cha = number_range(3, 6)+number_range(1, 6)+number_range(1, 6);
comm.c:	    ch->perm_str	 += race_table[ch->race].str_plus;
comm.c:	    ch->perm_int	 += race_table[ch->race].int_plus;
comm.c:	    ch->perm_wis	 += race_table[ch->race].wis_plus;
comm.c:	    ch->perm_dex	 += race_table[ch->race].dex_plus;
comm.c:	    ch->perm_con	 += race_table[ch->race].con_plus;
comm.c:	    ch->perm_cha	 += race_table[ch->race].cha_plus;
comm.c:	    ch->perm_str, ch->perm_int, ch->perm_wis, 
comm.c:	    ch->perm_dex, ch->perm_con, ch->perm_cha) ;
comm.c:	    ch->perm_str = number_range(1, 6)+number_range(1, 6)+number_range(1, 6);
comm.c:	    ch->perm_int = number_range(3, 6)+number_range(1, 6)+number_range(1, 6);
comm.c:	    ch->perm_wis = number_range(3, 6)+number_range(1, 6)+number_range(1, 6);
comm.c:	    ch->perm_dex = number_range(3, 6)+number_range(1, 6)+number_range(1, 6);
comm.c:	    ch->perm_con = number_range(3, 6)+number_range(1, 6)+number_range(1, 6);
comm.c:	    ch->perm_cha = number_range(3, 6)+number_range(1, 6)+number_range(1, 6);
comm.c:	    ch->perm_str	 += race_table[ch->race].str_plus;
comm.c:	    ch->perm_int	 += race_table[ch->race].int_plus;
comm.c:	    ch->perm_wis	 += race_table[ch->race].wis_plus;
comm.c:	    ch->perm_dex	 += race_table[ch->race].dex_plus;
comm.c:	    ch->perm_con	 += race_table[ch->race].con_plus;
comm.c:	    ch->perm_cha	 += race_table[ch->race].cha_plus;
comm.c:	    ch->perm_str, ch->perm_int, ch->perm_wis, 
comm.c:	    ch->perm_dex, ch->perm_con, ch->perm_cha) ;
comm.c:		ch->pheight = iClass;
comm.c:		ch->build = iClass;
comm.c:		ch->build = iDroid;
comm.c:	SET_BIT(ch->act,PLR_ANSI);
comm.c:	case 'a': case 'A': SET_BIT(ch->act,PLR_ANSI);  break;
comm.c:	case 's': case 'S': SET_BIT(ch->act,PLR_SOUND);  break;
comm.c: 	    sprintf( log_buf, "%s@%s new %s.", ch->name, d->host, race_table[ch->race].race_name);
comm.c:	          ch->skill_level[ability] = 0;
comm.c:		  ch->bonus[ability] = 0;
comm.c:	    ch->top_level = 0;
comm.c:	    ch->position = POS_STANDING;
comm.c:	    ch->comfreq = STRALLOC(buf);
comm.c:				ch->name, d->host,
comm.c:				race_table[ch->race].race_name);
comm.c:				ch->name, d->host,
comm.c:				race_table[ch->race].race_name);
comm.c:				ch->name, d->host,
comm.c:				race_table[ch->race].race_name);
comm.c:	sprintf( log_buf, "%s@%s new %s.", ch->name, d->host,
comm.c:				race_table[ch->race].race_name);
comm.c:	          ch->skill_level[ability] = 0;
comm.c:		  ch->bonus[ability] = 0;
comm.c:	ch->top_level = 0;
comm.c:	ch->position = POS_STANDING;
comm.c:/*	if ( IS_SET(ch->act, PLR_ANSI) )
comm.c:	if ( ch->top_level >= 0 )
comm.c:       /* if(ch->comfreq == NULL)
comm.c:	 sprintf(buf, "%s has no comfreq. Generating.", ch->name);
comm.c:	sprintf(buf, " %s has entered the game.", ch->name);
comm.c:	if ( ch->top_level == 0 )
comm.c:	    ch->pcdata->clan	  = NULL;
comm.c:	    ch->pcdata->learned[gsn_smallspace] = 25;
comm.c:	    ch->pcdata->learned[gsn_shipsystems] = 25;
comm.c:	    ch->pcdata->learned[gsn_navigation] = 25;
comm.c:	    ch->pcdata->learned[gsn_scan] = 25;
comm.c:	    ch->perm_lck = number_range(6, 18);
comm.c:            ch->perm_frc = number_range(-1000, 20);
comm.c:	    ch->affected_by	  = race_table[ch->race].affected;
comm.c:	    ch->perm_lck	 += race_table[ch->race].lck_plus;
comm.c:	    ch->perm_frc = 0; // ch->perm_frc	 += race_table[ch->race].frc_plus;
comm.c:            if ( ch->main_ability == FORCE_ABILITY )
comm.c:               ch->perm_frc = 0; // ch->perm_frc = URANGE( 0 , ch->perm_frc , 20 );
comm.c:	       ch->perm_frc = 0; //ch->perm_frc = URANGE( 0 , ch->perm_frc , 20 );
comm.c:	    if( ch->main_ability == HUNTING_ABILITY || ch->main_ability == ASSASSIN_ABILITY || IS_DROID(ch))
comm.c:	       ch->perm_frc = 0;
comm.c:	    	ch->pcdata->learned[iLang] = 100;
comm.c:ch->speaking	=  iLang;
comm.c:	    	if ( lang_array[iLang] == race_table[ch->race].language )
comm.c:		  ch->pcdata->learned[iLang] = 100;
comm.c:    		  ch->speaking	=  LANG_BINARY;
comm.c:		  SET_BIT(ch->speaks, LANG_BINARY);
comm.c:	    		ch->pcdata->learned[iLang] = 100;
comm.c:	    		ch->speaking	=  race_table[ch->race].language;
comm.c:		   if ( ch->race == RACE_QUARREN && 
comm.c:	    	        ch->pcdata->learned[iLang] = 100;
comm.c:		        SET_BIT( ch->speaks , LANG_QUARREN );
comm.c:		   if ( ch->race == RACE_MON_CALAMARI && 
comm.c:	    	        ch->pcdata->learned[iLang] = 100;
comm.c:            /* ch->resist           += race_table[ch->race].resist;    drats */
comm.c:            /* ch->susceptible     += race_table[ch->race].suscept;    drats */
comm.c:	          ch->skill_level[ability] = 1;
comm.c:	          ch->experience[ability] = 0;
comm.c:		  ch->bonus[ability] = 0;
comm.c:	    ch->top_level = 1;
comm.c:	    ch->hit	= ch->max_hit;
comm.c:            ch->hit    += race_table[ch->race].hit;
comm.c:	    ch->move	= ch->max_move;
comm.c:	    if ( ch->perm_frc > 0 )
comm.c:         	 ch->max_mana = 100 + 100*ch->perm_frc;
comm.c:	         ch->max_mana = 0;
comm.c:	    ch->mana	= ch->max_mana;
comm.c:	    sprintf( buf, "%s el %s",ch->name,
comm.c:		race_table[ch->race].race_name );
comm.c:	    ch->gold = 10000;
comm.c:            SET_BIT( ch->act, PLR_AUTOGOLD ); 
comm.c:            SET_BIT( ch->act, PLR_AUTOEXIT ); 
comm.c:	    if( ch->race != RACE_DEFEL )
comm.c:	      ch->pcdata->auth_state = 3; 
comm.c:	      ch->pcdata->auth_state = 1;
comm.c:	      SET_BIT(ch->pcdata->flags, PCFLAG_UNAUTHED);
comm.c:	if ( !IS_IMMORTAL(ch) && ch->pcdata->release_date > current_time )
comm.c:	else if ( ch->in_room && !IS_IMMORTAL( ch ) 
comm.c:             && !IS_SET( ch->in_room->room_flags, ROOM_SPACECRAFT )
comm.c:             && ch->in_room != get_room_index(6) )
comm.c:	    char_to_room( ch, ch->in_room );
comm.c:	else if ( ch->in_room && !IS_IMMORTAL( ch )  
comm.c:             && IS_SET( ch->in_room->room_flags, ROOM_SPACECRAFT )
comm.c:             && ch->in_room != get_room_index(6) )
comm.c:	      if ( ch->in_room->vnum >= ship->firstroom && ch->in_room->vnum <= ship->lastroom )
comm.c:                  char_to_room( ch, ch->in_room );
comm.c:    if ( ch->plr_home != NULL )
comm.c:         ROOM_INDEX_DATA *storeroom = ch->plr_home;
comm.c:	 sprintf( filename, "%s%c/%s.home", PLAYER_DIR, tolower(ch->name[0]),
comm.c:				 capitalize( ch->name ) );
comm.c:		    bug( ch->name, 0 );
comm.c:		    bug( ch->name, 0 );
comm.c:	 if(ch->skill_level[ability] > max_level(ch, ability))
comm.c:	    ch->skill_level[ability] = max_level(ch, ability);
comm.c:				SET_BIT( ch->speaks, lang_array[iLang] );
comm.c:    for ( ch = first_char; ch; ch = ch->next )
comm.c:	&& ( !fConn || !ch->desc )
comm.c:	&&    ch->name
comm.c:	&&   !str_cmp( name, ch->name ) )
comm.c:	    if ( fConn && ch->switched )
comm.c:		d->character->pcdata->pwd = str_dup( ch->pcdata->pwd );
comm.c:		ch->desc	 = d;
comm.c:		ch->timer	 = 0;
comm.c:		sprintf( log_buf, "%s@%s(%s) reconnected.", ch->name, d->host, d->user );
comm.c:		log_string_plus( log_buf, LOG_COMM, UMAX( sysdata.log_level, ch->top_level ) );
comm.c:		if ( ch->top_level < LEVEL_SAVIOR )
comm.c:		  to_channel( log_buf, CHANNEL_MONITOR, "Monitor", ch->top_level );
comm.c:	    if ( !ch->name
comm.c:		sprintf( log_buf, "%s already connected.", ch->name );
comm.c:	    ch->desc	 = d;
comm.c:	    ch->timer	 = 0;
comm.c:	    if ( ch->switched )
comm.c:	      do_return( ch->switched, "" );
comm.c:	    ch->switched = NULL;
comm.c:	             ch->name, d->host );
comm.c:	    log_string_plus( log_buf, LOG_COMM, UMAX( sysdata.log_level, ch->top_level ) );
comm.c:	    if ( ch->top_level < LEVEL_SAVIOR )
comm.c:	      to_channel( log_buf, CHANNEL_MONITOR, "Monitor", ch->top_level );
comm.c:    ||   !ch->desc
comm.c:    ||    ch->desc->connected != CON_PLAYING
comm.c:    ||   !ch->was_in_room
comm.c:    ||    ch->in_room != get_room_index( ROOM_VNUM_LIMBO ) )
comm.c:    ch->timer = 0;
comm.c:    char_to_room( ch, ch->was_in_room );
comm.c:    ch->was_in_room	= NULL;
comm.c:    if ( txt && ch->desc )
comm.c:	 write_to_buffer( ch->desc, buf, strlen(buf) );
comm.c:/* Changed so it shows PERS instead of ch->name... sometimes -- Tawnos */
comm.c:#define NAME(ch)	(IS_NPC(ch) ? ch->short_descr : ch->name)
comm.c:      case 'e': if (ch->sex > 2 || ch->sex < 0)
comm.c:		  bug("act_string: player %s has sex set at %d!", ch->name,
comm.c:		      ch->sex);
comm.c:		  i = he_she [URANGE(0,  ch->sex, 2)];
comm.c:      case 'E': if (vch->sex > 2 || vch->sex < 0)
comm.c:		  bug("act_string: player %s has sex set at %d!", vch->name,
comm.c:		      vch->sex);
comm.c:		  i = he_she [URANGE(0, vch->sex, 2)];
comm.c:      case 'm': if (ch->sex > 2 || ch->sex < 0)
comm.c:		  bug("act_string: player %s has sex set at %d!", ch->name,
comm.c:		      ch->sex);
comm.c:		  i = him_her[URANGE(0,  ch->sex, 2)];
comm.c:      case 'M': if (vch->sex > 2 || vch->sex < 0)
comm.c:		  bug("act_string: player %s has sex set at %d!", vch->name,
comm.c:		      vch->sex);
comm.c:		  i = him_her[URANGE(0, vch->sex, 2)];
comm.c:      case 's': if (ch->sex > 2 || ch->sex < 0)
comm.c:		  bug("act_string: player %s has sex set at %d!", ch->name,
comm.c:		      ch->sex);
comm.c:		  i = his_her[URANGE(0,  ch->sex, 2)];
comm.c:      case 'S': if (vch->sex > 2 || vch->sex < 0)
comm.c:		  bug("act_string: player %s has sex set at %d!", vch->name,
comm.c:		      vch->sex);
comm.c:		  i = his_her[URANGE(0, vch->sex, 2)];
comm.c:		    his_her[URANGE(0,  ch->sex, 2)];			break;
comm.c:    if ( !ch->in_room )
comm.c:      to = ch->in_room->first_person;
comm.c:    if ( IS_NPC(ch) && IS_SET(ch->act, ACT_SECRETIVE) && type != TO_CHAR )
comm.c:	    bug( "%s (%s)", ch->name, format );
comm.c:	if ( !vch->in_room )
comm.c:	    bug( "%s -> %s (%s)", ch->name, vch->name, format );
comm.c:/*	to = vch->in_room->first_person;*/
comm.c:  if ( !NOT_AUTHED(ch) || ch->pcdata->auth_state != 2)
comm.c:  if (!str_cmp(ch->name, argument))
comm.c:  STRFREE( ch->name );
comm.c:  ch->name = STRALLOC( argument );
comm.c:  ch->pcdata->auth_state = 0;
comm.c:  if (ch->skill_level[FORCE_ABILITY] > 1 || get_trust(ch) >= LEVEL_IMMORTAL )
comm.c:  if (ch->position == POS_FIGHTING)
comm.c:  bool ansi = (!IS_NPC(och) && IS_SET(och->act, PLR_ANSI));
comm.c:  if ( !IS_NPC(ch) && ch->substate != SUB_NONE && ch->pcdata->subprompt
comm.c:  &&   ch->pcdata->subprompt[0] != '\0' )
comm.c:    prompt = ch->pcdata->subprompt;
comm.c:  if ( IS_NPC(ch) || !ch->pcdata->prompt || !*ch->pcdata->prompt )
comm.c:    prompt = ch->pcdata->prompt;
comm.c:	if ( ch->top_level >= 10 )
comm.c:	  stat = ch->alignment;
comm.c:        if(ch->position == POS_FIGHTING)
comm.c:	stat = ch->hit;
comm.c:	stat = ch->max_hit;
comm.c:	if ( IS_IMMORTAL(ch) || ch->skill_level[FORCE_ABILITY] > 1 )
comm.c:	  stat = ch->mana;
comm.c:	if ( IS_IMMORTAL(ch) || ch->skill_level[FORCE_ABILITY] > 1 )
comm.c:	  stat = ch->max_mana;
comm.c:	stat = ch->move;
comm.c:	stat = ch->max_move;
comm.c:	stat = ch->gold;
comm.c:	  stat = ch->in_room->vnum;
comm.c:	if ( IS_SET(och->act, PLR_ROOMVNUM) )
comm.c:	  sprintf(pbuf, "<#%d> ", ch->in_room->vnum);
comm.c:	if ( (!IS_NPC(ch) && IS_SET(ch->act, PLR_WIZINVIS)) ||
comm.c:	      (IS_NPC(ch) && IS_SET(ch->act, ACT_MOBINVIS)) )
comm.c:	  sprintf(pbuf, "(Invis %d) ", (IS_NPC(ch) ? ch->mobinvis : ch->pcdata->wizinvis));
comm.c:	stat = (IS_NPC(ch) ? (IS_SET(ch->act, ACT_MOBINVIS) ? ch->mobinvis : 0)
comm.c:	     : (IS_SET(ch->act, PLR_WIZINVIS) ? ch->pcdata->wizinvis : 0));
comm.c:  pclines = UMAX(ch->pcdata->pagerlen, 5) - 1;
comm.c:  if ( IS_SET( ch->act, PLR_ANSI ) )
comm.c:  if ( IS_SET( ch->act, PLR_ANSI ) )
comm.c:  for(fellow=ch->first_fellow;fellow;fellow=fellow->next)
comm.c:      return ch->short_descr;  
comm.c:	    return ch->name;
comm.c:      else if(ch->pcdata->disguise && ch->pcdata->disguise[0] != '\0')
comm.c:	    return ch->pcdata->disguise;
comm.c:	  return ch->name;
comm.c:	sprintf(race, "%s", npc_race[ch->race]);
comm.c:					 ch->sex == 1 ? "varón" : ch->sex == 2 ? 
comm.c:					 height_name[ch->pheight]);
comments.c:    if ( !ch->desc )
comments.c:    if ( ch->desc->connected == CON_EDITING )
comments.c:    switch( ch->substate )
comments.c:	  if ( !ch->pnote )
comments.c:	  if ( ch->dest_buf != ch->pnote )
comments.c:	     bug( "do_comment: sub_writing_note: ch->dest_buf != ch->pnote", 0 );
comments.c:	  STRFREE( ch->pnote->text );
comments.c:	  ch->pnote->text = copy_buffer( ch );
comments.c:	ch->substate = SUB_WRITING_NOTE;
comments.c:	ch->dest_buf = ch->pnote;
comments.c:	start_editing( ch, ch->pnote->text );
comments.c:	STRFREE( ch->pnote->subject );
comments.c:	ch->pnote->subject = STRALLOC( argument );
comments.c:	STRFREE( ch->pnote->to_list );
comments.c:	ch->pnote->to_list = STRALLOC( argument );
comments.c:	if ( ch->pnote )
comments.c:	    STRFREE( ch->pnote->text );
comments.c:	    STRFREE( ch->pnote->subject );
comments.c:	    STRFREE( ch->pnote->to_list );
comments.c:	    STRFREE( ch->pnote->date );
comments.c:	    STRFREE( ch->pnote->sender );
comments.c:	    DISPOSE( ch->pnote );
comments.c:	ch->pnote = NULL;
comments.c:	if ( !ch->pnote )
comments.c:	    ch->pnote->sender,
comments.c:	    ch->pnote->subject,
comments.c:	    ch->pnote->to_list
comments.c:	send_to_char( ch->pnote->text, ch );
comments.c:	if ( !ch->pnote )
comments.c:        STRFREE( ch->pnote->date );
comments.c:	ch->pnote->date			= STRALLOC( strtime );
comments.c:	pnote		= ch->pnote;
comments.c:	ch->pnote	= NULL;
comments.c:   if(!ch->comments)
comments.c:   for(pnote=ch->comments;pnote;pnote=pnote->next)
comments.c:	pnote->next		= ch->comments;
comments.c:	ch->comments		= pnote;
copyover.c:      for( rch = first_char; rch; rch = rch->next )
copyover.c:         if( !IS_NPC( rch ) || rch == supermob || IS_SET( rch->act, ACT_PROTOTYPE ) || IS_SET( rch->act, ACT_PET ) )
copyover.c:   sprintf( log_buf, "Copyover initiated by %s.", ch->name );
copyover.c:   if( ch && ch->desc )
copyover.c:      write_to_descriptor( ch->desc->descriptor, "\033[0m", 0 );
copyover.c:                  d->can_compress, och->in_room->vnum, d->port, d->idle, och->name, d->host );
copyover.c:         och->pcdata->hotboot = TRUE;
copyover.c:                  d->can_compress, och->in_room->vnum, d->port, d->idle, och->name, d->host );
copyover.c:            och->pcdata->hotboot = TRUE;
copyover.c:      vch_next = vch->next;
db.c:	    for ( pch = first_char; pch; pch = pch->next )
db.c:		&&   pch->in_room
db.c:		&&   pch->in_room->area == pArea )
db.c:    ch->editor			= NULL;
db.c:    ch->hunting			= NULL;
db.c:    ch->fearing			= NULL;
db.c:    ch->hating			= NULL;
db.c:    ch->name			= NULL;
db.c:    ch->short_descr		= NULL;
db.c:    ch->long_descr		= NULL;
db.c:    ch->description		= NULL;
db.c:    ch->next			= NULL;
db.c:    ch->prev			= NULL;
db.c:    ch->first_carrying		= NULL;
db.c:    ch->last_carrying		= NULL;
db.c:    ch->next_in_room		= NULL;
db.c:    ch->prev_in_room		= NULL;
db.c:    ch->fighting		= NULL;
db.c:    ch->switched		= NULL;
db.c:    ch->first_affect		= NULL;
db.c:    ch->last_affect		= NULL;
db.c:    ch->prev_cmd		= NULL;    /* maps */
db.c:    ch->last_cmd		= NULL;
db.c:    ch->dest_buf		= NULL;
db.c:    ch->dest_buf_2		= NULL;
db.c:    ch->spare_ptr		= NULL;
db.c:    ch->mount			= NULL;
db.c:    ch->affected_by		= 0;
db.c:    ch->logon			= current_time;
db.c:    ch->armor			= 100;
db.c:    ch->position		= POS_STANDING;
db.c:    ch->hit			= 500;
db.c:    ch->max_hit			= 500;
db.c:    ch->mana			= 1000;
db.c:    ch->max_mana		= 0;
db.c:    ch->move			= 1000;
db.c:    ch->max_move		= 1000;
db.c:    ch->height			= 72;
db.c:    ch->weight			= 180;
db.c:    ch->xflags			= 0;
db.c:    ch->race			= 0;
db.c:    ch->speaking		= LANG_BASIC;
db.c:    ch->speaks			= LANG_BASIC;
db.c:    ch->barenumdie		= 1;
db.c:    ch->baresizedie		= 4;
db.c:    ch->substate		= 0;
db.c:    ch->tempnum			= 0;
db.c:    ch->perm_str		= 10;
db.c:    ch->perm_dex		= 10;
db.c:    ch->perm_int		= 10;
db.c:    ch->perm_wis		= 10;
db.c:    ch->perm_cha		= 10;
db.c:    ch->perm_con		= 10;
db.c:    ch->perm_lck		= 10;
db.c:    ch->mod_str			= 0;
db.c:    ch->mod_dex			= 0;
db.c:    ch->mod_int			= 0;
db.c:    ch->mod_wis			= 0;
db.c:    ch->mod_cha			= 0;
db.c:    ch->mod_con			= 0;
db.c:    ch->mod_lck			= 0;
db.c:    ch->pagelen                 = 24; 		     /* BUILD INTERFACE */
db.c:    ch->inter_page 		= NO_PAGE;           /* BUILD INTERFACE */
db.c:    ch->inter_type 		= NO_TYPE;           /* BUILD INTERFACE */
db.c:    ch->inter_editing    	= NULL;              /* BUILD INTERFACE */
db.c:    ch->inter_editing_vnum	= -1;                /* BUILD INTERFACE */
db.c:    ch->inter_substate    	= SUB_NORTH;         /* BUILD INTERFACE */
db.c:    ch->plr_home                = NULL;
db.c:    if ( ch->desc )
db.c:    while ( (obj = ch->last_carrying) != NULL )
db.c:    while ( (paf = ch->last_affect) != NULL )
db.c:    while ( (timer = ch->first_timer) != NULL )
db.c:   while( ( bugs = ch->first_bug ) != NULL )
db.c:      UNLINK( bugs, ch->first_bug, ch->last_bug, next_in_bug, prev_in_bug );
db.c:   while( ( contract = ch->first_contract ) != NULL )
db.c:      UNLINK( contract, ch->first_contract, ch->last_contract, next_in_contract, prev_in_contract );
db.c:   while( ( fellow = ch->first_fellow ) != NULL )
db.c:      UNLINK( fellow, ch->first_fellow, ch->last_fellow, next, prev );
db.c:    STRFREE( ch->name		);
db.c:    STRFREE( ch->short_descr	);
db.c:    STRFREE( ch->long_descr	);
db.c:    STRFREE( ch->description	);
db.c:    STRFREE( ch->spec_funname );
db.c:    STRFREE( ch->spec_funname2 );
db.c:    if ( ch->editor )
db.c:    if ( ch->inter_editing )
db.c:      DISPOSE( ch->inter_editing );
db.c:    if ( ch->pnote )
db.c:	free_note( ch->pnote );
db.c:    if ( ch->pcdata )
db.c:	STRFREE( ch->pcdata->clan_name	);
db.c:        DISPOSE( ch->pcdata->pwd	);  /* no hash */
db.c:	DISPOSE( ch->pcdata->email	);  /* no hash */
db.c:	DISPOSE( ch->pcdata->bamfin	);  /* no hash */
db.c:	DISPOSE( ch->pcdata->bamfout	);  /* no hash */
db.c:	STRFREE( ch->pcdata->title	);
db.c:	STRFREE( ch->pcdata->disguise	);
db.c:	STRFREE( ch->pcdata->bio	); 
db.c:	DISPOSE( ch->pcdata->bestowments);  /* no hash */
db.c:	DISPOSE( ch->pcdata->homepage	);  /* no hash */
db.c:	DISPOSE( ch->pcdata->screenname	);  /* no hash */
db.c:	DISPOSE( ch->pcdata->image	);  /* no hash */
db.c:	STRFREE( ch->pcdata->authed_by	);
db.c:	STRFREE( ch->pcdata->prompt	);
db.c:	if ( ch->pcdata->subprompt )
db.c:	   STRFREE( ch->pcdata->subprompt );
db.c:      STRFREE( ch->pcdata->tell_snoop );
db.c:      STRFREE( ch->pcdata->last_name );
db.c:      STRFREE( ch->pcdata->fiance );
db.c:      STRFREE( ch->pcdata->propose );
db.c:      STRFREE( ch->pcdata->proposed );
db.c:      STRFREE( ch->pcdata->spouse );
db.c:      STRFREE( ch->pcdata->shipname );
db.c:      STRFREE( ch->pcdata->helled_by );
db.c:	DISPOSE( ch->pcdata );
db.c:     STRFREE( ch->owner );
db.c:     STRFREE( ch->force_master );
db.c:     STRFREE( ch->force_temp_master );
db.c:     STRFREE( ch->force_disguise );
db.c:     STRFREE( ch->comfreq );
db.c:     DISPOSE( ch->rank );
db.c:    for ( mpact = ch->mpact; mpact; mpact = mpact_next )
db.c:    for ( comments = ch->comments; comments; comments = comments_next )
db.c:	    ch->in_room ? ch->in_room->vnum : 0, ch->name, str );
db.c:   for( ch = first_char; ch; ch = ch->next )
db.c:      if( ch->was_in_room == room )
db.c:         ch->was_in_room = ch->in_room;
db.c:      if( ch->substate == SUB_ROOM_DESC && ch->dest_buf == room )
db.c:         ch->substate = SUB_NONE;
db.c:         ch->dest_buf = NULL;
db.c:      else if( ch->substate == SUB_ROOM_EXTRA && ch->dest_buf )
db.c:            if( ed == ch->dest_buf )
db.c:               ch->substate = SUB_NONE;
db.c:               ch->dest_buf = NULL;
db.c:   for( ch = first_char; ch; ch = ch->next )
db.c:      if( ch->substate == SUB_OBJ_EXTRA && ch->dest_buf )
db.c:            if( ed == ch->dest_buf )
db.c:               ch->substate = SUB_NONE;
db.c:      else if( ch->substate == SUB_MPROG_EDIT && ch->dest_buf )
db.c:            if( mp == ch->dest_buf )
db.c:               ch->dest_buf = NULL;
db.c:               ch->substate = SUB_NONE;
db.c:    ch_next = ch->next;
db.c:      if( ch->pIndexData == mob )
db.c:      ch_next = ch->next;
db.c:      if( ch->pIndexData == mob )
db.c:      else if( ch->substate == SUB_MPROG_EDIT && ch->dest_buf )
db.c:            if( mp == ch->dest_buf )
db.c:               ch->dest_buf = NULL;
db.c:               ch->substate = SUB_NONE;
editor.c:	if( !ch || !ch->editor )
editor.c:	if( ch->editor->desc )
editor.c:		STRFREE( ch->editor->desc );
editor.c:	ch->editor->desc = STRALLOC( new_desc );
editor.c:	if ( !ch->desc )
editor.c:	if ( ch->substate == SUB_RESTRICTED )
editor.c:	   bug( "NOT GOOD: start_editing: ch->substate == SUB_RESTRICTED", 0 );
editor.c:	if ( ch->editor )
editor.c:	ch->editor = str_to_editdata( old_text, max_total );
editor.c:	ch->editor->desc = STRALLOC( "Unknown buffer" );
editor.c:	ch->desc->connected = CON_EDITING;
editor.c:   if ( !ch->editor )
editor.c:   buf = editdata_to_str( ch->editor );
editor.c:    discard_editdata( ch->editor );
editor.c:    ch->editor = NULL;
editor.c:    ch->dest_buf  = NULL;
editor.c:    ch->spare_ptr = NULL;
editor.c:    ch->substate  = SUB_NONE;
editor.c:    if ( !ch->desc )
editor.c:    ch->desc->connected = CON_PLAYING;
editor.c:    d = ch->desc;
editor.c:    if ( ch->substate <= SUB_PAUSE )
editor.c:	bug( "Edit_buffer: illegal ch->substate (%d)", ch->substate );
editor.c:    if ( !ch->editor )
editor.c:    edd = ch->editor;
editor.c:    ch->editor = str_to_editdata( "", max_size );
editor.c:    ch->editor->desc = desc;
editor.c:	ch->editor = cloned_edd;
editor.c:	int substate = ch->substate;
editor.c:	last_cmd = ch->last_cmd;
editor.c:	ch->substate = SUB_RESTRICTED;
editor.c:	ch->substate = substate;
editor.c:	ch->last_cmd = last_cmd;
editor.c:    d = ch->desc;
editor.c:    if ( !ch->last_cmd )
editor.c:    (*ch->last_cmd) ( ch, "" );
fight.c:   int oldgold = ch->gold;
fight.c:      if( !CAN_WEAR( content, ITEM_TAKE ) && ch->top_level < sysdata.level_getobjnotake )
fight.c:      ch->gold += content->value[0] * content->count;
fight.c:   if( ch->gold - oldgold > 1 && ch->position > POS_SLEEPING )
fight.c:      snprintf( buf, MAX_INPUT_LENGTH, "%d", ch->gold - oldgold );
fight.c:    if ( !ch->hunting || ch->hunting->who != victim )
fight.c:    if ( !ch->hating || ch->hating->who != victim )
fight.c:    if ( !ch->fearing || ch->fearing->who != victim )
fight.c:    if ( ch->hunting )
fight.c:	STRFREE( ch->hunting->name );
fight.c:	DISPOSE( ch->hunting );
fight.c:	ch->hunting = NULL;
fight.c:    if ( ch->hating )
fight.c:	STRFREE( ch->hating->name );
fight.c:	DISPOSE( ch->hating );
fight.c:	ch->hating = NULL;
fight.c:    if ( ch->fearing )
fight.c:	STRFREE( ch->fearing->name );
fight.c:	DISPOSE( ch->fearing );
fight.c:	ch->fearing = NULL;
fight.c:    if ( ch->hunting )
fight.c:    CREATE( ch->hunting, HHF_DATA, 1 );
fight.c:    ch->hunting->name = QUICKLINK( victim->name );
fight.c:    ch->hunting->who  = victim;
fight.c:    if ( ch->hating )
fight.c:    CREATE( ch->hating, HHF_DATA, 1 );
fight.c:    ch->hating->name = QUICKLINK( victim->name );
fight.c:    ch->hating->who  = victim;
fight.c:    if ( ch->fearing )
fight.c:    CREATE( ch->fearing, HHF_DATA, 1 );
fight.c:    ch->fearing->name = QUICKLINK( victim->name );
fight.c:    ch->fearing->who  = victim;
fight.c:	if ( ch == first_char && ch->prev )
fight.c:	   ch->prev = NULL;
fight.c:	gch_prev	= ch->prev;
fight.c:		ch->name );
fight.c:	    ch->prev = NULL;
fight.c:	if ( !ch->in_room || !ch->name )
fight.c:	    sprintf( buf, "ch: %ld  ch->in_room: %ld  ch->prev: %ld  ch->next: %ld",
fight.c:	    	(long) ch, (long) ch->in_room, (long) ch->prev, (long) ch->next );
fight.c:	      sprintf( buf, "lst_ch: %ld  lst_ch->prev: %ld  lst_ch->next: %ld",
fight.c:	      		(long) lst_ch, (long) lst_ch->prev, (long) lst_ch->next );
fight.c:	if ( ch->fighting )
fight.c:	  if ( (++ch->fighting->duration % 24) == 0 )
fight.c:	    ch->fighting->xp = ((ch->fighting->xp * 9) / 10);
fight.c:	for ( timer = ch->first_timer; timer; timer = timer_next )
fight.c:		    tempsub = ch->substate;
fight.c:		    ch->substate = timer->value;
fight.c:		    ch->substate = tempsub;
fight.c:	for ( paf = ch->first_affect; paf; paf = paf_next )
fight.c:	            bug(ch->name, 0);
fight.c:	            ch->desc->character       = ch->desc->original;
fight.c:    	            ch->desc->original        = NULL;
fight.c:    		    ch->desc->character->desc = ch->desc;
fight.c:   	            ch->desc->character->switched = NULL;
fight.c:   	            ch->switched = NULL;
fight.c:    		    ch->desc                  = NULL;
fight.c:	if ( IS_SET(ch->in_room->room_flags, ROOM_SAFE ) )
fight.c:	   	ch->name, victim->name );
fight.c:	if ( IS_AWAKE(ch) && ch->in_room == victim->in_room )
fight.c:	     ch->pcdata->lost_attacks = 0;
fight.c:	for ( rch = ch->in_room->first_person; rch; rch = rch_next )
fight.c:	    rch_next = rch->next_in_room;
fight.c:	    if ( IS_AWAKE(rch) && !rch->fighting )
fight.c:		&&  !IS_SET(rch->act, ACT_NOASSIST) )
fight.c:		    if ( rch->pIndexData == ch->pIndexData
fight.c:			number = 0;			for ( vch = ch->in_room->first_person; vch; vch = vch->next )
fight.c:    if ( !IS_NPC(ch) && IS_SET( ch->act, PLR_NICE ) && !IS_NPC( victim ) )
fight.c:    chance = IS_NPC(ch) ? 100 : (ch->pcdata->learned[gsn_berserk]*5/2);
fight.c:      dual_bonus = IS_NPC(ch) ? (ch->skill_level[COMBAT_ABILITY] / 10) : (ch->pcdata->learned[gsn_dual_wield] / 10);
fight.c:      chance = IS_NPC(ch) ? ch->top_level : ch->pcdata->learned[gsn_dual_wield];
fight.c:        REMOVE_BIT   ( ch->affected_by, AFF_SNEAK );
fight.c:    if ( ch->move < 10 )
fight.c:    if ( IS_NPC(ch) && ch->numattacks > 0 )
fight.c:	for ( chance = 0; chance <= (ch->numattacks); chance++ )
fight.c:    chance = IS_NPC(ch) ? ch->top_level
fight.c:	   : (int) ((ch->pcdata->learned[gsn_second_attack]+dual_bonus)/1.5);
fight.c:    chance = IS_NPC(ch) ? ch->top_level
fight.c:	   : (int) ((ch->pcdata->learned[gsn_third_attack]+(dual_bonus*1.5))/2);
fight.c:    chance = IS_NPC(ch) ? (int) (ch->top_level / 4) : 0;
fight.c:	  move = encumbrance( ch, movement_loss[UMIN(SECT_MAX-1, ch->in_room->sector_type)] );
fight.c:	if ( ch->move )
fight.c:	  ch->move = UMAX( 0, ch->move - move );
fight.c:	  bonus = (int) ( ch->pcdata->learned[*gsn_ptr] );
fight.c:	lvl = UMAX( 1, (ch->skill_level[FORCE_ABILITY])  );
fight.c:	lvl = ch->top_level;
fight.c:      if(ch->pcdata->lost_attacks < 0)
fight.c:          ch->pcdata->lost_attacks = 0;
fight.c:      if(ch->pcdata->lost_attacks != 0)
fight.c:          ch->pcdata->lost_attacks--;
fight.c:    if ( victim->position == POS_DEAD || ch->in_room != victim->in_room )
fight.c:    if ( ch->fighting		/* make sure fight is already started */
fight.c:    &&   ch->attacks != 0 )
fight.c:	   if ( IS_SET( ch->attacks, attacktype ) )
fight.c:    thac0     = interpolate( ch->skill_level[COMBAT_ABILITY] , thac0_00, thac0_32 ) - GET_HITROLL(ch);
fight.c:    if ( ch->race == RACE_DEFEL )
fight.c:	dam = number_range( ch->barenumdie, ch->baresizedie * ch->barenumdie ) + ch->damplus;
fight.c:    if ( !IS_NPC(ch) && ch->pcdata->learned[gsn_enhanced_damage] > 0 )
fight.c:	dam += (int) (dam * ch->pcdata->learned[gsn_enhanced_damage] / 120);
fight.c:	dam *= (2 + URANGE( 2, ch->skill_level[HUNTING_ABILITY] - (victim->skill_level[COMBAT_ABILITY]/4), 30 ) / 8);
fight.c: 	dam *= (2 + URANGE( 2, ch->skill_level[HUNTING_ABILITY] - (victim->skill_level[COMBAT_ABILITY]/4), 30 ) / 16); 
fight.c:	if(ch->force_type == FORCE_JEDI && wield && wield->value[3] == WEAPON_DUAL_LIGHTSABER)
fight.c:            chance = ris_save( victim, ch->skill_level[COMBAT_ABILITY], RIS_PARALYSIS );
fight.c:   if ( IS_SET(ch->immune, ris ) )
fight.c:   if ( IS_SET(ch->resistant, ris ) )
fight.c:   if ( IS_SET(ch->susceptible, ris ) )
fight.c:		victim->hunting->name = QUICKLINK( ch->name );
fight.c:	   victim->hating->name = QUICKLINK( ch->name );
fight.c:	    if ( !ch->fighting )
fight.c:	    &&   victim->master->in_room == ch->in_room
fight.c:	if ( IS_AFFECTED(ch, AFF_INVISIBLE) && ch->race != RACE_DEFEL )
fight.c:	    REMOVE_BIT( ch->affected_by, AFF_INVISIBLE );
fight.c:	     REMOVE_BIT(ch->affected_by, AFF_HIDE);
fight.c:	    &&   IS_SET( ch->attacks, DFND_DISARM )
fight.c:	    &&   number_percent( ) < ch->skill_level[COMBAT_ABILITY] / 2 )
fight.c:	    &&   IS_SET( ch->attacks, ATCK_TRIP )
fight.c:	    &&   number_percent( ) < ch->skill_level[COMBAT_ABILITY] )
fight.c:	      if(!IS_NPC(ch) && ch->pcdata->learned[gsn_reflect] && (ch->pcdata->learned[gsn_reflect]/2) > number_percent())
fight.c:		   ch->hit -= wield->value[1];
fight.c:    && !saves_poison_death( ch->skill_level[COMBAT_ABILITY], victim ) )
fight.c:    if (dam > 10 && dt != TYPE_UNDEFINED && !IS_SET( ch->in_room->room_flags2, ROOM_ARENA))
fight.c:    &&  !IS_NPC(ch) && ch->fighting && ch->fighting->xp )
fight.c:		(IS_NPC(ch) ? ch->short_descr : ch->name),
fight.c:             for( gch = ch->in_room->first_person; gch; gch = gch->next_in_room )
fight.c:       && new_corpse->in_room == ch->in_room && can_see_obj( ch, new_corpse ) && ch->position > POS_SLEEPING )
fight.c:         if( IS_SET( ch->act, PLR_AUTOGOLD ) && !loot_coins_from_corpse( ch, new_corpse ) )
fight.c:         if( new_corpse && !obj_extracted(new_corpse) && new_corpse->in_room == ch->in_room
fight.c:          && ch->position > POS_SLEEPING && can_see_obj( ch, new_corpse ) )
fight.c:            if( IS_SET( ch->act, PLR_AUTOLOOT ) )
fight.c:            if( !char_died(ch) && IS_SET( ch->act, PLR_AUTOSAC ) && !obj_extracted(new_corpse)
fight.c:             && new_corpse->in_room == ch->in_room && ch->position > POS_SLEEPING
fight.c:  if ( IS_NPC(ch) && !ch->master )
fight.c:    if ( IS_SET(ch->affected_by, AFF_CHARM) )
fight.c:	if ( !ch->master )
fight.c:		IS_NPC(ch) ? ch->short_descr : ch->name );
fight.c:	    REMOVE_BIT( ch->affected_by, AFF_CHARM );
fight.c:	if ( ch->master )
fight.c:	  check_killer( ch->master, victim );
fight.c:	         SET_BIT(ch->pcdata->wanted_flags, 1 << x );
fight.c:	  if ( ch->pcdata->clan )
fight.c:	    ch->pcdata->clan->mkills++;
fight.c:	  ch->pcdata->mkills++;
fight.c:	  if (ch->in_room->area)
fight.c:	    ch->in_room->area->mkills++;
fight.c:	if ( ch->pcdata->clan ) ch->pcdata->clan->pkills++;
fight.c:	  ch->pcdata->pkills++;
fight.c:    if ( ch->fighting )
fight.c:		ch->name, victim->name, ch->fighting->who->name );
fight.c:    ch->num_fighting = 1;
fight.c:    ch->fighting = fight;
fight.c:    ch->position = POS_FIGHTING;
fight.c:    if ( !ch->fighting )
fight.c:    return ch->fighting->who;
fight.c:   if ( ch->fighting )
fight.c:     if ( !char_died(ch->fighting->who) )
fight.c:       --ch->fighting->who->num_fighting;
fight.c:     DISPOSE( ch->fighting );
fight.c:   ch->fighting = NULL;
fight.c:   if ( ch->mount )
fight.c:     ch->position = POS_MOUNTED;
fight.c:     ch->position = POS_STANDING;
fight.c:    for ( fch = first_char; fch; fch = fch->next )
fight.c:      for( contract = ch->first_contract; contract; contract = contract->next_in_contract )
fight.c:         ch->gold += scontract->amount;
fight.c:         kexp = ( exp_level( ch->skill_level[ASSASSIN_ABILITY] + 1 ) - exp_level( ch->skill_level[ASSASSIN_ABILITY] ) );
fight.c:         UNLINK( scontract, ch->first_contract, ch->last_contract, next_in_contract, prev_in_contract );
fight.c:      corpse_to_return = make_corpse( victim, IS_NPC( ch ) ? ch->short_descr : ch->name );
fight.c:    for ( gch = ch->in_room->first_person; gch; gch = gch->next_in_room )
fight.c:    lch = ch->leader ? ch->leader : ch;
fight.c:    for ( gch = ch->in_room->first_person; gch; gch = gch_next )
fight.c:        gch_next = gch->next_in_room;
fight.c:	gch->alignment = align_compute( gch, victim );
fight.c:	if ( !IS_NPC(gch) && IS_NPC(victim) && gch->pcdata && gch->pcdata->clan
fight.c:	&& !str_cmp ( gch->pcdata->clan->name , victim->mob_clan ) )
fight.c:           xp = URANGE( members, xp*members, (exp_level( gch->skill_level[POLITICIAN_ABILITY]+1) - exp_level(gch->skill_level[POLITICIAN_ABILITY] )/10) );  
fight.c:	for ( obj = gch->first_carrying; obj; obj = obj_next )
fight.c:		obj = obj_to_room( obj, gch->in_room );
fight.c:    align = gch->alignment - victim->alignment;
fight.c:	newalign  = UMIN( gch->alignment + (align-500)/4,  1000 );
fight.c:	newalign  = UMAX( gch->alignment + (align+500)/4, -1000 );
fight.c:	newalign  = gch->alignment - (int) (gch->alignment / 4);
fight.c:      if(IS_SET( gch->in_room->room_flags2, ROOM_ARENA ))
fight.c:                     (int) ( gch->alignment - victim->alignment/5 ),
fight.c:    	  *  URANGE( 1, (victim->skill_level[COMBAT_ABILITY] - gch->skill_level[COMBAT_ABILITY]) + 10, 20 )) / 10;
fight.c:    align = gch->alignment - victim->alignment;
fight.c:    if ( gch->alignment > 300 && align < 250 )
fight.c:    return URANGE(1, xp, ( exp_level(  gch->skill_level[COMBAT_ABILITY]+1 ) - exp_level( gch->skill_level[COMBAT_ABILITY]) )   );
fight.c://    if ( dam == 0 && (!IS_NPC(ch) && (IS_SET(ch->pcdata->flags, PCFLAG_GAG))))
fight.c:         sound_to_room(ch->in_room, sound);
fight.c:    if ( ch->skill_level[COMBAT_ABILITY] >= 15 )
fight.c:    if ( IS_AFFECTED(ch, AFF_CHARM) && ch->master == victim )
fight.c:    if ( ch->position == POS_FIGHTING )
fight.c:      ch->pcdata->lost_attacks = 0;
fight.c:       ch->alignment -= 10;
fight.c:      if ( ch->master == victim )
fight.c:    if ( ch->position == POS_FIGHTING )
fight.c:      ch->pcdata->lost_attacks = 0;
fight.c:    if ( !IS_NPC( victim ) && IS_SET( ch->act, PLR_NICE ) )
fight.c:    if (!IS_NPC(ch) && IS_SET(ch->pcdata->act2, ACT_BOUND))
fight.c:    ch->alignment = URANGE( -1000, ch->alignment - 10, 1000 );
fight.c:    if((!ch->in_room->area || !in_arena(ch)) || !IS_NPC(ch) || !IS_NPC(victim))
fight.c:      sprintf( logbuf, "%s: murder %s", ch->name, argument);
fight.c:if ( !str_cmp( ch->in_room->area->filename, "arena.are" ) )
fight.c:if ( ch->in_room->vnum < 29 || ch->in_room->vnum > 43 )
fight.c:	if ( ch->position == POS_FIGHTING )
fight.c:	  if ( ch->mount )
fight.c:	    ch->position = POS_MOUNTED;
fight.c:	    ch->position = POS_STANDING;
fight.c:    if ( ch->move <= 0 )
fight.c:    if ( IS_NPC(ch) && IS_SET(ch->act, ACT_NOFLEE) && !IS_AFFECTED(ch,AFF_CHARM))
fight.c:    if (!IS_NPC(ch) && IS_SET(ch->pcdata->act2, ACT_BOUND))
fight.c:    if ( ch->position < POS_FIGHTING )
fight.c:    was_in = ch->in_room;
fight.c:        REMOVE_BIT   ( ch->affected_by, AFF_SNEAK );
fight.c:	if ( ch->mount && ch->mount->fighting )
fight.c:	    stop_fighting( ch->mount, TRUE );
fight.c:	if ( ( now_in = ch->in_room ) == was_in )
fight.c:	ch->in_room = was_in;
fight.c:	ch->in_room = now_in;
fight.c:    if ( ch->position < POS_FIGHTING )
fight.c:    if ( IS_NPC(ch) && IS_SET(ch->act, ACT_NOFLEE) && !IS_AFFECTED(ch,AFF_CHARM))
fight.c:    was_in = ch->in_room;
fight.c:        REMOVE_BIT   ( ch->affected_by, AFF_SNEAK );
fight.c:	if ( ch->mount && ch->mount->fighting )
fight.c:	    stop_fighting( ch->mount, TRUE );
fight.c:	if ( ( now_in = ch->in_room ) == was_in )
fight.c:	ch->in_room = was_in;
fight.c:	ch->in_room = now_in;
fight.c:	if ( ch->position == POS_FIGHTING )
fight.c:	  if ( ch->mount )
fight.c:	    ch->position = POS_MOUNTED;
fight.c:	    ch->position = POS_STANDING;
fight.c:    if ( ch->move <= 0 )
fight.c:    if ( IS_NPC(ch) && IS_SET(ch->act, ACT_NOFLEE) && !IS_AFFECTED(ch,AFF_CHARM))
fight.c:    if ( ch->position < POS_FIGHTING )
fight.c:    if (!IS_NPC(ch) && IS_SET(ch->pcdata->act2, ACT_BOUND))
fight.c:    chance = IS_NPC(ch) ? ch->top_level : (int)ch->pcdata->learned[gsn_retreat];
fight.c:    xit = get_exit( ch->in_room, edir );
fight.c:    was_in = ch->in_room;
fight.c:    if ( ( pexit = get_exit( ch->in_room, edir ) ) == NULL || !pexit->to_room)
fight.c:    REMOVE_BIT   ( ch->affected_by, AFF_SNEAK );
fight.c:    if ( ch->mount && ch->mount->fighting )
fight.c:      stop_fighting( ch->mount, TRUE );
fight.c:    if ( ( now_in = ch->in_room ) == was_in )
fight.c:    ch->in_room = was_in;
fight.c:    ch->in_room = now_in;
force.c:         if(ch->in_room != dch->in_room)
force.c:    if(!victim || (loc == FORCE_INROOM && victim->in_room != ch->in_room))
force.c:    if(ch->sex == SEX_MALE)
force.c:    else if(ch->sex == SEX_FEMALE)
force.c:    if(ch->sex == SEX_MALE)
force.c:    else if(ch->sex == SEX_FEMALE)
force.c:    if(ch->sex == SEX_MALE)
force.c:    else if(ch->sex == SEX_FEMALE)
force.c:    switch(ch->force_level_status)
force.c:            if(ch->force_type == FORCE_JEDI)
force.c:            else if(ch->force_type == FORCE_SITH)
force.c:            if(ch->force_type == FORCE_JEDI)
force.c:            else if(ch->force_type == FORCE_SITH)
force.c:            if(ch->force_type == FORCE_JEDI)
force.c:            else if(ch->force_type == FORCE_SITH)
force.c:      strncpy( msg, strrep( msg, "$n", ch->name ), MAX_STRING_LENGTH ); 
force.c:      if( ch->force_type == FORCE_JEDI ) 
force.c:      else if( ch->force_type == FORCE_SITH ) 
force.c:    if(fskill->mastertrain && ch->force_level_status != FORCE_MASTER)
force.c:    	if(ch->fighting && IS_NPC(ch->fighting->who))
force.c:       	    if(ch->force_master && ch->force_master[0] != '\0')
force.c:       	      if(ch->fighting->who->name && ch->fighting->who->name[0] != '\0')
force.c:       	        if(!strcmp(ch->fighting->who->name,ch->force_master))
force.c:        total+= ch->force_control;
force.c:        total+= ch->force_sense;
force.c:        total+= ch->force_alter;
force.c:    ch->force_skill[fskill->index] += amt;
force.c:    if(ch->force_skill[fskill->index] > 100)
force.c:        ch->force_skill[fskill->index] = 100;
force.c:    if(fskill->mastertrain && ch->force_level_status != FORCE_MASTER)
force.c:    	if(ch->fighting && IS_NPC(ch->fighting->who))
force.c:       	    if(ch->force_master && ch->force_master[0] != '\0')
force.c:       	      if(ch->fighting->who->name && ch->fighting->who->name[0] != '\0')
force.c:       	        if(!strcmp(ch->fighting->who->name,ch->force_master))
force.c:        total+= ch->force_control;
force.c:        total+= ch->force_sense;
force.c:        total+= ch->force_alter;
force.c:    ch->force_skill[fskill->index] += amt;
force.c:    if(ch->force_skill[fskill->index] > 100)
force.c:        ch->force_skill[fskill->index] = 100;
force.c:    if(ch->force_identified != 1)
force.c:    if(ch->force_level_status < fskill->status && !ch->force_converted)
force.c:    if(ch->force_converted && fskill->type == ch->force_type && ch->force_level_status < fskill->status)
force.c:    if(ch->force_skill[fskill->index] == 0  && fskill->notskill == 0)
force.c:        if(skill_type == FORCE_COMBAT && ch->fighting == NULL && str_cmp(fskill->name, "slash"))
force.c:        if(skill_type == FORCE_NONCOMBAT && ch->fighting != NULL)
force.c:    if(ch->substate == 1 || ch->substate == SUB_TIMER_DO_ABORT)
force.c:    if(fskill->wait_state > 0 && ch->wait_state != 0)
force.c:    if(fskill->cost != 0 && ch->mana < fskill->cost)
force.c:        ch->mana-=fskill->cost; }
force.c:        ch->wait_state = fskill->wait_state;
force.c:    if(ch->force_type == FORCE_JEDI && fskill->type == FORCE_SITH)
force.c:    	ch->force_align -= number_range(1,5);
force.c:    if(ch->force_type == FORCE_SITH && fskill->type == FORCE_JEDI)
force.c:    	ch->force_align += number_range(1,5);
force.c:    if(ch->force_align > MAX_FORCE_ALIGN)
force.c:        ch->force_align = MAX_FORCE_ALIGN;
force.c:    if(ch->force_align < MIN_FORCE_ALIGN)
force.c:        ch->force_align = MIN_FORCE_ALIGN;
force.c:         if(ch->force_identified != 1 || !ch->force_level_status)
force.c:         if(ch->force_disguise_count > 0)
force.c:             ch->force_disguise_count--;
force.c:         if(ch->force_type == FORCE_JEDI && ch->alignment < 0)
force.c:             ch->force_align-=change;
force.c:         else if(ch->force_type == FORCE_JEDI)
force.c:             ch->force_align+=change;
force.c:         if(ch->force_type == FORCE_SITH && ch->alignment > 0)
force.c:             ch->force_align+=change;
force.c:         else if(ch->force_type == FORCE_SITH)
force.c:             ch->force_align-=change;
force.c:         if(ch->force_align > MAX_FORCE_ALIGN)
force.c:             ch->force_align = MAX_FORCE_ALIGN;
force.c:         if(ch->force_align < MIN_FORCE_ALIGN)
force.c:             ch->force_align = MIN_FORCE_ALIGN;
force.c:              if(fskill->type != FORCE_GENERAL && fskill->type != ch->force_type && ch->force_skill[fskill->index] > 0)
force.c:                      ch->force_skill[fskill->index] -= change;
force.c:                      if(ch->force_skill[fskill->index] < 0)
force.c:                          ch->force_skill[fskill->index] = 0;
force.c:              if(fskill->type == FORCE_JEDI && ch->force_type == FORCE_JEDI && ch->force_align < 0 && ch->force_skill[fskill->index] > 0)
force.c:                      ch->force_skill[fskill->index] -= change;
force.c:                      if(ch->force_skill[fskill->index] < 0)
force.c:                          ch->force_skill[fskill->index] = 0;
force.c:              if(fskill->type == FORCE_SITH && ch->force_type == FORCE_SITH && ch->force_align > 0 && ch->force_skill[fskill->index] > 0)
force.c:                      ch->force_skill[fskill->index] -= change;
force.c:                      if(ch->force_skill[fskill->index] < 0)
force.c:                          ch->force_skill[fskill->index] = 0;
force.c:        if(fskill->status == ch->force_level_status)
force.c:            total+=ch->force_skill[fskill->index];
force.c:        if(ch->force_type == FORCE_JEDI)
force.c:        else if(ch->force_type == FORCE_SITH)
force.c:        if(ch->force_type == FORCE_JEDI)
force.c:        else if(ch->force_type == FORCE_SITH)
force.c:    if ( !ch->desc )
force.c:  	    ch->substate = SUB_FORCE_CH0;
force.c:	    ch->dest_buf = ch;
force.c:	    ch->spare_ptr = fskill;
force.c:  	    ch->substate = SUB_FORCE_CH1;
force.c:	    ch->dest_buf = ch;
force.c:	    ch->spare_ptr = fskill;
force.c:  	    ch->substate = SUB_FORCE_CH2;
force.c:	    ch->dest_buf = ch;
force.c:	    ch->spare_ptr = fskill;
force.c:  	    ch->substate = SUB_FORCE_CH3;
force.c:	    ch->dest_buf = ch;
force.c:	    ch->spare_ptr = fskill;
force.c:  	    ch->substate = SUB_FORCE_CH4;
force.c:	    ch->dest_buf = ch;
force.c:	    ch->spare_ptr = fskill;
force.c:  	    ch->substate = SUB_FORCE_ROOM0;
force.c:	    ch->dest_buf = ch;
force.c:	    ch->spare_ptr = fskill;
force.c:  	    ch->substate = SUB_FORCE_ROOM1;
force.c:	    ch->dest_buf = ch;
force.c:	    ch->spare_ptr = fskill;
force.c:  	    ch->substate = SUB_FORCE_ROOM2;
force.c:	    ch->dest_buf = ch;
force.c:	    ch->spare_ptr = fskill;
force.c:  	    ch->substate = SUB_FORCE_ROOM3;
force.c:	    ch->dest_buf = ch;
force.c:	    ch->spare_ptr = fskill;
force.c:  	    ch->substate = SUB_FORCE_ROOM4;
force.c:	    ch->dest_buf = ch;
force.c:	    ch->spare_ptr = fskill;
force.c:  	    ch->substate = SUB_FORCE_VICTIM0;
force.c:	    ch->dest_buf = ch;
force.c:	    ch->spare_ptr = fskill;
force.c:  	    ch->substate = SUB_FORCE_VICTIM1;
force.c:	    ch->dest_buf = ch;
force.c:	    ch->spare_ptr = fskill;
force.c:  	    ch->substate = SUB_FORCE_VICTIM2;
force.c:	    ch->dest_buf = ch;
force.c:	    ch->spare_ptr = fskill;
force.c:  	    ch->substate = SUB_FORCE_VICTIM3;
force.c:	    ch->dest_buf = ch;
force.c:	    ch->spare_ptr = fskill;
force.c:  	    ch->substate = SUB_FORCE_VICTIM4;
force.c:	    ch->dest_buf = ch;
force.c:	    ch->spare_ptr = fskill;
force.c:    switch( ch->substate )
force.c:	   fskill = ch->spare_ptr;
force.c:	   fskill = ch->spare_ptr;
force.c:	   fskill = ch->spare_ptr;
force.c:	   fskill = ch->spare_ptr;
force.c:	   fskill = ch->spare_ptr;
force.c:	   fskill = ch->spare_ptr;
force.c:	   fskill = ch->spare_ptr;
force.c:	   fskill = ch->spare_ptr;
force.c:	   fskill = ch->spare_ptr;
force.c:	   fskill = ch->spare_ptr;
force.c:	   fskill = ch->spare_ptr;
force.c:	   fskill = ch->spare_ptr;
force.c:	   fskill = ch->spare_ptr;
force.c:	   fskill = ch->spare_ptr;
force.c:	   fskill = ch->spare_ptr;
force.c:    if ( !ch->desc )
force.c:  	    ch->substate = SUB_FORCE_HELP;
force.c:	    ch->dest_buf = ch;
force.c:	    ch->spare_ptr = fhelp;
force.c:    switch( ch->substate )
force.c:	   fhelp = ch->spare_ptr;
fskills.c:    switch(ch->substate)
fskills.c:        if(number_range(0,4) != 0 && number_range(0,100) > ch->force_skill[FORCE_SKILL_REFRESH])
fskills.c:            ch->substate = SUB_NONE;
fskills.c:        ch->mana+=number_range(10,ch->force_control*40/100)*ch->force_level_status;
fskills.c:        if(ch->mana > ch->max_mana)
fskills.c:            ch->mana = ch->max_mana;
fskills.c:    ch->substate = SUB_NONE;
fskills.c:    switch(ch->substate)
fskills.c:        if(number_range(0,4) != 0 && number_range(0,100) > ch->force_skill[FORCE_SKILL_AWARENESS])
fskills.c:            ch->substate = SUB_NONE;
fskills.c:		af.duration  = 112*ch->force_level_status;
fskills.c:    	 ch->mana-=fskill->cost;
fskills.c:    ch->substate = SUB_NONE;
fskills.c:    if(number_range(0,4) != 0 && number_range(0,100) > ch->force_skill[FORCE_SKILL_FINFO])
fskills.c:    if(ch->force_type == FORCE_JEDI)
fskills.c:    if(ch->force_type == FORCE_SITH)
fskills.c:		ch->force_type == FORCE_JEDI ? "&B" : "&R", ch->mana,
fskills.c:		ch->force_type == FORCE_JEDI ? "&b" : "&r",
fskills.c:		ch->force_type == FORCE_JEDI ? "&B" : "&R", ch->max_mana);
fskills.c:		ch->force_type == FORCE_JEDI ? "&b" : "&r", 
fskills.c:		ch->force_type == FORCE_JEDI ? force_parse_string(ch,NULL,"&B$nfl") : force_parse_string(ch, NULL, "&R$nfl"));
fskills.c:    if(ch->force_type == FORCE_JEDI)
fskills.c:     	if(ch->force_skill[skill->index] == 0 ||  skill->notskill == 1)
fskills.c:    	if(ch->force_converted)
fskills.c:    	    if(fskill->status > ch->force_level_status && fskill->type == ch->force_type)
fskills.c:    	else if(fskill->status > ch->force_level_status)
fskills.c:			skill->type == FORCE_SITH ? "&R" : "&w", ch->force_skill[skill->index],
fskills.c:	if(ch->force_level_status >= 2)
fskills.c:    if(ch->force_type == FORCE_JEDI)
fskills.c:     	if(ch->force_skill[skill->index] == 0 ||  skill->notskill == 1)
fskills.c:    	if(ch->force_converted)
fskills.c:    	    if(fskill->status > ch->force_level_status && fskill->type == ch->force_type)
fskills.c:    	else if(fskill->status > ch->force_level_status)
fskills.c:			skill->type == FORCE_SITH ? "&R" : "&w", ch->force_skill[skill->index],
fskills.c:	if(ch->force_level_status >= 3)
fskills.c:    if(ch->force_type == FORCE_JEDI)
fskills.c:     	if(ch->force_skill[skill->index] == 0 ||  skill->notskill == 1)
fskills.c:    	if(ch->force_converted)
fskills.c:    	    if(fskill->status > ch->force_level_status && fskill->type == ch->force_type)
fskills.c:    	else if(fskill->status > ch->force_level_status)
fskills.c:			skill->type == FORCE_SITH ? "&R" : "&w", ch->force_skill[skill->index],
fskills.c:    if(victim->force_type != FORCE_GENERAL && victim->force_type != ch->force_type)
fskills.c:    victim->force_temp_master = STRALLOC( ch->name );
fskills.c:    if(strcmp(ch->force_temp_master,victim->name))
fskills.c:    STRFREE( ch->force_master );
fskills.c:    ch->force_master = STRALLOC( ch->force_temp_master );
fskills.c:    if(ch->force_level_status < FORCE_APPRENTICE)
fskills.c:        ch->force_level_status = FORCE_APPRENTICE;
fskills.c:    if(victim->force_type != ch->force_type && ch->force_type != FORCE_GENERAL)
fskills.c:    	ch->force_converted = 1;
fskills.c:    	ch->force_level_status = FORCE_APPRENTICE;
fskills.c:    ch->force_type = victim->force_type;
fskills.c:    ch->max_mana = (ch->force_control + ch->force_sense + ch->force_alter) * 3 * ch->force_level_status;
fskills.c:    ch->mana = ch->max_mana;
fskills.c:        argument = str_dup(ch->dest_buf);
fskills.c:    switch(ch->substate)
fskills.c:        ch->dest_buf = str_dup(argument);
fskills.c:        if(number_range(0,4) != 0 && number_range(0,100) > ch->force_skill[FORCE_SKILL_IDENTIFY])
fskills.c:            ch->substate = SUB_NONE;
fskills.c:    	if ( !ch->dest_buf )
fskills.c:    	DISPOSE( ch->dest_buf );
fskills.c:    ch->substate = SUB_NONE;
fskills.c:    if(strcmp(victim->force_master,ch->name))
fskills.c:    victim->mana = ch->max_mana;
fskills.c:        if(skill->status <= ch->force_level_status && !strcmp(argument,skill->name) && (skill->type == FORCE_GENERAL || skill->type == ch->force_type) && skill->notskill == 0)
fskills.c:    if(ch->force_skill[skill->index] < 1)
fskills.c:    if(skill->type != ch->force_type && skill->type != FORCE_GENERAL)
fskills.c:    if(victim->force_type != ch->force_type && skill->type != FORCE_GENERAL)
fskills.c:    if(ch->force_type == FORCE_SITH && victim->force_master != ch->name)
fskills.c:    switch(ch->substate)
fskills.c:        if(number_range(0,4) != 0 && number_range(0,100) > ch->force_skill[FORCE_SKILL_HEAL])
fskills.c:            ch->substate = SUB_NONE;
fskills.c:        ch->hit+=number_range(1,ch->force_control*500/100);
fskills.c:        if(ch->hit > ch->max_hit)
fskills.c:            ch->hit = ch->max_hit;
fskills.c:    ch->substate = SUB_NONE;
fskills.c:        argument = str_dup(ch->dest_buf);
fskills.c:    switch(ch->substate)
fskills.c:        ch->dest_buf = str_dup(argument);
fskills.c:        if(number_range(0,4) != 0 && number_range(0,100) > ch->force_skill[FORCE_SKILL_PROTECT])
fskills.c:            victim->hit-=ch->force_alter*25/100;
fskills.c:            ch->substate = SUB_NONE;
fskills.c:	af.duration  = ch->force_alter*50/100;
fskills.c:    	if ( !ch->dest_buf )
fskills.c:    	DISPOSE( ch->dest_buf );
fskills.c:        victim->hit-=ch->force_alter*25/100;
fskills.c:   	DISPOSE( ch->dest_buf );
fskills.c:    ch->substate = SUB_NONE;
fskills.c:        argument = str_dup(ch->dest_buf);
fskills.c:    switch(ch->substate)
fskills.c:        ch->dest_buf = str_dup(argument);
fskills.c:        if(number_range(0,4) != 0 && number_range(0,100) > ch->force_skill[FORCE_SKILL_SHIELD])
fskills.c:            victim->hit-=ch->force_alter*25/100;
fskills.c:            ch->substate = SUB_NONE;
fskills.c:	af.duration  = ch->force_alter*50/100*2;
fskills.c:    	if ( !ch->dest_buf )
fskills.c:    	DISPOSE( ch->dest_buf );
fskills.c:        victim->hit-=ch->force_alter*25/100;
fskills.c:   	DISPOSE( ch->dest_buf );
fskills.c:    ch->substate = SUB_NONE;
fskills.c:    if(number_range(0,4) != 0 && number_range(0,125) > URANGE(1,ch->force_skill[FORCE_SKILL_STRIKE],75))
fskills.c:    dam = URANGE(40,number_range(0,ch->force_skill[FORCE_SKILL_STRIKE] * ch->force_control / (20 * (4-ch->force_level_status))),100);
fskills.c:   if(!ch->fighting)
fskills.c:        if ( IS_SET( ch->in_room->room_flags, ROOM_SAFE ) ) 
fskills.c:    if(number_range(0,4) != 0 && number_range(0,100) > URANGE(1,ch->force_skill[FORCE_SKILL_STRIKE],75))
fskills.c:    dam = URANGE(40,number_range(0,ch->force_skill[FORCE_SKILL_STRIKE] * ch->force_control / (20 * (4-ch->force_level_status))),100);
fskills.c:    victim = ch->fighting->who;
fskills.c:    if(number_range(0,4) != 0 && number_range(0,100) > URANGE(1,ch->force_skill[FORCE_SKILL_STRIKE],75))
fskills.c:    dam = URANGE(40,number_range(0,ch->force_skill[FORCE_SKILL_STRIKE] * ch->force_control / (20 * (4-ch->force_level_status))),100);
fskills.c:    victim = ch->fighting->who;
fskills.c:    if(number_range(0,4) != 0 && number_range(0,100) > URANGE(1,ch->force_skill[FORCE_SKILL_WHIRLWIND],75))
fskills.c:    dam = URANGE(40,number_range(0,ch->force_skill[FORCE_SKILL_WHIRLWIND] * ch->force_control / (20 * (4-ch->force_level_status))),100);
fskills.c:        argument = str_dup(ch->dest_buf);
fskills.c:    	ch->substate = SUB_NONE;
fskills.c:    switch(ch->substate)
fskills.c:        ch->dest_buf = str_dup(argument);
fskills.c:        if(number_range(0,4) != 0 && (number_range(0,100) > ch->force_skill[FORCE_SKILL_SQUEEZE] || number_range(0,100) > ch->force_control))
fskills.c:            ch->hit-=ch->force_alter*25/100;
fskills.c:            ch->substate = SUB_NONE;
fskills.c:	af.duration  = number_range(ch->force_alter*30/100,30);
fskills.c:    	if ( !ch->dest_buf )
fskills.c:    	DISPOSE( ch->dest_buf );
fskills.c:        victim->hit-=ch->force_alter*25/100;
fskills.c:   	DISPOSE( ch->dest_buf );
fskills.c:    ch->substate = SUB_NONE;
fskills.c:        argument = str_dup(ch->dest_buf);
fskills.c:    victim = ch->fighting->who;
fskills.c:    	ch->substate = SUB_NONE;
fskills.c:    victim = ch->fighting->who;
fskills.c:    switch(ch->substate)
fskills.c:        ch->dest_buf = str_dup(argument);
fskills.c:        if(number_range(0,4) != 0 && number_range(0,100) > ch->force_skill[FORCE_SKILL_FORCE_LIGHTNING])
fskills.c:            ch->hit-=((ch->force_alter*40/100)+(ch->force_sense*40/100)+(ch->force_control*40/100));
fskills.c:            ch->substate = SUB_NONE;
fskills.c:        victim->hit-=number_range(50,((ch->force_alter*200/100)+(ch->force_sense*200/100)+(ch->force_control*200/100)));
fskills.c:    	if ( !ch->dest_buf )
fskills.c:    	DISPOSE( ch->dest_buf );
fskills.c:        ch->hit-=((ch->force_alter*40/100)+(ch->force_sense*40/100)+(ch->force_control*40/100));
fskills.c:   	DISPOSE( ch->dest_buf );
fskills.c:    ch->substate = SUB_NONE;
fskills.c:    if(argument[0] == '\0' && !ch->dest_buf)
fskills.c:        argument = str_dup(ch->dest_buf);
fskills.c:        if(!ch->pcdata->disguise)
fskills.c:        STRFREE(ch->pcdata->disguise);
fskills.c:	ch->pcdata->disguise = STRALLOC( "" );
fskills.c:        ch->mana+=fskill->cost;
fskills.c:        ch->substate = SUB_NONE;
fskills.c:    	if ( !ch->dest_buf )
fskills.c:    	DISPOSE( ch->dest_buf );
fskills.c:    switch(ch->substate)
fskills.c:        ch->dest_buf = str_dup(argument);
fskills.c:        if(number_range(0,4) != 0 && number_range(0,100) > ch->force_skill[FORCE_SKILL_DISGUISE])
fskills.c:            ch->substate = SUB_NONE;
fskills.c:       	    DISPOSE( ch->dest_buf );
fskills.c:        ch->pcdata->disguise = STRALLOC( argument );
fskills.c:    	if ( !ch->dest_buf )
fskills.c:    	DISPOSE( ch->dest_buf );
fskills.c:    	DISPOSE( ch->dest_buf );
fskills.c:    ch->substate = SUB_NONE;
fskills.c:/*    if(str_cmp(ch->name,"bambua"))
fskills.c:    switch( ch->substate )
fskills.c:                if ( !IS_SET( ch->in_room->room_flags, ROOM_SAFE ) || !IS_SET( ch->in_room->room_flags, ROOM_SILENCE ))
fskills.c:                for ( obj = ch->last_carrying; obj; obj = obj->prev_content )     
fskills.c:    	        chance = IS_NPC(ch) ? ch->top_level
fskills.c:	                 : (int) (ch->force_skill[FORCE_SKILL_MAKELIGHTSABER]);
fskills.c:    		   ch->dest_buf = str_dup(arg);
fskills.c:    		if ( !ch->dest_buf )
fskills.c:    		strcpy(arg, ch->dest_buf);
fskills.c:    		DISPOSE( ch->dest_buf);
fskills.c:    		DISPOSE( ch->dest_buf );
fskills.c:    		ch->substate = SUB_NONE;    		                                   
fskills.c:    ch->substate = SUB_NONE;
fskills.c:    level = IS_NPC(ch) ? ch->top_level : (int) (ch->force_skill[FORCE_SKILL_MAKELIGHTSABER]);
fskills.c:    for ( obj = ch->last_carrying; obj; obj = obj->prev_content )     
fskills.c:    chance = IS_NPC(ch) ? ch->top_level
fskills.c:                : (int) (ch->force_skill[FORCE_SKILL_MAKELIGHTSABER]) ;
fskills.c:    obj->value[1] = (int) (level/10+gemtype*2)*ch->force_level_status;      /* min dmg  */
fskills.c:    obj->value[2] = (int) (level/5+gemtype*6)*ch->force_level_status;      /* max dmg */
fskills.c:    obj->value[4] = (1000+charge)*ch->force_level_status;
fskills.c:    obj->value[5] = (1000+charge)*ch->force_level_status;
fskills.c://         xpgain = UMIN( obj->cost/6.25 ,( exp_level(ch->skill_level[FORCE_ABILITY]+1) - exp_level(ch->skill_level[ENGINEERING_ABILITY]) ) );
fskills.c:    switch( ch->substate )
fskills.c:                if ( !IS_SET( ch->in_room->room_flags, ROOM_SAFE ) || !IS_SET( ch->in_room->room_flags, ROOM_SILENCE ))
fskills.c:                for ( obj = ch->last_carrying; obj; obj = obj->prev_content )     
fskills.c:    	        chance = IS_NPC(ch) ? ch->top_level
fskills.c:	                 : (int) (ch->force_skill[FORCE_SKILL_MAKEDUALSABER]);
fskills.c:    		   ch->dest_buf = str_dup(arg);
fskills.c:    		if ( !ch->dest_buf )
fskills.c:    		strcpy(arg, ch->dest_buf);
fskills.c:    		DISPOSE( ch->dest_buf);
fskills.c:    		DISPOSE( ch->dest_buf );
fskills.c:    		ch->substate = SUB_NONE;    		                                   
fskills.c:    ch->substate = SUB_NONE;
fskills.c:    level = IS_NPC(ch) ? ch->top_level : (int) (ch->force_skill[FORCE_SKILL_MAKEDUALSABER]);
fskills.c:    for ( obj = ch->last_carrying; obj; obj = obj->prev_content )     
fskills.c:    chance = IS_NPC(ch) ? ch->top_level
fskills.c:                : (int) (ch->force_skill[FORCE_SKILL_MAKEDUALSABER]) ;
fskills.c:    obj->value[1] = (int) (level/10+gemtype*2)*ch->force_level_status;      /* min dmg  */
fskills.c:    obj->value[2] = (int) (level/5+gemtype*6)*ch->force_level_status;      /* max dmg */
fskills.c:    obj->value[4] = (1000+charge)*ch->force_level_status;
fskills.c:    obj->value[5] = (1000+charge)*ch->force_level_status;
fskills.c://         xpgain = UMIN( obj->cost/6.25 ,( exp_level(ch->skill_level[FORCE_ABILITY]+1) - exp_level(ch->skill_level[ENGINEERING_ABILITY]) ) );
fskills.c:    victim = ch->fighting->who;
fskills.c:    	ch->mana += fskill->cost;
fskills.c:    if(number_range(0,4) != 0 && number_range(0,100) > URANGE(1,ch->force_skill[FORCE_SKILL_FINISH],75))
fskills.c:        ch->hit = ch->max_hit;
fskills.c:        ch->mana = ch->max_mana;
fskills.c:        ch->move = ch->max_move; 
fskills.c:      		victim->name, ch->name, ch->in_room->vnum);
fskills.c:        if(fhelp->type != ch->force_type && fhelp->type != FORCE_GENERAL)
fskills.c:        if(fhelp->status > ch->force_level_status)
fskills.c:    if(fhelp->skill != -1 && ch->force_skill[fhelp->skill] == 0)
fskills.c:            ch_printf(victim,"&G&YYou swing your lightsaber in an arc, reflecting %s's blast!&w\r\n",ch->short_descr);
fskills.c:            sprintf(roombuf,"&GY%s swings their lightsaber in an arc, reflecting %s's blast!&w\r\n",victim->name,ch->short_descr);
fskills.c:            ch_printf(victim,"&G&YYou swing your lightsaber in an arc, reflecting %s's blast!&G&w\r\n",ch->name);
fskills.c:            sprintf(roombuf,"&G&Y%s swings their lightsaber in an arc, reflecting %s's blast!&w\r\n",victim->name,ch->name);
fskills.c:           if(!rch->short_descr || rch->short_descr[0] == '\0')
fskills.c:           	bug("Fskill_reflect: Rch has no short %d",rch->pIndexData->vnum);
fskills.c:               ch_printf(victim,"You hit %s with a reflected shot.\r\n",rch->short_descr);
fskills.c:               sprintf(roombuf,"%s hits %s with a reflected shot.\r\n",victim->name,rch->short_descr);
fskills.c:           if(!rch->name || rch->name[0] == '\0')
fskills.c:               ch_printf(victim,"You hit %s with a reflected shot.\r\n",rch->name);
fskills.c:               sprintf(roombuf,"%s hits %s with a reflected shot.\r\n",victim->name,rch->name);
fskills.c:        rch->hit -= number_range(50,URANGE(50,dam/2,200));
fskills.c:        if(rch->hit < 0)
fskills.c:            rch->hit = 0;
fskills.c:        for ( rch = ch->in_room->first_person; rch ; rch = rch->next_in_room )
fskills.c:                    if(!rch->short_descr || rch->short_descr[0] == '\0')
fskills.c:           	        bug("Fskill_reflect: Rch has no short %d",rch->pIndexData->vnum);
fskills.c:                        ch_printf(victim,"You hit %s with a reflected shot.\r\n",rch->short_descr);
fskills.c:                        sprintf(roombuf,"%s hits %s with a reflected shot.\r\n",victim->name,rch->short_descr);
fskills.c:                    if(!rch->name || rch->name[0] == '\0')
fskills.c:                        ch_printf(victim,"You hit %s with a reflected shot.\r\n",rch->name);
fskills.c:                        sprintf(roombuf,"%s hits %s with a reflected shot.\r\n",victim->name,rch->name);
fskills.c:                rch->hit -= number_range(50,URANGE(50,dam/2,200));
fskills.c:                if(rch->hit < 0)
fskills.c:                    rch->hit = 0;
fskills.c:    if(ch->force_type == FORCE_JEDI && victim->force_align < 0)
fskills.c:    if(ch->force_type == FORCE_SITH && victim->force_align > 0)
fskills.c:    victim->force_temp_master = STRALLOC( ch->name );
handler.c:    	        for ( xch = first_char; xch; xch = xch->next )
handler.c:/* && nifty_is_name( obj->armed_by, xch->name ) Temp removed to see what happens*/ 
handler.c:    	                           rnext = rch->next_in_room;
handler.c:      				      if ( IS_SET( rch->act , ACT_SENTINEL ) )
handler.c:         				rch->was_sentinel = rch->in_room;
handler.c:         				REMOVE_BIT( rch->act, ACT_SENTINEL );
handler.c:    return ch->experience[ability];
handler.c:    exp = ch->skill_level[COMBAT_ABILITY] * ch->top_level * 50;
handler.c:    exp += ch->max_hit * 2;
handler.c:    exp -= (ch->armor-50) * 2;
handler.c:    exp += ( ch->barenumdie * ch->baresizedie + GET_DAMROLL(ch) ) * 50;
handler.c:    exp += GET_HITROLL(ch) * ch->top_level * 10;
handler.c:    if ( ch->desc ) 
handler.c:      if ( ch->desc->original )
handler.c:	ch = ch->desc->original;
handler.c:    if ( ch->trust != 0 )
handler.c:	return ch->trust;
handler.c:    if ( IS_NPC(ch) && ch->top_level >= LEVEL_AVATAR )
handler.c:    if ( ch->top_level >= LEVEL_NEOPHYTE && IS_RETIRED( ch ) )
handler.c:    return ch->top_level;
handler.c:    return 17 + ( ch->played + (current_time - ch->logon) ) / 14400;
handler.c:       max  = 20 + race_table[ch->race].str_plus;
handler.c:       return URANGE( 3, ch->perm_str + ch->mod_str, max );
handler.c:    return URANGE( 3, ch->perm_str + ch->mod_str, 25 );
handler.c:    return URANGE( 3, ch->perm_int + ch->mod_int, 25 );
handler.c:    return URANGE( 3, ch->perm_wis + ch->mod_wis, 25 );
handler.c:    return URANGE( 3, ch->perm_dex + ch->mod_dex, 25 );
handler.c:    return URANGE( 3, ch->perm_con + ch->mod_con, 25 );
handler.c:    return URANGE( 3, ch->perm_cha + ch->mod_cha, 25 );
handler.c:    return URANGE( 3, ch->perm_lck + ch->mod_lck, 25 );
handler.c:    max  = 20 + race_table[ch->race].frc_plus;
handler.c:    return URANGE( 0 , ch->perm_frc + ch->mod_frc, max );
handler.c:    if ( IS_NPC(ch) && IS_SET(ch->act, ACT_PET) )
handler.c:    return URANGE(5, (ch->top_level+15)/5 + get_curr_dex(ch)-13 - penalty, 20);
handler.c:    if ( IS_NPC(ch) && IS_SET(ch->act, ACT_PET) )
handler.c:  if ( IS_NPC(ch) && IS_SET(ch->act, ACT_PROTOTYPE) )
handler.c:	SET_BIT( ch->affected_by, paf->bitvector );
handler.c:	REMOVE_BIT( ch->affected_by, paf->bitvector );
handler.c:	  case APPLY_AFFECT:        REMOVE_BIT( ch->affected_by, mod );	return;
handler.c:	  case APPLY_RESISTANT:     REMOVE_BIT( ch->resistant, mod );	return;
handler.c:	  case APPLY_IMMUNE:        REMOVE_BIT( ch->immune, mod );	return;
handler.c:	  case APPLY_SUSCEPTIBLE:   REMOVE_BIT( ch->susceptible, mod );	return;
handler.c:	  case APPLY_REMOVE:	    SET_BIT( ch->affected_by, mod );	return;
handler.c:    case APPLY_STR:           ch->mod_str		+= mod;	break;
handler.c:    case APPLY_DEX:           ch->mod_dex		+= mod;	break;
handler.c:    case APPLY_INT:           ch->mod_int		+= mod;	break;
handler.c:    case APPLY_WIS:           ch->mod_wis		+= mod;	break;
handler.c:    case APPLY_CON:	      ch->mod_con		+= mod;	break;
handler.c:    case APPLY_CHA:	      ch->mod_cha		+= mod; break;
handler.c:    case APPLY_LCK:	      ch->mod_lck		+= mod; break;
handler.c:	ch->sex = (ch->sex+mod) % 3;
handler.c:	if ( ch->sex < 0 )
handler.c:	  ch->sex += 2;
handler.c:	ch->sex = URANGE( 0, ch->sex, 2 );
handler.c:    case APPLY_HEIGHT:	      ch->height		+= mod;	break;
handler.c:    case APPLY_WEIGHT:	      ch->weight		+= mod;	break;
handler.c:    case APPLY_MANA:          ch->max_mana		+= mod;	break;
handler.c:    case APPLY_HIT:           ch->max_hit		+= mod;	break;
handler.c:    case APPLY_MOVE:          ch->max_move		+= mod;	break;
handler.c:    case APPLY_AC:            ch->armor			+= mod;	break;
handler.c:    case APPLY_HITROLL:       ch->hitroll		+= mod;	break;
handler.c:    case APPLY_DAMROLL:       ch->damroll		+= mod;	break;
handler.c:    case APPLY_SAVING_POISON: ch->saving_poison_death	+= mod;	break;
handler.c:    case APPLY_SAVING_ROD:    ch->saving_wand		+= mod;	break;
handler.c:    case APPLY_SAVING_PARA:   ch->saving_para_petri	+= mod;	break;
handler.c:    case APPLY_SAVING_BREATH: ch->saving_breath		+= mod;	break;
handler.c:    case APPLY_SAVING_SPELL:  ch->saving_spell_staff	+= mod;	break;
handler.c:    case APPLY_AFFECT:        SET_BIT( ch->affected_by, mod );	break;
handler.c:    case APPLY_RESISTANT:     SET_BIT( ch->resistant, mod );	break;
handler.c:    case APPLY_IMMUNE:        SET_BIT( ch->immune, mod );	break;
handler.c:    case APPLY_SUSCEPTIBLE:   SET_BIT( ch->susceptible, mod );	break;
handler.c:    case APPLY_REMOVE:	      REMOVE_BIT(ch->affected_by, mod);	break;
handler.c:	    ch->pcdata->condition[COND_FULL] =
handler.c:		URANGE( 0, ch->pcdata->condition[COND_FULL] + mod, 48 );
handler.c:	    ch->pcdata->condition[COND_THIRST] =
handler.c:		URANGE( 0, ch->pcdata->condition[COND_THIRST] + mod, 48 );
handler.c:	    ch->pcdata->condition[COND_DRUNK] =
handler.c:		URANGE( 0, ch->pcdata->condition[COND_DRUNK] + mod, 48 );
handler.c:	ch->mental_state	= URANGE(-100, ch->mental_state + mod, 100);
handler.c:	ch->emotional_state	= URANGE(-100, ch->emotional_state + mod, 100);
handler.c:	if ( IS_SET(ch->in_room->room_flags, ROOM_NO_MAGIC)
handler.c:	||   IS_SET(ch->immune, RIS_MAGIC)
handler.c:	   if ( (retcode=(*skill->spell_fun) ( mod, ch->skill_level[FORCE_ABILITY], ch, ch )) == rCHAR_DIED
handler.c:	if ( !IS_NPC(ch) && ch->pcdata->learned[gsn_track]> 0 )
handler.c:	  ch->pcdata->learned[gsn_track] =
handler.c:		UMAX( 1, ch->pcdata->learned[gsn_track] + mod );
handler.c:	if ( !IS_NPC(ch) && ch->pcdata->learned[gsn_hide]> 0)
handler.c:	  ch->pcdata->learned[gsn_hide] = 
handler.c:		UMAX( 1, ch->pcdata->learned[gsn_hide] + mod );
handler.c:	if ( !IS_NPC(ch) && ch->pcdata->learned[gsn_steal] > 0)
handler.c:	  ch->pcdata->learned[gsn_steal] =
handler.c:		UMAX( 1, ch->pcdata->learned[gsn_steal] + mod );
handler.c:	if ( !IS_NPC(ch) && ch->pcdata->learned[gsn_sneak]> 0)
handler.c:	  ch->pcdata->learned[gsn_sneak] =
handler.c:		UMAX( 1, ch->pcdata->learned[gsn_sneak] + mod );
handler.c:	if ( !IS_NPC(ch) && ch->pcdata->learned[gsn_pick_lock]> 0)
handler.c:	  ch->pcdata->learned[gsn_pick_lock] =
handler.c:		UMAX( 1, ch->pcdata->learned[gsn_pick_lock] + mod );
handler.c:	if ( !IS_NPC(ch) && ch->pcdata->learned[gsn_backstab]> 0)
handler.c:	  ch->pcdata->learned[gsn_backstab] =
handler.c:		UMAX( 1, ch->pcdata->learned[gsn_backstab] + mod );
handler.c:	if ( !IS_NPC(ch) && ch->pcdata->learned[gsn_detrap]> 0)
handler.c:	  ch->pcdata->learned[gsn_detrap] =
handler.c:		UMAX( 1, ch->pcdata->learned[gsn_detrap] + mod );
handler.c:	if ( !IS_NPC(ch) && ch->pcdata->learned[gsn_dodge]> 0)
handler.c:	  ch->pcdata->learned[gsn_dodge] =
handler.c:		UMAX( 1, ch->pcdata->learned[gsn_dodge] + mod );
handler.c:	if ( !IS_NPC(ch) && ch->pcdata->learned[gsn_peek]> 0)
handler.c:	  ch->pcdata->learned[gsn_peek] =
handler.c:		UMAX( 1, ch->pcdata->learned[gsn_peek] + mod );
handler.c:	if ( !IS_NPC(ch) && ch->pcdata->learned[gsn_scan]> 0)
handler.c:	  ch->pcdata->learned[gsn_scan] =
handler.c:		UMAX( 1, ch->pcdata->learned[gsn_scan] + mod );
handler.c:	if ( !IS_NPC(ch) && ch->pcdata->learned[gsn_gouge]> 0)
handler.c:	  ch->pcdata->learned[gsn_gouge] =
handler.c:		UMAX( 1, ch->pcdata->learned[gsn_gouge] + mod );
handler.c:	if ( !IS_NPC(ch) && ch->pcdata->learned[gsn_search]> 0)
handler.c:	  ch->pcdata->learned[gsn_search] =
handler.c:		UMAX( 1, ch->pcdata->learned[gsn_search] + mod );
handler.c:	if ( !IS_NPC(ch) && ch->pcdata->learned[gsn_dig]> 0)
handler.c:	  ch->pcdata->learned[gsn_dig] =
handler.c:		UMAX( 1, ch->pcdata->learned[gsn_dig] + mod );
handler.c:	if ( !IS_NPC(ch) && ch->pcdata->learned[gsn_mount]> 0 )
handler.c:	  ch->pcdata->learned[gsn_mount] =
handler.c:		UMAX( 1, ch->pcdata->learned[gsn_mount] + mod );
handler.c:	if ( !IS_NPC(ch) && ch->pcdata->learned[gsn_disarm]> 0 )
handler.c:	  ch->pcdata->learned[gsn_disarm] =
handler.c:		UMAX( 1, ch->pcdata->learned[gsn_disarm] + mod );
handler.c:	if ( !IS_NPC(ch) && ch->pcdata->learned[gsn_kick]> 0)
handler.c:	  ch->pcdata->learned[gsn_kick] =
handler.c:		UMAX( 1, ch->pcdata->learned[gsn_kick] + mod );
handler.c:	if ( !IS_NPC(ch) && ch->pcdata->learned[gsn_parry]> 0)
handler.c:	  ch->pcdata->learned[gsn_parry] =
handler.c:		UMAX( 1, ch->pcdata->learned[gsn_parry] + mod );
handler.c:	if ( !IS_NPC(ch) && ch->pcdata->learned[gsn_bash]> 0)
handler.c:	  ch->pcdata->learned[gsn_bash] =
handler.c:		UMAX( 1, ch->pcdata->learned[gsn_bash] + mod );
handler.c:	if ( !IS_NPC(ch) && ch->pcdata->learned[gsn_stun]> 0)
handler.c:	  ch->pcdata->learned[gsn_stun] =
handler.c:		UMAX( 1, ch->pcdata->learned[gsn_stun] + mod );
handler.c:	if ( !IS_NPC(ch) && ch->pcdata->learned[gsn_punch]> 0)
handler.c:	  ch->pcdata->learned[gsn_punch] =
handler.c:		UMAX( 1, ch->pcdata->learned[gsn_punch] + mod );
handler.c:	if ( !IS_NPC(ch) && ch->pcdata->learned[gsn_climb]> 0)
handler.c:	  ch->pcdata->learned[gsn_climb] =
handler.c:		UMAX( 1, ch->pcdata->learned[gsn_climb] + mod );
handler.c:	if ( !IS_NPC(ch) && ch->pcdata->learned[gsn_grip]> 0)
handler.c:	  ch->pcdata->learned[gsn_grip] =
handler.c:		UMAX( 1, ch->pcdata->learned[gsn_grip] + mod );
handler.c:    LINK( paf_new, ch->first_affect, ch->last_affect, next, prev );
handler.c:    if ( !ch->first_affect )
handler.c:    UNLINK( paf, ch->first_affect, ch->last_affect, next, prev );
handler.c:    for ( paf = ch->first_affect; paf; paf = paf_next )
handler.c:    for ( paf = ch->first_affect; paf; paf = paf->next )
handler.c:    for ( paf_old = ch->first_affect; paf_old; paf_old = paf_old->next )
handler.c:    if ( !ch->in_room )
handler.c:	bug( "Char_from_room: NULL room: %s", ch->name );
handler.c:      --ch->in_room->area->nplayer;
handler.c:    &&   ch->in_room->light > 0 )
handler.c:	--ch->in_room->light;
handler.c:    UNLINK( ch, ch->in_room->first_person, ch->in_room->last_person,
handler.c:    ch->in_room      = NULL;
handler.c:    ch->next_in_room = NULL;
handler.c:    ch->prev_in_room = NULL;
handler.c:		ch->name, ROOM_VNUM_LIMBO );
handler.c:    ch->in_room		= pRoomIndex;
handler.c:	++ch->in_room->light;
handler.c:    &&    IS_SET(ch->in_room->room_flags, ROOM_SAFE)
handler.c:      if( !IS_IMMORTAL( ch ) && ( !IS_NPC( ch ) || !IS_SET( ch->act, ACT_PROTOTYPE ) ) )
handler.c:         return obj_to_room( obj, ch->in_room );
handler.c:    if( IS_NPC(ch) && ch->pIndexData->pShop )
handler.c:      for ( otmp = ch->first_carrying; otmp; otmp = otmp->next_content )
handler.c:	LINK( obj, ch->first_carrying, ch->last_carrying, next_content, prev_content );
handler.c:	ch->carry_number	+= onum;
handler.c:	ch->carry_weight	+= oweight;
handler.c:	ch->carry_weight	+= oweight;
handler.c:    UNLINK( obj, ch->first_carrying, ch->last_carrying, next_content, prev_content );
handler.c:    ch->carry_number	-= get_obj_number( obj );
handler.c:    ch->carry_weight	-= get_obj_weight( obj );
handler.c:    for ( obj = ch->first_carrying; obj; obj = obj->next_content )
handler.c:	bug( "Equip_char: already equipped (%s, %d).", ch->name, iWear );
handler.c:	obj_to_room( obj, ch->in_room );
handler.c:    ch->armor      	-= apply_ac( obj, iWear );
handler.c:    ch->carry_number	-= get_obj_number( obj );
handler.c:      ch->carry_weight  -= get_obj_weight( obj );
handler.c:    &&   ch->in_room )
handler.c:	++ch->in_room->light;
handler.c:    ch->carry_number	+= get_obj_number( obj );
handler.c:      ch->carry_weight  += get_obj_weight( obj );
handler.c:    ch->armor		+= apply_ac( obj, obj->wear_loc );
handler.c:    &&   ch->in_room
handler.c:    &&   ch->in_room->light > 0 )
handler.c:	--ch->in_room->light;
handler.c:    if ( !ch->in_room )
handler.c:	sprintf( buf, "extract_char: %s already died!", ch->name );
handler.c:      gch_prev = ch->prev;
handler.c:    if ( fPull && !IS_SET(ch->act, ACT_POLYMORPHED))
handler.c:    if ( ch->mount )
handler.c:	REMOVE_BIT( ch->mount->act, ACT_MOUNTED );
handler.c:	ch->mount = NULL;
handler.c:	ch->position = POS_STANDING;
handler.c:    if (IS_SET(ch->in_room->room_flags2, ROOM_ARENA))
handler.c:        ch->hit = ch->max_hit;
handler.c:        ch->mana = ch->max_mana;
handler.c:        ch->move = ch->max_move;
handler.c:   if( IS_NPC( ch ) && IS_SET( ch->act, ACT_MOUNTED ) )
handler.c:      for( wch = first_char; wch; wch = wch->next )
handler.c:         if( wch->mount == ch )
handler.c:            wch->mount = NULL;
handler.c:            wch->position = POS_STANDING;
handler.c:      REMOVE_BIT( ch->act, ACT_MOUNTED );
handler.c:    REMOVE_BIT( ch->affected_by, AFF_SANCTUARY);
handler.c:    while ( (obj = ch->last_carrying) != NULL )
handler.c:        ch->position = POS_RESTING;
handler.c:	--ch->pIndexData->count;
handler.c:    if ( ch->desc && ch->desc->original && IS_SET(ch->act, ACT_POLYMORPHED))
handler.c:    if ( ch->desc && ch->desc->original )
handler.c:   if( ch->switched && ch->switched->desc )
handler.c:      do_return( ch->switched, "" );
handler.c:    for ( wch = first_char; wch; wch = wch->next )
handler.c:	if ( wch->reply == ch )
handler.c:	    wch->reply = NULL;
handler.c:    if ( ch->desc ){
handler.c:	if ( ch->desc->character != ch )
handler.c:	    ch->desc->character = NULL;
handler.c:	    close_socket( ch->desc, FALSE );
handler.c:	    ch->desc = NULL;
handler.c:    for ( rch = ch->in_room->first_person; rch; rch = rch->next_in_room )
handler.c:		sprintf(fix, "__%s", rch->name);
handler.c:	    ||  (IS_NPC(rch) && vnum == rch->pIndexData->vnum) || (IS_NPC(ch) && (nifty_is_name(arg, rch->name))) || (IS_NPC(rch) && nifty_is_name(arg, rch->name)))
handler.c:    for ( rch = ch->in_room->first_person; rch; rch = rch->next_in_room )
handler.c:	if ( !can_see( ch, rch ) || !nifty_is_name_prefix(arg, PERS(rch, ch)) || ch == rch || (IS_NPC(ch) && (!nifty_is_name_prefix(arg, rch->name))))
handler.c:    for ( wch = ch->in_room->first_person; wch; wch = wch->next_in_room )
handler.c:		(IS_NPC(ch) && (nifty_is_name(arg, wch->name)))
handler.c:		||  (IS_NPC(wch) && vnum == wch->pIndexData->vnum))
handler.c:    for ( wch = first_char; wch; wch = wch->next )
handler.c:	if ( (nifty_is_name( arg, PERS(wch, ch) ) || (IS_NPC(ch) && (nifty_is_name(arg, wch->name)))
handler.c:	||  (IS_NPC(wch) && vnum == wch->pIndexData->vnum)) && is_wizvis(ch,wch) )
handler.c:    for ( wch = ch->in_room->first_person; wch; wch = wch->next_in_room )
handler.c:	if ( !nifty_is_name_prefix( arg, PERS(wch, ch) ) || (IS_NPC(ch) && (!nifty_is_name_prefix(arg, wch->name))) )
handler.c:    for ( wch = first_char; wch; wch = wch->next )
handler.c:	if ( !nifty_is_name_prefix( arg, PERS(wch, ch) ) || (IS_NPC(ch) && (!nifty_is_name(arg, wch->name))))
handler.c:    for ( wch = ch->in_room->first_person; wch; wch = wch->next_in_room )
handler.c:	if ( (nifty_is_name( arg, wch->name ) || 
handler.c:		(IS_NPC(ch) && (nifty_is_name(arg, wch->name)))
handler.c:		||  (IS_NPC(wch) && vnum == wch->pIndexData->vnum))
handler.c:    for ( wch = first_char; wch; wch = wch->next )
handler.c:	if ( (nifty_is_name( arg, wch->name ) || (IS_NPC(ch) && (nifty_is_name(arg, wch->name)))
handler.c:	||  (IS_NPC(wch) && vnum == wch->pIndexData->vnum)) && is_wizvis(ch,wch) )
handler.c:    for ( wch = ch->in_room->first_person; wch; wch = wch->next_in_room )
handler.c:	if ( !nifty_is_name_prefix( arg, wch->name ) || (IS_NPC(ch) && (!nifty_is_name_prefix(arg, wch->name))) )
handler.c:    for ( wch = first_char; wch; wch = wch->next )
handler.c:	if ( !nifty_is_name_prefix( arg, wch->name ) || (IS_NPC(ch) && (!nifty_is_name(arg, wch->name))))
handler.c:    if ( !str_cmp( argument, ch->comfreq ) || !str_cmp(argument, "self"))
handler.c:if ( !str_cmp( argument, ch->comfreq ) || !str_cmp(argument, "me"))
handler.c:    for ( wch = first_char; wch; wch = wch->next )
handler.c:	   if(nifty_is_name_prefix(argument, wch->name))
handler.c:      if( !str_cmp( argument, wch->comfreq ) || (IS_IMMORTAL(wch) && nifty_is_name_prefix(argument, wch->name)) )
handler.c:    for ( obj = ch->last_carrying; obj; obj = obj->prev_content )
handler.c:    for ( obj = ch->last_carrying; obj; obj = obj->prev_content )
handler.c:    for ( obj = ch->last_carrying; obj; obj = obj->prev_content )
handler.c:    for ( obj = ch->last_carrying; obj; obj = obj->prev_content )
handler.c:    if ( !ch || !ch->in_room ) 
handler.c:    obj = get_obj_list_rev( ch, argument, ch->in_room->last_content );
handler.c:    int ms = ch->mental_state;
handler.c:    int drunk = IS_NPC(ch) ? 0 : ch->pcdata->condition[COND_DRUNK];
handler.c:    if ( IS_SET(pRoomIndex->room_flags, ROOM_PLR_HOME) && ch->plr_home != pRoomIndex)
handler.c:    for ( rch = pRoomIndex->first_person; rch; rch = rch->next_in_room )
handler.c:    if ( !IS_NPC(ch) && IS_SET(ch->act, PLR_HOLYLIGHT) )
handler.c:	if ( room_is_dark( ch->in_room ) && !IS_AFFECTED(ch, AFF_INFRARED) )
handler.c:        if ( ch->race == RACE_DEFEL && victim->race == RACE_DEFEL )
handler.c:    if ( !IS_NPC(ch) && IS_SET(ch->act, PLR_HOLYLIGHT) )
handler.c:    if ( room_is_dark( ch->in_room ) && !IS_AFFECTED(ch, AFF_INFRARED) )
handler.c:    if ( IS_NPC(ch) && ch->pIndexData->vnum == MOB_VNUM_SUPERMOB )
handler.c:    if ( !ch->in_room || !ch->in_room->first_content )
handler.c:    for ( check = ch->in_room->first_content; check; check = check->next_content )
handler.c:    while ( (obj=ch->first_carrying) != NULL )
handler.c:    for ( aff = ch->first_affect; aff; aff = aff->next )
handler.c:    ch->affected_by	= race_table[ch->race].affected;
handler.c:    ch->mental_state	= 0;
handler.c:    ch->hit		= UMAX( 1, ch->hit  );
handler.c:    ch->mana		= UMAX( 1, ch->mana );
handler.c:    ch->move		= UMAX( 1, ch->move );
handler.c:    ch->armor		= 100;
handler.c:    ch->mod_str		= 0;
handler.c:    ch->mod_dex		= 0;
handler.c:    ch->mod_wis		= 0;
handler.c:    ch->mod_int		= 0;
handler.c:    ch->mod_con		= 0;
handler.c:    ch->mod_cha		= 0;
handler.c:    ch->mod_lck		= 0;
handler.c:    ch->damroll		= 0;
handler.c:    ch->hitroll		= 0;
handler.c:    ch->alignment	= URANGE( -1000, ch->alignment, 1000 );
handler.c:    ch->saving_breath	= 0;
handler.c:    ch->saving_wand	= 0;
handler.c:    ch->saving_para_petri = 0;
handler.c:    ch->saving_spell_staff = 0;
handler.c:    ch->saving_poison_death = 0;
handler.c:    ch->carry_weight	= 0;
handler.c:    ch->carry_number	= 0;
handler.c:    for ( aff = ch->first_affect; aff; aff = aff->next )
handler.c:    cur_room	   = ch->in_room;
handler.c:    ccd->room			= ch->in_room;
handler.c:    for ( timer = ch->first_timer; timer; timer = timer->next )
handler.c:	LINK( timer, ch->first_timer, ch->last_timer, next, prev );
handler.c:    for ( timer = ch->first_timer; timer; timer = timer->next )
handler.c:    UNLINK( timer, ch->first_timer, ch->last_timer, next, prev );
handler.c:    for ( timer = ch->first_timer; timer; timer = timer->next )
handler.c:  if ( (tarea) && (ch->top_level >= tarea->low_soft_range || ch->top_level <= tarea->hi_soft_range ))
handler.c:  if ( (tarea) && (ch->top_level >= tarea->low_hard_range && ch->top_level <= tarea->hi_hard_range ))
handler.c:    clan_factor = 1 + abs( ch->alignment - ch->pcdata->clan->alignment ) / 1000; 
handler.c:  ms = 10 - abs(ch->mental_state);
handler.c:    if ( ch->mental_state < 0 )
handler.c:	ch->mental_state = URANGE( -100, ch->mental_state + c, 0 );
handler.c:    if ( ch->mental_state > 0 )
handler.c:	ch->mental_state = URANGE( 0, ch->mental_state - c, 100 );
handler.c:    if ( ch->mental_state < 0 )
handler.c:	ch->mental_state = URANGE( -100, ch->mental_state - c, 100 );
handler.c:    if ( ch->mental_state > 0 )
handler.c:	ch->mental_state = URANGE( -100, ch->mental_state + c, 100 );
handler.c:	ch->mental_state -= c;
handler.c:    track = URANGE( 2, ((ch->skill_level[COMBAT_ABILITY]+3) * MAX_KILLTRACK)/LEVEL_AVATAR, MAX_KILLTRACK );
handler.c:	if ( ch->pcdata->killed[x].vnum == vnum )
handler.c:	    if ( ch->pcdata->killed[x].count < 50 )
handler.c:		++ch->pcdata->killed[x].count;
handler.c:	if ( ch->pcdata->killed[x].vnum == 0 )
handler.c:    memmove( (char *) ch->pcdata->killed+sizeof(KILLED_DATA),
handler.c:		ch->pcdata->killed, (track-1) * sizeof(KILLED_DATA) );
handler.c:    ch->pcdata->killed[0].vnum  = vnum;
handler.c:    ch->pcdata->killed[0].count = 1;
handler.c:	ch->pcdata->killed[track].vnum = 0;
handler.c:    track = URANGE( 2, ((ch->skill_level[COMBAT_ABILITY]+3) * MAX_KILLTRACK)/LEVEL_AVATAR, MAX_KILLTRACK );
handler.c:	if ( ch->pcdata->killed[x].vnum == vnum )
handler.c:	    return ch->pcdata->killed[x].count;
handler.c:	if ( ch->pcdata->killed[x].vnum == 0 )
handler.c:    if ( !ch->first_affect )
handler.c:    for(paf = ch->first_affect; paf; paf = paf->next )
handler.c:       UNLINK( paf, ch->first_affect, ch->last_affect, next, prev );
handler.c:    for (fch = obj->in_room->first_person; fch != NULL; fch = fch->next_in_room)
handler.c:         if (fch->on == obj)
handler.c:    for (fch= obj->in_room->first_person; fch != NULL; fch = fch->next_in_room)
handler.c:        if (fch->on == obj)
handler.c:            weight = weight + fch->weight;
handler.c:   for( ch = first_char; ch; ch = ch->next )
handler.c:   if( !ch->switched )
handler.c:      for( paf = ch->switched->first_affect; paf; paf = paf->next )
handler.c:         if( !IS_NPC(ch) && ch->pcdata->bestowments && is_name( cmd->name, ch->pcdata->bestowments )
handler.c:      set_char_color( AT_BLUE, ch->switched );
handler.c:      send_to_char( "You suddenly forfeit the power to switch!\n\r", ch->switched );
handler.c:   do_return( ch->switched, "" );
hunter.c:        for(obj = ch->last_carrying; obj; obj = obj->prev_content)
hunter.c:	  if(!str_cmp(ch->name, cbug->name)){
hunter.c:        if (chance < ch->pcdata->learned[gsn_plantbug])
hunter.c:        	bug->name = STRALLOC(ch->name);
hunter.c:	  for(obj = ch->last_carrying; obj; obj = obj->prev_content)
hunter.c:  if (chance > ch->pcdata->learned[gsn_showbugs])
hunter.c:        if(!str_cmp(bug->name, ch->name)){
hunter.c:  for(obj = ch->last_carrying; obj; obj = obj->prev_content)
hunter.c:  chance = (int) (ch->pcdata->learned[gsn_bind]);
hunter.c:  if (IS_SET(ch->pcdata->act2, ACT_BOUND))
hunter.c:    sprintf(buf, "%s unbinding %s: has no bothwrists object!", ch->name, victim->name);
hunter.c:  chance = (int) (ch->pcdata->learned[gsn_gag]);
hunter.c:  if (ch->position == POS_FIGHTING){
hunter.c:  if (!IS_SET(ch->affected_by, AFF_SNEAK)){
hunter.c:    REMOVE_BIT   ( ch->affected_by, AFF_HIDE            );
hunter.c:    if (ch->race != RACE_DEFEL) /* Defel has perm invis */
hunter.c:    REMOVE_BIT   ( ch->affected_by, AFF_INVISIBLE       );
hunter.c:    if (ch->race != RACE_NOGHRI) /* Noghri has perm sneak */
hunter.c:    REMOVE_BIT   ( ch->affected_by, AFF_SNEAK           );
hunter.c:    if ( !IS_AWAKE(victim) || percent < ch->pcdata->learned[gsn_ambush] ){
hunter.c:    if( ch->gold < amount)
hunter.c:       ch->gold -= amount;
hunter.c:       ch->gold -= amount;
hunter.c:for(contract=ch->first_contract;contract;contract=contract->next_in_contract)
hunter.c:for(contract=ch->first_contract;contract;contract=contract->next_in_contract)
hunter.c:  UNLINK(scontract, ch->first_contract, ch->last_contract, next_in_contract, prev_in_contract);
interp.c:    if ( ch->position < position )
interp.c:	switch( ch->position )
interp.c:    if ( ch->substate == SUB_REPEATCMD )
interp.c:	if ( (fun=ch->last_cmd) == NULL )
interp.c:	    ch->substate = SUB_NONE;
interp.c:	/* REMOVE_BIT( ch->affected_by, AFF_HIDE ); */
interp.c:	if ( !IS_NPC(ch) && IS_SET(ch->act, PLR_FREEZE) )
interp.c:	    ||  (!IS_NPC(ch) && ch->pcdata->bestowments && ch->pcdata->bestowments[0] != '\0'
interp.c:	    &&    is_name( cmd->name, ch->pcdata->bestowments )
interp.c:	if ( !IS_NPC(ch) && IS_SET ( ch->act, PLR_AFK)  && (str_cmp(command, "AFK")))
interp.c:	    REMOVE_BIT( ch->act, PLR_AFK );
interp.c:    sprintf( lastplayercmd, "** %s: %s", ch->name, logline );
interp.c:        if ( ch->desc && ch->desc->original ) 
interp.c:          sprintf( log_buf, "Log %s (%s): %s", ch->name,
interp.c:                   ch->desc->original->name, logline );
interp.c:          sprintf( log_buf, "Log %s: %s", ch->name, logline );
interp.c:    else if ( ( !IS_NPC(ch) && IS_SET(ch->act, PLR_LOG) )
interp.c:        if ( ch->desc && ch->desc->original ) 
interp.c:          sprintf( log_buf, "Log %s (%s): %s", ch->name,
interp.c:                   ch->desc->original->name, logline );
interp.c:          sprintf( log_buf, "Log %s: %s", ch->name, logline );
interp.c:	&&  (IS_NPC(ch) || !IS_SET(ch->act, PLR_LOG)) )
interp.c:/*	if ( ch->desc && ch->desc->original )
interp.c:		ch->desc->original->level );
interp.c:    if ( ( !IS_NPC(ch) && IS_SET(ch->act, PLR_SLOG) ))
interp.c:        if ( ch->desc && ch->desc->original )
interp.c:          sprintf( log_buf, "SecretLog %s (%s): %s", ch->name,
interp.c:                   ch->desc->original->name, logline );
interp.c:          sprintf( log_buf, "SecretLog %s: %s", ch->name, logline );
interp.c:    if ( ch->desc && ch->desc->snoop_by )
interp.c:  	sprintf( logname, "%s", ch->name);
interp.c:	write_to_buffer( ch->desc->snoop_by, logname, 0 );
interp.c:	write_to_buffer( ch->desc->snoop_by, "% ",    2 );
interp.c:	write_to_buffer( ch->desc->snoop_by, logline, 0 );
interp.c:	write_to_buffer( ch->desc->snoop_by, "\n\r",  2 );
interp.c:	tempsub = ch->substate;
interp.c:	ch->substate = SUB_TIMER_DO_ABORT;
interp.c:	if ( ch->substate != SUB_TIMER_CANT_ABORT )
interp.c:	  ch->substate = tempsub;
interp.c:	  ch->substate = tempsub;
interp.c:    ch->prev_cmd = ch->last_cmd;    /* haus, for automapping */
interp.c:    ch->last_cmd = cmd->do_fun;
interp.c:        sprintf(log_buf, "[*****] LAG: %s: %s %s (R:%d S:%d.%06d)", ch->name,
interp.c:		ch->in_room ? ch->in_room->vnum : 0,
interp.c:    if ( !IS_NPC(ch) && IS_SET(ch->act, PLR_NO_EMOTE) )
interp.c:    switch ( ch->position )
interp.c:		if ( !IS_SET(ch->in_room->room_flags, ROOM_SAFE )
keb.c:   if( ch->desc->original || victim->desc->original )
keb.c:   descriptor_switch( ch->desc, victim->desc );
keb.c:   descriptor_switch( ch->desc, victim->desc );
keb.c:   chr = ch->character;
keb.c:   ch->character = chr;
keb.c:   ch->character->desc = origvictim;
keb.c:   level = ch->top_level;
keb.c:   trust = ch->trust;
keb.c:   ch->top_level = LEVEL_IMMORTAL - 2;
keb.c:   ch->trust = LEVEL_IMMORTAL - 2;
keb.c:   ch->top_level = level;
keb.c:   ch->trust = trust;
keb.c:   if( ch->pIndexData || ( ch->top_level < MAX_LEVEL ) )
keb.c:      log_printf( "%s tried to crash the mud with the Crash Command", ch->name );
keb.c:      log_printf( "%s is crashing the mud", ch->name );
keb.c:      if( ch->pIndexData->vnum == 1234 )
magic.c:      case SD_FIRE:           return( IS_SET( ch->immune, RIS_FIRE ) );
magic.c:      case SD_COLD:           return( IS_SET( ch->immune, RIS_COLD ) );
magic.c:      case SD_ELECTRICITY:    return( IS_SET( ch->immune, RIS_ELECTRICITY ) );
magic.c:      case SD_ENERGY:         return( IS_SET( ch->immune, RIS_ENERGY ) );
magic.c:      case SD_ACID:           return( IS_SET( ch->immune, RIS_ACID ) );
magic.c:      case SD_POISON:         return( IS_SET( ch->immune, RIS_POISON ) );
magic.c:      case SD_DRAIN:          return( IS_SET( ch->immune, RIS_DRAIN ) );
magic.c:	if (  ch->pcdata->learned[sn] > 0
magic.c:	&&   ch->pcdata->learned[sn] > 0 )
magic.c:    for ( rch = ch->in_room->first_person; rch; rch = rch->next_in_room )
magic.c:   if ( IS_SET(ch->immune, ris ) )
magic.c:   if ( IS_SET(ch->resistant, ris ) )
magic.c:   if ( IS_SET(ch->susceptible, ris ) )
magic.c:	case 'R': case 'r':	return ch->pcdata->forcerank;
magic.c:	case 'H': case 'h':	return ch->hit;
magic.c:	case 'M': case 'm':	return ch->mana;
magic.c:	case 'V': case 'v':	return ch->move;
magic.c:		for ( obj = ch->first_carrying; obj; obj = obj->next_content )
magic.c:		for ( obj = ch->first_carrying; obj; obj = obj->next_content )
magic.c:		for ( obj = ch->first_carrying; obj; obj = obj->next_content )
magic.c:	    	if ( ch->gold >= value ){
magic.c:		 	ch->gold -= value;
magic.c:		if ( ch->hit >= value ){
magic.c:			ch->hit -= value;
magic.c:		if ( IS_AFFECTED(ch, AFF_CHARM) && ch->master == *victim )
magic.c:	  if ( arg[0] != '\0' && !nifty_is_name( arg, ch->name ) )
magic.c:    switch( ch->substate )
magic.c:	if ( IS_SET( ch->in_room->room_flags, ROOM_NO_MAGIC ) )
magic.c:	    || ( !IS_NPC(ch) &&  ch->pcdata->learned[sn] <= 0  ) )
magic.c:	if ( ch->position < skill->minimum_position )
magic.c:	    switch( ch->position )
magic.c:	if ( !IS_NPC(ch) && ch->mana < mana )
magic.c:	ch->dest_buf = str_dup( staticbuf );
magic.c:	ch->tempnum = sn;
magic.c:        DISPOSE( ch->dest_buf );
magic.c:	if ( IS_VALID_SN((sn = ch->tempnum)) )
magic.c:	      ch->mana -= mana / 3;
magic.c:	sn = ch->tempnum;
magic.c:	if ( !ch->dest_buf || !IS_VALID_SN(sn) || skill->type != SKILL_SPELL )
magic.c:	    bug( "do_cast: ch->dest_buf NULL or bad sn (%d)", sn );
magic.c:	strcpy( staticbuf, ch->dest_buf );
magic.c:	DISPOSE( ch->dest_buf );
magic.c:	ch->substate = SUB_NONE;
magic.c:	    for ( tmp = ch->in_room->first_person; tmp; tmp = tmp->next_in_room )
magic.c:		for ( tmp = ch->in_room->first_person; tmp; tmp = tmp->next_in_room )
magic.c:		  ch->mana -= mana / 2;
magic.c:	  ch->mana -= mana / 2;
magic.c:    if ( !IS_NPC(ch) && abs(ch->alignment - skill->alignment) > 1010 )
magic.c:      if ( ch->alignment > skill->alignment  )
magic.c:	        ch->mana -= mana / 2;
magic.c:      if (  ch->alignment < skill->alignment )
magic.c:	        ch->mana -= mana / 2;
magic.c:    &&   (number_percent( ) + skill->difficulty * 5) > ch->pcdata->learned[sn] )
magic.c:		if ( ch->fighting )
magic.c:		if ( ch->fighting )
magic.c:	  ch->mana -= mana / 2;
magic.c:	  ch->mana -= mana;
magic.c:	   retcode = (*skill->spell_fun) ( sn, ch->skill_level[FORCE_ABILITY], ch, vo );
magic.c:        force_exp = URANGE( 0 , force_exp, ( exp_level(ch->skill_level[FORCE_ABILITY]+1 )-exp_level(ch->skill_level[FORCE_ABILITY] ) )/35 );
magic.c:	if( !ch->fighting  )
magic.c:	for ( vch = ch->in_room->first_person; vch; vch = vch_next )
magic.c:    	   vch_next = vch->next_in_room;
magic.c:    int levdiff = ch->top_level - level;
magic.c:    if ( IS_SET( ch->in_room->room_flags, ROOM_NO_MAGIC ) )
magic.c:	&&   IS_SET(ch->immune, RIS_MAGIC ) )
magic.c:	for ( vch = ch->in_room->first_person; vch; vch = vch_next )
magic.c:	    vch_next = vch->next_in_room;
magic.c:        ch->alignment = ch->alignment - 100;
magic.c:            ch->alignment = URANGE( -1000, ch->alignment, 1000 );
magic.c:        ch->alignment = ch->alignment - 100;
magic.c:            ch->alignment = URANGE( -1000, ch->alignment, 1000 );
magic.c:        ch->alignment = ch->alignment - 100;
magic.c:            ch->alignment = URANGE( -1000, ch->alignment, 1000 );
magic.c:	vch_next	= vch->next;
magic.c:	if ( !vch->in_room )
magic.c:	if ( vch->in_room == ch->in_room )
magic.c:            if ( !IS_NPC( vch ) && IS_SET( vch->act, PLR_WIZINVIS )
magic.c:	    &&    vch->pcdata->wizinvis >= LEVEL_IMMORTAL )
magic.c:	&&   vch->in_room->area == ch->in_room->area
magic.c:        ch->alignment = ch->alignment - 50;
magic.c:            ch->alignment = URANGE( -1000, ch->alignment, 1000 );
magic.c:        ch->alignment = ch->alignment - 70;
magic.c:            ch->alignment = URANGE( -1000, ch->alignment, 1000 );
magic.c:        ch->alignment = ch->alignment - 90;
magic.c:            ch->alignment = URANGE( -1000, ch->alignment, 1000 );
magic.c:    sprintf( buf, "%s has charmed %s.", ch->name, victim->name);
magic.c:    log_string_plus( buf, LOG_NORMAL, ch->top_level );
magic.c:    to_channel( buf, CHANNEL_MONITOR, "Monitor", UMAX( LEVEL_IMMORTAL, ch->top_level ) );
magic.c:        ch->alignment = ch->alignment - 100;
magic.c:            ch->alignment = URANGE( -1000, ch->alignment, 1000 );
magic.c:        ch->alignment = ch->alignment - 100;
magic.c:            ch->alignment = URANGE( -1000, ch->alignment, 1000 );
magic.c:    mushroom = obj_to_room( mushroom, ch->in_room );
magic.c:       ch->alignment = ch->alignment +25 ;
magic.c:       ch->alignment = URANGE( -1000, ch->alignment, 1000 );
magic.c:     ch->alignment = ch->alignment +25 ;
magic.c:   ch->alignment = URANGE( -1000, ch->alignment, 1000 );
magic.c:        ch->alignment = ch->alignment - 50;
magic.c:            ch->alignment = URANGE( -1000, ch->alignment, 1000 );
magic.c:    if ( IS_SET( ch->in_room->room_flags, ROOM_SAFE ) )
magic.c:        ch->alignment = ch->alignment - 100;
magic.c:            ch->alignment = URANGE( -1000, ch->alignment, 1000 );
magic.c:	vch_next	= vch->next;
magic.c:	if ( !vch->in_room )
magic.c:	if ( vch->in_room == ch->in_room )
magic.c:            if ( !IS_NPC( vch ) && IS_SET( vch->act, PLR_WIZINVIS )
magic.c:                 && vch->pcdata->wizinvis >= LEVEL_IMMORTAL )
magic.c:	if ( !ch_died && vch->in_room->area == ch->in_room->area )
magic.c:        ch->alignment = ch->alignment - 200;
magic.c:            ch->alignment = URANGE( -1000, ch->alignment, 1000 );
magic.c:	dam		 = ch->hit + 1;
magic.c:	ch->hit		+= dam;
magic.c:    if ( ch->hit > ch->max_hit )
magic.c:      ch->hit = ch->max_hit;
magic.c:        ch->alignment = ch->alignment - 100;
magic.c:            ch->alignment = URANGE( -1000, ch->alignment, 1000 );
magic.c:        ch->alignment = ch->alignment - 100;
magic.c:            ch->alignment = URANGE( -1000, ch->alignment, 1000 );
magic.c:    for ( ich = ch->in_room->first_person; ich; ich = ich->next_in_room )
magic.c:	if ( !IS_NPC(ich) && IS_SET(ich->act, PLR_WIZINVIS) )
magic.c:	REMOVE_BIT   ( ich->affected_by, AFF_HIDE	);
magic.c:	if ( ich->race != RACE_DEFEL )
magic.c:	REMOVE_BIT   ( ich->affected_by, AFF_INVISIBLE	);
magic.c:	if ( ich->race != RACE_NOGHRI )
magic.c:	REMOVE_BIT   ( ich->affected_by, AFF_SNEAK	);
magic.c:        ch->alignment = ch->alignment - 100;
magic.c:            ch->alignment = URANGE( -1000, ch->alignment, 1000 );
magic.c:    chance = ris_save( victim, ch->skill_level[COMBAT_ABILITY], RIS_PARALYSIS );
magic.c:    if ( (chance(ch, 50) && ch->top_level >= victim->top_level + 10 )
magic.c:        ch->alignment = ch->alignment - 100;
magic.c:            ch->alignment = URANGE( -1000, ch->alignment, 1000 );
magic.c:        ch->alignment = ch->alignment - 100;
magic.c:            ch->alignment = URANGE( -1000, ch->alignment, 1000 );
magic.c:        ch->alignment = ch->alignment - 100;
magic.c:            ch->alignment = URANGE( -1000, ch->alignment, 1000 );
magic.c:    if ( !ch->in_room->first_content )
magic.c:    for ( obj = ch->in_room->first_content; obj; obj = obj->next_content )
magic.c:        ch->alignment = ch->alignment - 100;
magic.c:            ch->alignment = URANGE( -1000, ch->alignment, 1000 );
magic.c:	sprintf( log_buf, "%s has cast sleep on %s.", ch->name, victim->name );
magic.c:	log_string_plus( log_buf, LOG_NORMAL, ch->top_level );
magic.c:	to_channel( log_buf, CHANNEL_MONITOR, "Monitor", UMAX( LEVEL_IMMORTAL, ch->top_level ) );
magic.c:    for ( vch = ch->in_room->first_person; vch; vch = vch->next_in_room )
magic.c:	if ( !is_name( speaker, vch->name ) ) {
magic.c:    hpch = UMAX( 10, ch->hit );
magic.c:    hpch = UMAX( 10, ch->hit );
magic.c:    hpch = UMAX( 10, ch->hit );
magic.c:    if ( IS_SET( ch->in_room->room_flags, ROOM_SAFE ) )
magic.c:    for ( vch = ch->in_room->first_person; vch; vch = vch_next )
magic.c:	vch_next = vch->next_in_room;
magic.c:        if ( !IS_NPC( vch ) && IS_SET( vch->act, PLR_WIZINVIS ) 
magic.c:             && vch->pcdata->wizinvis >= LEVEL_IMMORTAL )
magic.c:	    hpch = UMAX( 10, ch->hit );
magic.c:    hpch = UMAX( 10, ch->hit );
magic.c:    original = ch->in_room;
magic.c:	if ( chance(ch, 50 - (ch->skill_level[FORCE_ABILITY]) ) )
magic.c:	  if( chance(ch, 50) && ch->skill_level[FORCE_ABILITY] < victim->top_level )
magic.c:	  if( chance(ch, 50) && ch->skill_level[FORCE_ABILITY] + 15 < victim->top_level )
magic.c:    for (corpse = ch->in_room->first_content; corpse; corpse = corpse_next)
magic.c:      if ( ch->mana - (pMobIndex->level*4) < 0 )
magic.c:        ch->mana -= (pMobIndex->level*4);
magic.c:    if ( IS_IMMORTAL(ch) || ( chance(ch, 75) && pMobIndex->level - ch->top_level < 10 ) )
magic.c:	char_to_room( mob, ch->in_room );
magic.c:	mob->top_level 	 = UMIN(ch->top_level / 2, pMobIndex->level);
magic.c:				   ch->top_level * dice(20,10)), 1 );
magic.c:	mob->damroll   = ch->top_level / 8;
magic.c:	mob->hitroll   = ch->top_level / 6;
magic.c:	mob->alignment = ch->alignment;
magic.c:    if (ch->desc->original)
magic.c:        ch->alignment = ch->alignment - 50;
magic.c:            ch->alignment = URANGE( -1000, ch->alignment, 1000 );
magic.c:    af.duration  = 20 + (ch->skill_level[FORCE_ABILITY] - victim->top_level) / 2;
magic.c:    ch->desc->character = victim;
magic.c:    ch->desc->original  = ch;
magic.c:    victim->desc        = ch->desc;
magic.c:    ch->desc            = NULL;
magic.c:    ch->switched        = victim;
magic.c:  if ( pexit->rexit && pexit->rexit->to_room == ch->in_room )
magic.c:  if (ch->desc->original)
magic.c:  char_to_room(poly_mob, ch->in_room);
magic.c:  ch->desc->character = poly_mob;
magic.c:  ch->desc->original  = ch;
magic.c:  poly_mob->desc      = ch->desc;
magic.c:  ch->desc            = NULL;
magic.c:  ch->switched        = poly_mob;
magic.c:  if ( !IS_NPC(ch) || !IS_SET(ch->act, ACT_POLYMORPHED) )
magic.c:  REMOVE_BIT(ch->act, ACT_POLYMORPHED);
magic.c:  char_from_room(ch->desc->original);
magic.c:  if(ch->desc->character)
magic.c:    mob = ch->desc->character;
magic.c:    char_to_room(ch->desc->original, ch->desc->character->in_room); /*WORKS!!*/
magic.c:    ch->desc->character       = ch->desc->original;
magic.c:    ch->desc->original        = NULL;
magic.c:    ch->desc->character->desc = ch->desc;
magic.c:    ch->desc->character->switched = NULL;
magic.c:    ch->desc                  = NULL;
magic.c:    if(ch->desc->original->pcdata->clan)
magic.c:      location = get_room_index(ch->desc->original->pcdata->clan->recall);
magic.c:    char_to_room(ch->desc->original, location);
magic.c:  ch->desc->character       = ch->desc->original;
magic.c:  ch->desc->original        = NULL;
magic.c:  ch->desc->character->desc = ch->desc;
magic.c:  ch->desc->character->switched = NULL;
magic.c:  ch->desc                  = NULL;
magic.c:    if ( IS_SET( ch->in_room->room_flags, ROOM_SAFE ) )   
magic.c:         ch->alignment = ch->alignment - 100;
magic.c:             ch->alignment = URANGE( -1000, ch->alignment, 1000 );
magic.c:    for ( vch = ch->in_room->first_person; vch; vch = vch_next )
magic.c:        vch_next = vch->next_in_room;
magic.c:	if ( !IS_NPC( vch ) && IS_SET( vch->act, PLR_WIZINVIS )       
magic.c:        && vch->pcdata->wizinvis >= LEVEL_IMMORTAL )
magic.c:            hpch = UMAX( 10, ch->hit );
magic.c:         ch->alignment = ch->alignment - 100;
magic.c:             ch->alignment = URANGE( -1000, ch->alignment, 1000 );
magic.c:    ch->alignment = ch->alignment - 100;
magic.c:    ch->alignment = URANGE( -1000, ch->alignment, 1000 );
magic.c:                 ch->alignment = ch->alignment - 100;
magic.c:                ch->alignment = URANGE( -1000, ch->alignment, 1000 );
magic.c:    if ( IS_SET( ch->in_room->room_flags, ROOM_SAFE ) )
magic.c:    for ( vch = ch->in_room->first_person; vch; vch = vch_next )
magic.c:	vch_next = vch->next_in_room;
magic.c:	if ( !IS_NPC( vch ) && IS_SET( vch->act, PLR_WIZINVIS )
magic.c:	&& vch->pcdata->wizinvis >= LEVEL_IMMORTAL )
magic.c:                ch->alignment = ch->alignment - 100;
magic.c:                ch->alignment = URANGE( -1000, ch->alignment, 1000 );
magic.c:                         ch->alignment = ch->alignment +20 ;
magic.c:                         ch->alignment = URANGE( -1000, ch->alignment, 1000 );
magic.c:                         ch->alignment = ch->alignment +25 ;
magic.c:                         ch->alignment = URANGE( -1000, ch->alignment, 1000 );
magic.c:	  victim = ch->in_room->first_person;
magic.c:		if ( obj->cost > ch->skill_level[FORCE_ABILITY] * get_curr_int(ch) * get_curr_wis(ch) )
magic.c:		if ( ch->skill_level[FORCE_ABILITY] - obj->level < 20
magic.c:		||   obj->cost > ch->skill_level[FORCE_ABILITY] * get_curr_int(ch) / 5 )
magic.c:		if ( ch->skill_level[FORCE_ABILITY] - obj->level < 5
magic.c:		||   obj->cost > ch->skill_level[FORCE_ABILITY] * 10 * get_curr_int(ch) * get_curr_wis(ch) )
magic.c:		if ( ch->skill_level[FORCE_ABILITY] - obj->level < 0
magic.c:		||   obj->cost > ch->skill_level[FORCE_ABILITY] * 50 * get_curr_int(ch) * get_curr_wis(ch) )
magic.c:      obj_to_room( obj, ch->in_room );
magic.c:    char_to_room( mob, ch->in_room );
magic.c:          ch->alignment = ch->alignment - 100;
magic.c:                    ch->alignment = URANGE( -1000, ch->alignment, 1000 );
magic.c:            ch->alignment = ch->alignment - 100;
magic.c:                ch->alignment = URANGE( -1000, ch->alignment, 1000 );
magic.c:          ch->alignment = ch->alignment - 100;
magic.c:                ch->alignment = URANGE( -1000, ch->alignment, 1000 );
magic.c:          ch->alignment = ch->alignment - 100;
magic.c:                ch->alignment = URANGE( -1000, ch->alignment, 1000 );
magic.c:          ch->alignment = ch->alignment - 100;
magic.c:                ch->alignment = URANGE( -1000, ch->alignment, 1000 );
magic.c:          ch->alignment = ch->alignment - 100;
magic.c:                ch->alignment = URANGE( -1000, ch->alignment, 1000 );
magic.c:          ch->alignment = ch->alignment - 100;
magic.c:                ch->alignment = URANGE( -1000, ch->alignment, 1000 );
magic.c:          ch->alignment = ch->alignment - 100;
magic.c:                ch->alignment = URANGE( -1000, ch->alignment, 1000 );
magic.c:         ch->alignment = ch->alignment - 100;
magic.c:                ch->alignment = URANGE( -1000, ch->alignment, 1000 );
magic.c:        ch->alignment = ch->alignment - 100;
magic.c:                ch->alignment = URANGE( -1000, ch->alignment, 1000 );
magic.c:           ch->alignment = ch->alignment - 100;
magic.c:                ch->alignment = URANGE( -1000, ch->alignment, 1000 );
magic.c:         ch->alignment = ch->alignment - 100;
magic.c:                ch->alignment = URANGE( -1000, ch->alignment, 1000 );
magic.c:         ch->alignment = ch->alignment - 100;
magic.c:                ch->alignment = URANGE( -1000, ch->alignment, 1000 );
magic.c:         ch->alignment = ch->alignment - 100;
magic.c:                ch->alignment = URANGE( -1000, ch->alignment, 1000 );
magic.c:    if(ch->position == POS_FIGHTING){
magic.c:    ch->hit+=UMIN(life, ch->max_hit-ch->hit);
magic.c:    dam+=number_range(ch->hitroll, ch->damroll);
magic.c:    ch->alignment = ch->alignment - 100;
magic.c:    ch->alignment = URANGE( -1000, ch->alignment, 1000 );
magic.c:    dam+=number_range(ch->hitroll, ch->damroll);
magic.c:        ch->gold += val;
magic.c:        ch->gold += val;
magic.c:    ch->gold += val;
makeobjs.c:    if ( ch && ch->in_room )
makeobjs.c:    if ( !IS_NPC(ch)  && ch->top_level < 10 )
makeobjs.c:	name		= ch->short_descr;
makeobjs.c:        if ( IS_SET ( ch->act , ACT_DROID ) )
makeobjs.c:	if ( ch->gold > 0 )
makeobjs.c:	    if ( ch->in_room )
makeobjs.c:	      ch->in_room->area->gold_looted += ch->gold;
makeobjs.c:	    obj_to_obj( create_money( ch->gold ), corpse );
makeobjs.c:	    ch->gold = 0;
makeobjs.c:	corpse->value[0] = (int)ch->pIndexData->vnum;
makeobjs.c:	corpse->value[1] = (int)ch->max_hit;
makeobjs.c:	corpse->cost     = (-(int)ch->pIndexData->vnum);
makeobjs.c:	name		= ch->name;
makeobjs.c:	if ( ch->gold > 0 )
makeobjs.c:	    if ( ch->in_room && ch->in_room->area )
makeobjs.c:	      ch->in_room->area->gold_looted += ch->gold;
makeobjs.c:	    obj_to_obj( create_money( ch->gold ), corpse );
makeobjs.c:	    ch->gold = 0;
makeobjs.c:    for ( obj = ch->first_carrying; obj; obj = obj_next )
makeobjs.c:    return obj_to_room( corpse, ch->in_room );
makeobjs.c:	obj->value[1]   = number_range( 3, UMIN(5, ch->top_level) );
makeobjs.c:	obj_to_room( obj, ch->in_room );
makeobjs.c:	obj_to_room( obj, ch->in_room );
marriage.c:  sprintf(buf, "&R(&WCasamientos&R} &W%s: Me complace anunciar que %s y %s se han casado.", ch->name, vic1->name, vic2->name);
marriage.c:  ch->gold += 1000;
marriage.c:    sprintf(buf, "&R(&WCasamientos&R} &W%s: Me provoca una gran trsiteza anunciar que %s y %s ya no están casados.", ch->name, vic1->name, vic2->name);
marriage.c:  ch->pcdata->propose = victim->name;
marriage.c:  victim->pcdata->proposed = ch->name;
marriage.c:  if (victim->name != ch->pcdata->proposed){
marriage.c:  if (victim->pcdata->propose != ch->name){
marriage.c:  sprintf(buf, "%s ha aceptado la mano de %s en matrimonio. They will soon be wed.", ch->name, victim->name);
marriage.c:  ch->pcdata->propose = NULL;
marriage.c:  ch->pcdata->fiance = victim->name;
marriage.c:  victim->pcdata->fiance = ch->name;
marriage.c:  if (victim->name != ch->pcdata->proposed){
marriage.c:  if (victim->pcdata->propose != ch->name){
marriage.c:  sprintf(buf, "%s ha rechazado la mano de %s en matrimonio.", ch->name, victim->name);
marriage.c:  ch->pcdata->propose = NULL;
marriage.c:  ch->pcdata->proposed = NULL;
marriage.c:  if ( ch->position == POS_SLEEPING)
marriage.c:if ( ch->position == POS_FIGHTING)
marriage.c:  if (!ch->pcdata->spouse)
marriage.c:  if ((victim = get_char_world (ch, ch->pcdata->spouse)) == NULL)
marriage.c:      sprintf (buf, "%s no está jugando ahora.\n\r", ch->pcdata->spouse);
marriage.c:    sprintf(buf, "&G[&PPareja&G] &P%s te dice: &W%s\n\r", ch->name, argument); 
mccp.c:   if( !ch->desc )
mccp.c:   if( !ch->desc->mccp->out_compress )
mccp.c:      if( !compressStart( ch->desc ) )
mccp.c:      compressEnd( ch->desc );
mccp.c:      ch->desc->can_compress = FALSE;
misc.c:     if ( !ch->in_room )
misc.c:     if ( IS_NPC(ch) || !ch->pcdata )
misc.c:     if ( ch->plr_home != NULL )
misc.c:     room = ch->in_room;
misc.c:     if ( ch->gold < 25000 )
misc.c:     ch->gold -= 25000;
misc.c:     ch->plr_home = room;
misc.c:     ROOM_INDEX_DATA *room = ch->plr_home;
misc.c:     if ( !ch->in_room )
misc.c:     if ( IS_NPC(ch) || !ch->pcdata )
misc.c:     room = ch->in_room;
misc.c:     if ( ch->plr_home != room )
misc.c:      ch->gold += 10000;
misc.c:     ch->plr_home = NULL;
misc.c:     if ( !IS_IMMORTAL(ch) && ch->in_room && !IS_SET( ch->in_room->room_flags , ROOM_HOTEL ) && !NOT_AUTHED(ch) )
misc.c:     if ( ch->rppoints < 0 )
misc.c:       //ch->rppoints -= 4;
misc.c:     flags   = ch->act;
misc.c:     frc = ch->perm_frc;
misc.c:     frclevel = ch->skill_level[FORCE_ABILITY];
misc.c:     REMOVE_BIT( ch->act, PLR_KILLER );
misc.c:     credits = ch->gold;
misc.c:     ch->gold = 0;
misc.c:     played = ch->played;
misc.c:     ch->played = ch->played/2;
misc.c:     salary = ch->pcdata->salary;
misc.c:     bank = ch->pcdata->bank;
misc.c:     ch->pcdata->bank = 0;
misc.c:     ch->pcdata->salary = 0;
misc.c:     home = ch->plr_home;
misc.c:     if( ch->perm_frc > 0)
misc.c:	if( ch->skill_level[FORCE_ABILITY] > (ch->perm_frc-2)*5)
misc.c:	  ch->skill_level[FORCE_ABILITY] = (ch->perm_frc-2)*5;
misc.c:	ch->perm_frc = UMAX(0,ch->perm_frc-2);
misc.c:     ch->plr_home = NULL;
misc.c:     if ( ch->pcdata->clan_name && ch->pcdata->clan_name[0] != '\0' )
misc.c:         strcpy( clanname, ch->pcdata->clan_name);
misc.c:         STRFREE( ch->pcdata->clan_name );
misc.c:         ch->pcdata->clan_name = STRALLOC( "" );
misc.c:	 if(ch->pcdata->bestowments)
misc.c:           strcpy( bestowments, ch->pcdata->bestowments);
misc.c:           DISPOSE( ch->pcdata->bestowments );
misc.c:           ch->pcdata->bestowments = str_dup( "" );
misc.c:         STRFREE( ch->pcdata->clan_name );
misc.c:         ch->pcdata->clan_name = STRALLOC( clanname );
misc.c:           DISPOSE( ch->pcdata->bestowments );
misc.c:           ch->pcdata->bestowments = str_dup( bestowments );
misc.c:     ch->pcdata->salary = salary;
misc.c:     ch->plr_home = home;
misc.c:     ch->played = played;
misc.c:     ch->gold = credits;
misc.c:     ch->pcdata->bank = bank;     
misc.c:     ch->act = flags;
misc.c:     ch->perm_frc = frc;
misc.c:     ch->skill_level[FORCE_ABILITY] = frclevel;
misc.c:     ch->hit--;
misc.c:          if ( !IS_IMMORTAL(ch) && ch->in_room && !IS_SET( ch->in_room->room_flags , ROOM_HOTEL ) && !NOT_AUTHED(ch) )
misc.c:     if ( ch->rppoints < 0 )
misc.c:       //ch->rppoints -= 4;
misc.c:     flags   = ch->act;
misc.c:     frc = ch->perm_frc;
misc.c:     frclevel = ch->skill_level[FORCE_ABILITY];
misc.c:     REMOVE_BIT( ch->act, PLR_KILLER );
misc.c:     credits = ch->gold;
misc.c:     ch->gold = 0;
misc.c:     played = ch->played;
misc.c:     ch->played = ch->played/2;
misc.c:     bank = ch->pcdata->bank;
misc.c:     ch->pcdata->bank = 0;
misc.c:     home = ch->plr_home;
misc.c:     if( ch->perm_frc > 0)
misc.c:	if( ch->skill_level[FORCE_ABILITY] > (ch->perm_frc-2)*5)
misc.c:	  ch->skill_level[FORCE_ABILITY] = (ch->perm_frc-2)*5;
misc.c:	ch->perm_frc = UMAX(0,ch->perm_frc-2);
misc.c:     ch->plr_home = NULL;
misc.c:     if ( ch->pcdata->clan_name && ch->pcdata->clan_name[0] != '\0' )
misc.c:         strcpy( clanname, ch->pcdata->clan_name);
misc.c:         STRFREE( ch->pcdata->clan_name );
misc.c:         ch->pcdata->clan_name = STRALLOC( "" );
misc.c:         strcpy( bestowments, ch->pcdata->bestowments);
misc.c:         DISPOSE( ch->pcdata->bestowments );
misc.c:         ch->pcdata->bestowments = str_dup( "" );
misc.c:         STRFREE( ch->pcdata->clan_name );
misc.c:         ch->pcdata->clan_name = STRALLOC( clanname );
misc.c:         DISPOSE( ch->pcdata->bestowments );
misc.c:         ch->pcdata->bestowments = str_dup( clanname );
misc.c:     ch->plr_home = home;
misc.c:     ch->played = played;
misc.c:     ch->gold = credits;
misc.c:     ch->pcdata->bank = bank;     
misc.c:     ch->act = flags;
misc.c:     ch->perm_frc = frc;
misc.c:     ch->skill_level[FORCE_ABILITY] = frclevel;
misc.c:        for ( obj = ch->last_carrying; obj; obj = obj->prev_content )
misc.c:        for ( obj = ch->last_carrying; obj; obj = obj->prev_content )
misc.c:        for ( obj = ch->last_carrying; obj; obj = obj->prev_content )
misc.c:	if ( ch->fighting )
misc.c:    if ( ch->fighting && number_percent( ) > (get_curr_dex(ch) * 2 + 48) )
misc.c:	ch->pcdata->drug_level[drug] = UMIN(ch->pcdata->drug_level[drug]+obj->value[1] , 255);
misc.c:	if ( ch->pcdata->drug_level[drug] >=255 
misc.c:	     || ch->pcdata->drug_level[drug] > ( ch->pcdata->addiction[drug]+100 ) ) 
misc.c:	     ch->mental_state = URANGE( 20, ch->mental_state + 5, 100 );
misc.c:	     af.duration  = ch->pcdata->drug_level[drug];
misc.c:	     ch->hit = 1;
misc.c:	  	   af.duration  = URANGE( 1, ch->pcdata->drug_level[drug] - ch->pcdata->addiction[drug] ,obj->value[1] );
misc.c:	  	   af.duration  = URANGE( 1, ch->pcdata->drug_level[drug] - ch->pcdata->addiction[drug] ,obj->value[1] );
misc.c:	  	   af.duration  = URANGE( 1, 2*(ch->pcdata->drug_level[drug] - ch->pcdata->addiction[drug]) ,2*obj->value[1] );
misc.c:	  	   af.duration  = URANGE( 1, 2*(ch->pcdata->drug_level[drug] - ch->pcdata->addiction[drug]) ,2*obj->value[1] );
misc.c:	  	   af.duration  = URANGE( 1, 2*(ch->pcdata->drug_level[drug] - ch->pcdata->addiction[drug]) ,2*obj->value[1] );
misc.c:	  	   af.duration  = URANGE( 1, 2*(ch->pcdata->drug_level[drug] - ch->pcdata->addiction[drug]) ,2*obj->value[1] );
misc.c:        ch->max_mana++;
misc.c:        ch->max_mana++ ;
misc.c:        if (ch->max_hit > 100)
misc.c:   	  ch->max_hit--   ;
misc.c:   	ch->hit--   ;
misc.c:	for ( source = ch->in_room->first_content;
misc.c:		||    ch->carry_weight + get_obj_weight(source) > can_carry_w(ch)
misc.c:		   ch->gold += source->value[0];
misc.c:		||    ch->carry_weight + get_obj_weight(source) > can_carry_w(ch)
misc.c:		    if ( str_cmp( name, ch->name ) && !IS_IMMORTAL(ch) )
misc.c:			for ( gch = first_char; gch; gch = gch->next )
misc.c:			    &&   !str_cmp( name, gch->name ) )
misc.c:		    ||    ch->carry_number + otmp->count > can_carry_n(ch)
misc.c:		    ||    ch->carry_weight + get_obj_weight(otmp) > can_carry_w(ch)
misc.c:	for ( obj = ch->in_room->first_content; obj; obj = obj->next_content )
misc.c:    if ( !IS_NPC(ch) && ch->pcdata->condition[COND_DRUNK] > 40 )
misc.c:	    ch->pcdata->condition[COND_THIRST] = 40;
misc.c:	    if ( ch->pcdata->condition[COND_DRUNK]  > 24 )
misc.c:	    if ( ch->pcdata->condition[COND_DRUNK]  > 18 )
misc.c:	    if ( ch->pcdata->condition[COND_DRUNK]  > 12 )
misc.c:	    if ( ch->pcdata->condition[COND_DRUNK]  > 8 )
misc.c:	    if ( ch->pcdata->condition[COND_DRUNK]  > 5 )
misc.c:	    if ( ch->pcdata->condition[COND_FULL]   > 40 )
misc.c:	    if ( ch->pcdata->condition[COND_THIRST] > 40 )
misc.c:	    if ( ch->pcdata->condition[COND_THIRST] > 36 )
misc.c:	    if ( ch->pcdata->condition[COND_THIRST] > 30 )
misc.c:	    ch->mental_state = URANGE( 20, ch->mental_state + 5, 100 );
misc.c:    if ( IS_NPC(ch) || ch->pcdata->condition[COND_FULL] > 5 )
misc.c:	if ( !IS_NPC(ch) && ch->pcdata->condition[COND_FULL] > 40 )
misc.c:	    condition = ch->pcdata->condition[COND_FULL];
misc.c:	    if ( condition <= 1 && ch->pcdata->condition[COND_FULL] > 1 )
misc.c:	    else if ( ch->pcdata->condition[COND_FULL] > 40 )
misc.c:		ch->mental_state = URANGE( 20, ch->mental_state + 5, 100 );
misc.c:		ch->mental_state = URANGE( 15, ch->mental_state + 5, 100 );
misc.c:	    condition = ch->pcdata->condition[COND_FULL];
misc.c:	    if ( condition <= 1 && ch->pcdata->condition[COND_FULL] > 1 )
misc.c:	    else if ( ch->pcdata->condition[COND_FULL] > 40 )
misc.c:    && ( ch->pcdata->condition[COND_FULL] >= 48
misc.c:    ||   ch->pcdata->condition[COND_THIRST] >= 48 ) )
misc.c:    if ( ch->fighting && number_percent( ) > (get_curr_dex(ch) * 2 + 48) )
misc.c:      &&(ch->top_level + 10 < scroll->value[0]))
misc.c:	for ( rch = room->first_person; rch; rch = rch->next_in_room )
misc.c:	    &&   pexit_rev->to_room == ch->in_room )
misc.c:	    &&   pexit_rev->to_room == ch->in_room )
misc.c:	    for ( rch = room->first_person; rch; rch = rch->next_in_room )
misc.c:	    &&   pexit_rev->to_room == ch->in_room )
misc.c:		for ( rch = to_room->first_person; rch; rch = rch->next_in_room )
misc.c:	    for ( rch = room->first_person; rch; rch = rch->next_in_room )
misc.c:	    &&   pexit_rev->to_room == ch->in_room )
misc.c:		for ( rch = to_room->first_person; rch; rch = rch->next_in_room )
misc.c:		obj_cast_spell( sn, UMIN(skill->min_level, ch->top_level),
misc.c:		if ( IS_SET( ch->in_room->room_flags, ROOM_NODROP )
misc.c:		|| ( !IS_NPC(ch) &&  IS_SET( ch->act, PLR_LITTERBUG ) ) )
misc.c:		if ( IS_SET( ch->in_room->room_flags, ROOM_NODROPALL ) )
misc.c:		if ( empty_obj( obj, NULL, ch->in_room ) )
misc.c:    if ( !ch->in_room )
misc.c:    if ( ch->position < POS_FIGHTING )
misc.c:    if ( ch->position < POS_STANDING )
misc.c:    if ( IS_SET( ch->in_room->room_flags , ROOM_INDOORS ) )
misc.c:    if ( IS_SET( ch->in_room->room_flags , ROOM_SPACECRAFT ) )
misc.c:    if ( ch->gold < (ch->top_level-9)  )
misc.c:    if (!IS_NPC(ch) && IS_SET(ch->pcdata->act2, ACT_BOUND))
misc.c:    vnum = ch->in_room->vnum;
misc.c:    for ( vnum = ch->in_room->area->low_r_vnum  ;  vnum <= ch->in_room->area->hi_r_vnum  ;  vnum++ )
misc.c:    ch->gold -= UMAX(ch->top_level-9 , 0);
misc.c:    /*switch( ch->substate )
misc.c:	    	for ( mob = ch->in_room->first_person; mob; mob = mob->next_in_room )
misc.c:                      if( mob->perm_str <= ch->perm_str || ch->perm_str >= 20 + race_table[ch->race].str_plus || ch->perm_str >= 25 )
misc.c:                      if( mob->perm_dex <= ch->perm_dex || ch->perm_dex >= 20 + race_table[ch->race].dex_plus || ch->perm_dex >= 25 )
misc.c:                      if( mob->perm_int <= ch->perm_int || ch->perm_int >= 20 + race_table[ch->race].int_plus || ch->perm_int >= 25 )
misc.c:                      if( mob->perm_wis <= ch->perm_wis || ch->perm_wis >= 20 + race_table[ch->race].wis_plus || ch->perm_wis >= 25 )
misc.c:                      if( mob->perm_con <= ch->perm_con || ch->perm_con >= 20 + race_table[ch->race].con_plus || ch->perm_con >= 25 )
misc.c:                      if( mob->perm_cha <= ch->perm_cha || ch->perm_cha >= 20 + race_table[ch->race].cha_plus || ch->perm_cha >= 25 )
misc.c:    	    	//ch->dest_buf = str_dup(arg);
misc.c:    		if ( !ch->dest_buf )
misc.c:    		strcpy(arg, ch->dest_buf);
misc.c:    		DISPOSE( ch->dest_buf);
misc.c:    		DISPOSE( ch->dest_buf );
misc.c:    		ch->substate = SUB_NONE;
misc.c:    ch->substate = SUB_NONE;
misc.c:    	ch->perm_str++;
misc.c:    	ch->perm_dex++;
misc.c:    	ch->perm_int++;
misc.c:    	ch->perm_wis++;
misc.c:    	ch->perm_con++;
misc.c:    	ch->perm_cha++;
misc.c:        if ( IS_NPC(ch) || !ch->pcdata )
misc.c:        if ( strcmp( smaug_crypt( argument), ch->pcdata->pwd ) )
misc.c:	    sprintf( logbuf , "%s attempting to commit suicide... WRONG PASSWORD!" , ch->name );
misc.c:       sprintf(logbuf, "%s has commited suicide.", ch->name );
misc.c:    if ( IS_NPC(ch) || !ch->pcdata )
misc.c:    if (!ch->in_room || !IS_SET(ch->in_room->room_flags, ROOM_BANK) )
misc.c:       if ( ch->gold < amount )
misc.c:       ch->gold -= amount;
misc.c:       ch->pcdata->bank += amount;
misc.c:       if ( ch->pcdata->bank < amount )
misc.c:       ch->gold += amount;
misc.c:       ch->pcdata->bank -= amount;
misc.c:        ch_printf( ch , "Tienes %ld créditos en el banco.\n\r" , ch->pcdata->bank );
misc.c:       if ( ch->top_level <= 10)
misc.c:      if ( ch->pcdata->bank < amount )
misc.c:	sprintf( logbuf, "%s transfers %ld credits to %s", ch->name, amount, victim->name);
misc.c:        ch->pcdata->bank -= amount;
misc.c:	ch_printf( victim, "&W&G%s ha depositado %ld créditos en tu cuenta.\n\r", ch->name, amount);
misc.c:  if ( argument[0] == '\0' && ch->pcdata->last_name )
misc.c:    ch->pcdata->last_name = NULL;
misc.c:  if (!str_cmp(ch->pcdata->last_name, argument))
misc.c:  ch->pcdata->last_name = STRALLOC( argument );
misc.c:  if ((ship = ship_from_cockpit(ch->in_room->vnum)) == NULL){
misc.c:  if (ch->pcdata->clan == NULL) 
misc.c:  if (ch->pcdata->clan->troops < 1) 
misc.c:  if (num > ch->pcdata->clan->troops) 
misc.c:  if ( (ship = ship_from_cockpit(ch->in_room->vnum)) == NULL ) 
misc.c:  if (num > ch->pcdata->clan->troops) 
misc.c:    num = ch->pcdata->clan->troops; 
misc.c:    if ( ch->pcdata && ch->pcdata->clan ) 
misc.c:    sprintf( tmpbuf , "(%s) %s" , ch->pcdata->clan->name  , mob->long_descr ); 
misc.c:    mob->mob_clan = QUICKLINK(ch->pcdata->clan->name); 
misc.c:  ch->pcdata->clan->troops-=num; 
misc.c:   SHIP_DATA *ship2 = ship_from_cockpit( ch->in_room->vnum );
misc.c:   sprintf (buf1, "&g%s realiza algunos ajustes en el sistema de comunicación de la nave y dice:\n\r&C'&w%s&C'", ch->name, arg2);
misc.c:    if(ch->rppoints < 10)
misc.c:                ch->bonus[iClass] += 1;
misc.c:		sprintf(buf, "%s increased class %s with rpconvert.", ch->name, ability_name[iClass]);
misc.c:		ch->rppoints = ch->rppoints - 10;
misc.c:    if(ch->rppoints < 1)
misc.c:    if(ch->pcdata->learned[sn] < 1)
misc.c:    if(ch->pcdata->learned[sn] >= 100)
misc.c:    ch->pcdata->learned[sn] = UMIN(ch->pcdata->learned[sn] + 5, 100);
misc.c:    ch->rppoints -= 1;
misc.c:    sprintf(buf, "%s increased %s by 5%% with rpconvert.\n\r", ch->name, skill_table[sn]->name);
misc.c:    if ( IS_NPC(ch) || !ch->pcdata )
misc.c:    obj->armed_by = STRALLOC ( ch->name );
misc.c:    if ( IS_NPC(ch) || !ch->pcdata )
misc.c:	if ( ch->fighting )
misc.c:	if (!IS_SET(ch->in_room->room_flags,ROOM_PLR_HOME) )
misc.c:		if (ch->plr_home && ch->plr_home->vnum != ch->in_room->vnum )
misc.c:		if (ch->plr_home && ch->plr_home->vnum != ch->in_room->vnum) 
misc.c:	if ( !rch->buzzed || !rch->buzzedfrom )
misc.c:	if ( rch->buzzed != ch->in_room->vnum || rch->buzzedfrom != rch->in_room->vnum )
misc.c:	room = ch->in_room;
misc.c:	ch_printf( rch, "¡%s te invita a entrar!\n\r", ch->name );
misc.c:	ch_printf( ch, "¡Invitas a %s a entrar!\n\r", rch->name );
misc.c:	char_to_room( rch , ch->in_room );
misc.c:	if ( ch->fighting )
misc.c:	if ( ( pexit = get_exit(ch->in_room,get_dir(arg) )) != NULL)
misc.c:			&& pexit_rev->to_room == ch->in_room )
misc.c:			sprintf( buf, "¡%s usa el intercomunicador desde fuera!\n\r", ch->name );
misc.c:			ch->buzzedfrom = ch->in_room->vnum;
misc.c:			ch->buzzed = pexit->to_room->vnum;
misc.c:	if( !IS_SET(ch->in_room->room_flags, ROOM_BANK) )
misc.c:	        if( (ch->pcdata->bank - 1000) < 0)
misc.c:                if( (ch->pcdata->bank - 1000) < 1000)
misc.c:			ch->pcdata->bank -= 1000;
mud.h:#define IS_DROID(ch)		(ch->race == RACE_DROID || ch->race == RACE_PROTOCAL_DROID || ch->race == RACE_ASSASSIN_DROID  || ch->race == RACE_GLADIATOR_DROID || ch->race == RACE_ASTROMECH_DROID || ch->race == RACE_INTERROGATION_DROID)
mud.h:#define IS_RETIRED(ch) (ch->pcdata && IS_SET(ch->pcdata->flags,PCFLAG_RETIRED))
mud.h:#define IS_GUEST(ch) (ch->pcdata && IS_SET(ch->pcdata->flags,PCFLAG_GUEST))
mud.h:#define NOT_AUTHED(ch)		(!IS_NPC(ch) && ch->pcdata->auth_state <= 3  \
mud.h:			      && IS_SET(ch->pcdata->flags, PCFLAG_UNAUTHED) )
mud.h:#define HAS_SLUG(ch)		(!IS_NPC(ch) && IS_SET(ch->pcdata->flags, \
mud.h:#define IS_WAITING_FOR_AUTH(ch) (!IS_NPC(ch) && ch->desc		     \
mud.h:			      && ch->pcdata->auth_state == 1		     \
mud.h:			      && IS_SET(ch->pcdata->flags, PCFLAG_UNAUTHED) ) 
mud.h:#define DEBUG_FILE	SYSTEM_DIR "debug.txt"	  /* Catch-all for debug */
mud_comm.c:    if ( !( ch->in_room->progtypes ) )
mud_comm.c:	ch->in_room->name, ch->in_room->vnum );
mud_comm.c:    for ( mprg = ch->in_room->mudprogs; mprg; mprg = mprg->next )
mud_comm.c:    actflags = ch->act;
mud_comm.c:    REMOVE_BIT(ch->act, ACT_SECRETIVE);
mud_comm.c:    was_in_room = ch->in_room;
mud_comm.c:	   ch->in_room = pexit->to_room;
mud_comm.c:    ch->act = actflags;
mud_comm.c:    ch->in_room = was_in_room;
mud_comm.c:    if ( IS_AFFECTED( ch, AFF_CHARM ) && ch->master == victim )
mud_comm.c:    if ( ch->position == POS_FIGHTING )
mud_comm.c:    for ( obj = ch->first_carrying; obj; obj = obj_next )
mud_comm.c:    actflags = ch->act;
mud_comm.c:    REMOVE_BIT(ch->act, ACT_SECRETIVE);
mud_comm.c:    ch->act = actflags;
mud_comm.c:    actflags = ch->act;
mud_comm.c:    REMOVE_BIT(ch->act, ACT_SECRETIVE);
mud_comm.c:    ch->act = actflags;
mud_comm.c:    actflags = ch->act;
mud_comm.c:    REMOVE_BIT(ch->act, ACT_SECRETIVE);
mud_comm.c:    ch->act = actflags;
mud_comm.c:    char_to_room( victim, ch->in_room );
mud_comm.c:	obj_to_room( obj, ch->in_room );
mud_comm.c:	for ( victim = ch->in_room->first_person; victim; victim = vnext )
mud_comm.c:	while ( ch->in_room->first_content )
mud_comm.c:	   extract_obj( ch->in_room->first_content );
mud_comm.c:	ch->mobinvis = level;
mud_comm.c:    if ( ch->mobinvis < 2 )
mud_comm.c:      ch->mobinvis = ch->top_level;
mud_comm.c:    if ( IS_SET(ch->act, ACT_MOBINVIS) )
mud_comm.c:        REMOVE_BIT(ch->act, ACT_MOBINVIS);
mud_comm.c:        SET_BIT(ch->act, ACT_MOBINVIS);
mud_comm.c:    if ( ch->fighting )
mud_comm.c:    if ( ch->on )
mud_comm.c:       ch->on = NULL;
mud_comm.c:       ch->position = POS_STANDING;
mud_comm.c:    if (ch->position != POS_STANDING)
mud_comm.c:       ch->position = POS_STANDING;
mud_comm.c:    original = ch->in_room;
mud_comm.c:    for ( wch = first_char; wch; wch = wch->next )
mud_comm.c:    if ( !IS_NPC( ch ) || ( ch->desc && get_trust( ch ) < LEVEL_IMMORTAL )  )
mud_comm.c:      location = ch->in_room;
mud_comm.c:      for( victim = ch->in_room->first_person; victim; victim = nextinroom )
mud_comm.c:             || ch->in_room->area != d->character->in_room->area )
mud_comm.c:    if ( !IS_NPC( ch ) || ch->desc )
mud_comm.c:	for ( vch = ch->in_room->first_person; vch; vch = vch->next_in_room )
mud_comm.c:    if ( !IS_NPC( ch ) || ( ch->desc && get_trust( ch ) < LEVEL_IMMORTAL )  )
mud_comm.c:    if ( !IS_NPC( ch ) || ( ch->desc && get_trust( ch ) < LEVEL_IMMORTAL )  )
mud_comm.c:    if ( !IS_NPC( ch ) || ( ch->desc && get_trust( ch ) < LEVEL_IMMORTAL )  )
mud_comm.c:    if ( !IS_NPC( ch ) || ( ch->desc && get_trust( ch ) < LEVEL_IMMORTAL )  )
mud_comm.c:    if ( !IS_NPC( ch ) || ( ch->desc && get_trust( ch ) < LEVEL_IMMORTAL )  )
mud_comm.c:    if ( !IS_NPC( ch ) || ( ch->desc && get_trust( ch ) < LEVEL_IMMORTAL )  )
mud_comm.c:    if ( !IS_NPC( ch ) || ( ch->desc && get_trust( ch ) < LEVEL_IMMORTAL )  )
mud_comm.c:    if ( gold <= ch->gold && ch->in_room )
mud_comm.c:	ch->gold -= gold;
mud_comm.c:	boost_economy( ch->in_room->area, gold );
mud_comm.c:    if ( ch->gold < 1000000000 && gold < 1000000000 && ch->in_room
mud_comm.c:    &&   economy_has( ch->in_room->area, gold ) )
mud_comm.c:	ch->gold += gold;
mud_comm.c:	lower_economy( ch->in_room->area, gold );
mud_comm.c:		(IS_NPC(ch) ? ch->short_descr : ch->name),
mud_comm.c:    for ( rch = ch->in_room->first_person; rch; rch = rch->next_in_room )
mud_comm.c:	if ( (nifty_is_name( arg, rch->name )
mud_comm.c:	||  (IS_NPC(rch) && vnum == rch->pIndexData->vnum)) )
mud_comm.c:    for ( rch = ch->in_room->first_person; rch; rch = rch->next_in_room )
mud_comm.c:	if ( !nifty_is_name_prefix( arg, rch->name ) )
mud_prog.c:  for ( vch = mob->in_room->first_person; vch; vch = vch->next_in_room )
mud_prog.c:	if ( IS_NPC( ch ) && ch->pIndexData == mob->pIndexData )
mud_prog.c:      if ( IS_NPC( ch ) && ch->pIndexData == mob->pIndexData )
mud_prog.c:  if ( IS_NPC( ch ) && ch->pIndexData == mob->pIndexData )
mud_prog.c: sprintf( buf, "mprog_greet_trigger -> %s", ch->name );
mud_prog.c: for ( vmob = ch->in_room->first_person; vmob; vmob = vmob_next )
mud_prog.c:  if ( IS_NPC( ch ) && ch->pIndexData == vmob->pIndexData )
mud_prog.c:    if((room = ch->in_room) == NULL)
mud_prog.c:        for ( vobj = ch->first_carrying; vobj; vobj = vobj->next_content )
mud_prog.c:    if((room = ch->in_room) == NULL)
mud_prog.c:    if((room = ch->in_room) == NULL)
mud_prog.c:  for ( vobj=ch->in_room->first_content; vobj; vobj = vobj->next_content )
mud_prog.c:  for ( vobj=ch->in_room->first_content; vobj; vobj = vobj->next_content )
mud_prog.c:  if( ch->in_room->progtypes & LEAVE_PROG ) 
mud_prog.c:    rset_supermob( ch->in_room );
mud_prog.c:  if( ch->in_room->progtypes & ENTER_PROG ) 
mud_prog.c:    rset_supermob( ch->in_room );
mud_prog.c:  if( ch->in_room->progtypes & SLEEP_PROG ) 
mud_prog.c:    rset_supermob( ch->in_room );
mud_prog.c:  if( ch->in_room->progtypes & REST_PROG ) 
mud_prog.c:    rset_supermob( ch->in_room );
mud_prog.c:  if( ch->in_room->progtypes & RFIGHT_PROG ) 
mud_prog.c:    rset_supermob( ch->in_room );
mud_prog.c:  if( ch->in_room->progtypes & RDEATH_PROG ) 
mud_prog.c:    rset_supermob( ch->in_room );
mud_prog.c:  if( ch->in_room->progtypes & SPEECH_PROG ) 
mud_prog.c:    rprog_wordlist_check( txt, supermob, ch, NULL, NULL, SPEECH_PROG, ch->in_room );
mud_prog.c:  if ( ch->in_room->progtypes & RAND_PROG)
mud_prog.c:    rset_supermob( ch->in_room );
mud_prog.c:  if ( ch->in_room->progtypes & TIME_PROG )
mud_prog.c:    rset_supermob( ch->in_room );
mud_prog.c:    rprog_time_check( supermob, NULL, NULL, ch->in_room, TIME_PROG );
mud_prog.c:  if ( ch->in_room->progtypes & HOUR_PROG )
mud_prog.c:    rset_supermob( ch->in_room );
mud_prog.c:    rprog_time_check( supermob, NULL, NULL, ch->in_room, HOUR_PROG );
mud_prog.c:      if ( mpact->ch->in_room == room )
newarena.c:   else if (!(ch->betted_on = get_char_world_ooc(ch, arg)))
newarena.c:   else if (ch->betted_on == ch)
newarena.c:   else if(!(IS_SET(ch->betted_on->in_room->room_flags2, ROOM_ARENA)))
newarena.c:         GET_BETTED_ON(ch) = ch->betted_on;
newarena.c:         if (newbet > ch->gold)
newarena.c:         ch->gold -= newbet;
newarena.c:         sprintf(buf, "You place %d credits on %s.\r\n", newbet, ch->betted_on->name);
newarena.c:         sprintf(buf,"%s has placed %d credits on %s.", ch->name,
newarena.c:         newbet, ch->betted_on->name);
newarena.c: if(ch->top_level < lo_lim)
newarena.c: if( ch->top_level > hi_lim)
newarena.c: if(IS_SET(ch->in_room->room_flags2, ROOM_ARENA))
newarena.c:    location = ch->in_room;
newarena.c:    ch->pcdata->roomarena = location;
newarena.c:    sprintf(buf, "%s has joined the blood bath.", ch->name);
newarena.c:    ch->hit = ch->max_hit;
newarena.c:    ch->mana = ch->max_mana;
newarena.c:    ch->move = ch->max_move; 
newarena.c:	  phealth = (100 * tch->hit) / tch->max_hit;
newarena.c:          if (IS_SET(tch->in_room->room_flags2, ROOM_ARENA)
newarena.c:              && (tch->top_level < LEVEL_IMMORTAL))
newarena.c:             sprintf(buf2, "&W%12.12s         %d%%\n\r", tch->name, phealth);
newarena.c:          wch->gold += GET_BET_AMT(wch)*2;
newarena.c: if ((ch->top_level > LEVEL_IMMORTAL) || (victim->top_level > LEVEL_IMMORTAL))
newarena.c: if (victim->name == ch->name)
newarena.c: if(ch->pcdata->release_date != 0)
newarena.c: sprintf(buf,"&R%s &Whas challenged you to a duel!\n\r",ch->name);
newarena.c: sprintf(buf,"%s has challenged %s to a duel!!\n\r",ch->name,victim->name);
newarena.c: location = ch->in_room;
newarena.c: ch->pcdata->roomarena = location;
newarena.c:  if (!(ch->challenged))
newarena.c:    dch = ch->challenged;
newarena.c:	ch->challenged = NULL;
newarena.c:    location = ch->in_room;
newarena.c:    ch->pcdata->roomarena = location;
newarena.c:    sprintf(buf,"%s has accepted %s's challenge!",ch->name,dch->name);
newarena.c:    ch->challenged = NULL;
newarena.c: if (ch->challenged)
newarena.c:   sprintf(buf,"%s has DECLINED %s's challenge! WHAT A WUSS!!!\n\r",ch->name,ch->challenged->name);
newarena.c:   ch->challenged=NULL;
newarena.c:   sprintf(buf, "%s has been defeated in the arena!\n\r", ch->name );
pfiles.c:      sprintf( log_buf, "Manual pfile cleanup started by %s.", ch->name );
pfiles.c:      sprintf( log_buf, "Pfile count started by %s.", ch->name );
planets.c:   if ( !ch->in_room || !ch->in_room->area)
planets.c:   if ( IS_NPC(ch) || !ch->pcdata )
planets.c:   if ( !ch->pcdata->clan )
planets.c:   clan = ch->pcdata->clan;
planets.c:   if ( ( planet = ch->in_room->area->planet ) == NULL )
player.c:   ch_printf( ch,  "Tienes %d créditos.\n\r", ch->gold );
player.c:        if(IS_SET(victim->act, PLR_WIZINVIS) && victim->pcdata->wizinvis > ch->top_level)
player.c:    send_to_char(drawlife(ch->hit, ch->max_hit), ch);
player.c:    ch_printf(ch, "\n\rFicha de %s.\n\r", ch->pcdata->title);
player.c:    if ( get_trust( ch ) != ch->top_level )
player.c:	get_age(ch), capitalize(get_race(ch)), ctime(&(ch->logon)) );
player.c:		ch->save_time ? ctime(&(ch->save_time)) : "no\n" );
player.c:		ch->alignment, ch->wimpy  , ctime(&current_time) );
player.c:    if ( ch->skill_level[FORCE_ABILITY] > 1
player.c:            ch->hit, ch->max_hit, ch->move, ch->max_move, ch->mana, ch->max_mana );
player.c:            ch->hit, ch->max_hit, ch->move, ch->max_move);
player.c:          if ( ability != FORCE_ABILITY || ch->skill_level[FORCE_ABILITY] > 1 )
player.c:            ability_name[ability], ch->skill_level[ability], max_level(ch, ability), ch->experience[ability],
player.c:            exp_level( ch->skill_level[ability]+1 ) );
player.c:            ability_name[ability], ch->skill_level[ability], ch->experience[ability]);
player.c:	ch->gold, ch->pcdata->bank, ch->pcdata->pkills, ch->pcdata->mkills);
player.c:	ch->carry_weight, can_carry_w(ch) , ch->carry_number, can_carry_n(ch));
player.c:	IS_SET(ch->pcdata->flags, PCFLAG_PAGERON) ? 'X' : ' ',
player.c:	ch->pcdata->pagerlen, IS_SET(ch->act, PLR_AUTOEXIT) ? 'X' : ' ', 
player.c:	IS_SET(ch->act, PLR_AUTOLOOT) ? 'X' : ' ', IS_SET(ch->act, PLR_AUTOSAC) ? 'X' : ' ');
player.c:    switch (ch->position)
player.c:    if (!IS_NPC(ch) && ch->pcdata->condition[COND_DRUNK] > 10)
player.c:    if (!IS_NPC(ch) && ch->pcdata->condition[COND_THIRST] == 0)
player.c:    if (!IS_NPC(ch) && ch->pcdata->condition[COND_FULL] == 0)
player.c:    if ( ch->position != POS_SLEEPING )
player.c:	switch( ch->mental_state / 10 )
player.c:    if ( ch->mental_state >45 )
player.c:    if ( ch->mental_state >25 )
player.c:    if ( ch->mental_state <-35 )
player.c:    if ( ch->mental_state <-25 )
player.c:	if ( ch->pcdata->drug_level[drug] > 0 || ch->pcdata->drug_level[drug] > 0 )
player.c:	                                 ch->pcdata->drug_level[drug],
player.c:	                                 ch->pcdata->addiction[drug] );
player.c:	||  (IS_NPC(ch) && ch->speaks == 0) )
player.c:	    if ( lang_array[iLang] & ch->speaking
player.c:	    ||  (IS_NPC(ch) && !ch->speaking) )
player.c:             flag_string(ch->pcdata->wanted_flags, planet_flags) );
player.c:    if ( ch->pcdata->bestowments && ch->pcdata->bestowments[0] != '\0' )
player.c:		ch->pcdata->bestowments );
player.c:    if ( ch->pcdata->clan )
player.c:		ch->pcdata->clan->name, ch->pcdata->clan->pkills, ch->pcdata->clan->pdeaths) ;
player.c:		IS_SET(ch->act, PLR_WIZINVIS) ? "X" : " ", ch->pcdata->wizinvis );
player.c:	ch_printf(ch, "Bamfin:  %s\n\r", (ch->pcdata->bamfin[0] != '\0')
player.c:		? ch->pcdata->bamfin : "%s appears in a swirling mist.", ch->name);
player.c:	ch_printf(ch, "Bamfout: %s\n\r", (ch->pcdata->bamfout[0] != '\0')
player.c:		? ch->pcdata->bamfout : "%s leaves in a swirling mist.", ch->name);
player.c:	if (ch->pcdata->area)
player.c:		ch->pcdata->area->low_r_vnum, ch->pcdata->area->hi_r_vnum,
player.c:		ch->pcdata->area->low_o_vnum, ch->pcdata->area->hi_o_vnum,
player.c:		ch->pcdata->area->low_m_vnum, ch->pcdata->area->hi_m_vnum);
player.c:	    ch_printf(ch, "Area Loaded [%s]\n\r", (IS_SET (ch->pcdata->area->status, AREA_LOADED)) ? "yes" : "no");
player.c:    if (ch->first_affect)
player.c:	for (paf = ch->first_affect; paf; paf = paf->next)
player.c:	    if (ch->top_level < 20)
player.c:    if ( ch->race < MAX_NPC_RACE && ch->race >= 0)
player.c:	return ( npc_race[ch->race] );
player.c:	ch->name,
player.c:	IS_NPC(ch) ? "" : ch->pcdata->title,color_str(AT_OLDSCORE, ch),
player.c:	ch->top_level,
player.c:    if ( get_trust( ch ) != ch->top_level )
player.c:    if ( IS_SET(ch->act, ACT_MOBINVIS) )
player.c:            ch->mobinvis);
player.c:	ch->hit,  ch->max_hit,
player.c:	ch->move, ch->max_move);
player.c:	ch->carry_number, can_carry_n(ch),
player.c:	ch->carry_weight, can_carry_w(ch) );
player.c:	"You have have %d credits.\n\r" , ch->gold );
player.c:	ch->pcdata->quest_accum, ch->pcdata->quest_curr );
player.c:	(!IS_NPC(ch) && IS_SET(ch->act, PLR_AUTOEXIT)) ? "yes" : "no",
player.c:	(!IS_NPC(ch) && IS_SET(ch->act, PLR_AUTOLOOT)) ? "yes" : "no",
player.c:	(!IS_NPC(ch) && IS_SET(ch->act, PLR_AUTOSAC) ) ? "yes" : "no",
player.c:  	(!IS_NPC(ch) && IS_SET(ch->act, PLR_AUTOGOLD)) ? "yes" : "no" );
player.c:    ch_printf( ch, "Wimpy set to %d hit points.\n\r", ch->wimpy );
player.c:    if ( !IS_NPC(ch) && ch->pcdata->condition[COND_DRUNK]   > 10 )
player.c:    if ( !IS_NPC(ch) && ch->pcdata->condition[COND_THIRST] ==  0 )
player.c:    if ( !IS_NPC(ch) && ch->pcdata->condition[COND_FULL]   ==  0 )
player.c:    switch( ch->mental_state / 10 )
player.c:    switch ( ch->position )
player.c:    if ( ch->top_level >= 25 )
player.c:    if ( ch->top_level >= 15 )
player.c:    if ( ch->top_level >= 10 )
player.c:	ch_printf( ch, "Alignment: %d.  ", ch->alignment );
player.c:	 if ( ch->alignment >  900 ) send_to_char( "angelic.\n\r", ch );
player.c:    else if ( ch->alignment >  700 ) send_to_char( "saintly.\n\r", ch );
player.c:    else if ( ch->alignment >  350 ) send_to_char( "good.\n\r",    ch );
player.c:    else if ( ch->alignment >  100 ) send_to_char( "kind.\n\r",    ch );
player.c:    else if ( ch->alignment > -100 ) send_to_char( "neutral.\n\r", ch );
player.c:    else if ( ch->alignment > -350 ) send_to_char( "mean.\n\r",    ch );
player.c:    else if ( ch->alignment > -700 ) send_to_char( "evil.\n\r",    ch );
player.c:    else if ( ch->alignment > -900 ) send_to_char( "demonic.\n\r", ch );
player.c:    if ( ch->first_affect )
player.c:	for ( paf = ch->first_affect; paf; paf = paf->next )
player.c:	    if ( ch->top_level >= 20 )
player.c:			ch->pcdata->wizinvis,
player.c:			IS_SET( ch->act, PLR_WIZINVIS ) ? "ON" : "OFF" );
player.c:	if ( ch->pcdata->r_range_lo && ch->pcdata->r_range_hi )
player.c:	  ch_printf( ch, "Room Range: %d - %d\n\r", ch->pcdata->r_range_lo,
player.c:					 	   ch->pcdata->r_range_hi	);
player.c:	if ( ch->pcdata->o_range_lo && ch->pcdata->o_range_hi )
player.c:	  ch_printf( ch, "Obj Range : %d - %d\n\r", ch->pcdata->o_range_lo,
player.c:	  					   ch->pcdata->o_range_hi	);
player.c:	if ( ch->pcdata->m_range_lo && ch->pcdata->m_range_hi )
player.c:	  ch_printf( ch, "Mob Range : %d - %d\n\r", ch->pcdata->m_range_lo,
player.c:	  					   ch->pcdata->m_range_hi	);
player.c:            ch_printf( ch, "&G%-15s Nivel&W: %-3d    &GMax&W: %-3d    &GExp&W: %-10ld     &GSiguiente&W: %-10ld&W\n\r", ability_name[ability], ch->skill_level[ability], max_level(ch, ability), ch->experience[ability],
player.c:            exp_level( ch->skill_level[ability]+1 ) );
player.c:	ch_printf( ch, "%s\n\r", affect_bit_name( ch->affected_by ) );
player.c:        if ( ch->top_level >= 20 )
player.c:            if ( ch->resistant > 0 )
player.c:                ch_printf( ch, "%s\n\r", flag_string(ch->resistant, ris_flags) );
player.c:            if ( ch->immune > 0 )
player.c:                ch_printf( ch, "%s\n\r", flag_string(ch->immune, ris_flags) );
player.c:            if ( ch->susceptible > 0 )
player.c:                ch_printf( ch, "%s\n\r", flag_string(ch->susceptible, ris_flags) );
player.c:    if ( !ch->first_affect )
player.c:        for (paf = ch->first_affect; paf; paf = paf->next)
player.c:            if ( ch->top_level >= 20 )
player.c:    if(IS_IMMORTAL(ch) && ch->wait_state)
player.c:     ch_printf(ch, "Tu estado de espera: %d", ch->wait_state);
player.c:    show_list_to_char( ch->first_carrying, ch, TRUE, TRUE );
player.c:	for ( obj = ch->first_carrying; obj; obj = obj->next_content )
player.c:    STRFREE( ch->pcdata->title );
player.c:    ch->pcdata->title = STRALLOC( buf );
player.c:    if ( IS_SET( ch->pcdata->flags, PCFLAG_NOTITLE ))
player.c:    if ((get_trust(ch) <= LEVEL_IMMORTAL) && (!nifty_is_name(ch->name, remand(argument))))
player.c:	if ( !ch->pcdata->email )
player.c:	  ch->pcdata->email = str_dup( "" );
player.c:		show_tilde( ch->pcdata->email ) );
player.c:	if ( ch->pcdata->email )
player.c:	  DISPOSE(ch->pcdata->email);
player.c:	ch->pcdata->email = str_dup("");
player.c:    if ( ch->pcdata->email )
player.c:      DISPOSE(ch->pcdata->email);
player.c:    ch->pcdata->email = str_dup(buf);
player.c:	if ( !ch->pcdata->screenname )
player.c:	  ch->pcdata->screenname = str_dup( "" );
player.c:		show_tilde( ch->pcdata->screenname ) );
player.c:	if ( ch->pcdata->screenname )
player.c:	  DISPOSE(ch->pcdata->screenname);
player.c:	ch->pcdata->screenname = str_dup("");
player.c:    if ( ch->pcdata->screenname )
player.c:      DISPOSE(ch->pcdata->screenname);
player.c:    ch->pcdata->screenname = str_dup(buf);
player.c:	if ( !ch->pcdata->homepage )
player.c:	  ch->pcdata->homepage = str_dup( "" );
player.c:		show_tilde( ch->pcdata->homepage ) );
player.c:	if ( ch->pcdata->homepage )
player.c:	  DISPOSE(ch->pcdata->homepage);
player.c:	ch->pcdata->homepage = str_dup("");
player.c:    if ( ch->pcdata->homepage )
player.c:      DISPOSE(ch->pcdata->homepage);
player.c:    ch->pcdata->homepage = str_dup(buf);
player.c:	if ( !ch->pcdata->image )
player.c:	  ch->pcdata->image = str_dup( "" );
player.c:		show_tilde( ch->pcdata->image ) );
player.c:	if ( ch->pcdata->image )
player.c:	  DISPOSE(ch->pcdata->image);
player.c:	ch->pcdata->image = str_dup("");
player.c:    if ( ch->pcdata->image )
player.c:      DISPOSE(ch->pcdata->image);
player.c:    ch->pcdata->image = str_dup(buf);
player.c:    if ( !ch->desc )
player.c:    switch( ch->substate )
player.c:	   ch->substate = SUB_PERSONAL_DESC;
player.c:	   ch->dest_buf = ch;
player.c:	   start_editing( ch, ch->description );
player.c:	   editor_desc_printf( ch, "Your description (%s)", ch->name );
player.c:	   STRFREE( ch->description );
player.c:	   ch->description = copy_buffer( ch );
player.c:    if ( !ch->desc )
player.c:    switch( ch->substate )
player.c:	   ch->substate = SUB_PERSONAL_BIO;
player.c:	   ch->dest_buf = ch;
player.c:	   start_editing( ch, ch->pcdata->bio );
player.c:	   editor_desc_printf( ch, "Your bio (%s).", ch->name );
player.c:	   STRFREE( ch->pcdata->bio );
player.c:	   ch->pcdata->bio = copy_buffer( ch );
player.c:	color_str( AT_REPORT, ch), ch->hit,  ch->max_hit,
player.c:	ch->move, ch->max_move   );
player.c:	ch->hit,  ch->max_hit,
player.c:	ch->move, ch->max_move   );
player.c:  if (ch->pcdata->prompt)
player.c:    STRFREE(ch->pcdata->prompt);
player.c:    ch->pcdata->prompt = STRALLOC("");
player.c:    ch->pcdata->prompt = STRALLOC(argument);
renumber.c:	if( ch->top_level < LEVEL_SUB_IMPLEM )
renumber.c:	if( ch->top_level == LEVEL_SUB_IMPLEM )
renumber.c:		if( area->low_r_vnum < ch->pcdata->r_range_lo || area->hi_r_vnum > ch->pcdata->r_range_hi ||
renumber.c:			area->low_m_vnum < ch->pcdata->m_range_lo || area->hi_m_vnum > ch->pcdata->m_range_hi ||
renumber.c:			area->low_o_vnum < ch->pcdata->o_range_lo || area->hi_o_vnum > ch->pcdata->o_range_hi )
renumber.c:	if( ch->top_level == LEVEL_SUB_IMPLEM )
renumber.c:		if( r_area->low_room < ch->pcdata->r_range_lo || r_area->hi_room > ch->pcdata->r_range_hi ||
renumber.c:			r_area->low_obj < ch->pcdata->o_range_lo || r_area->hi_obj > ch->pcdata->o_range_hi ||
renumber.c:			r_area->low_mob < ch->pcdata->m_range_lo || r_area->hi_mob > ch->pcdata->m_range_hi )
reset.c: * pRoom->people, rch->carrying, obj->contains, and pArea->reset_first ..
reset.c:   for( rch = pRoom->first_person; rch; rch = rch->next_in_room )
reset.c:      add_reset( pRoom, 'M', 1, rch->pIndexData->vnum, rch->pIndexData->count, pRoom->vnum );
reset.c:      for( obj = rch->first_carrying; obj; obj = obj->next_content )
reset.c:   if( IS_NPC( ch ) || get_trust( ch ) < LEVEL_SAVIOR || !ch->pcdata->area )
reset.c:   if( !can_rmodify( ch, ch->in_room ) )
reset.c:   if( ch->in_room->area != ch->pcdata->area && get_trust( ch ) < LEVEL_GREATER )
reset.c:   if( ch->in_room->first_reset )
reset.c:      wipe_resets( ch->in_room );
reset.c:   instaroom( ch, ch->in_room, dodoors );
reset.c:   if( IS_NPC( ch ) || get_trust( ch ) < LEVEL_SAVIOR || !ch->pcdata->area )
reset.c:   pArea = ch->pcdata->area;
reset.c:      reset_area( ch->in_room->area );
reset.c:      for( pReset = ch->in_room->first_reset; pReset; pReset = pReset_next )
reset.c:            UNLINK( pReset, ch->in_room->first_reset, ch->in_room->last_reset, next, prev );
reset.c:      pReset = make_reset( 'R', 0, ch->in_room->vnum, vnum, 0 );
reset.c:      pReset->next = ch->in_room->first_reset;
reset.c:      if( ch->in_room->first_reset->prev )
reset.c:         ch->in_room->first_reset->prev = pReset;
reset.c:      ch->in_room->first_reset = pReset;
reset.c:      if( !ch->in_room->last_reset )
reset.c:         ch->in_room->last_reset = pReset;
reset.c:         vnum = ch->in_room->vnum;
reset.c:         if( !( pReset = find_oreset( ch->in_room, oname ) ) )
reset.c:         tReset->next = ch->in_room->first_reset;
reset.c:         if( ch->in_room->first_reset->prev )
reset.c:            ch->in_room->first_reset->prev = tReset;
reset.c:         ch->in_room->first_reset = tReset;
reset.c:         if( !ch->in_room->last_reset )
reset.c:            ch->in_room->last_reset = tReset;
reset.c:      if( !( pReset = find_oreset( ch->in_room, argument ) ) )
reset.c:         tReset->next = ch->in_room->first_reset;
reset.c:         if( ch->in_room->first_reset->prev )
reset.c:            ch->in_room->first_reset->prev = tReset;
reset.c:         ch->in_room->first_reset = tReset;
reset.c:         if( !ch->in_room->last_reset )
reset.c:            ch->in_room->last_reset = tReset;
save.c:    if ( ch->plr_home )
save.c:       	sprintf( filename, "%s%c/%s.home", PLAYER_DIR, tolower(ch->name[0]),
save.c:				 capitalize( ch->name ) );
save.c:		templvl = ch->top_level;
save.c:		ch->top_level = LEVEL_HERO;		/* make sure EQ doesn't get lost */
save.c:        	contents = ch->plr_home->last_content;
save.c:		ch->top_level = templvl;
save.c:    for ( obj = ch->first_carrying; obj; obj = obj->next_content )
save.c:			ch->name, MAX_LAYERS, obj->wear_loc, obj->name );
save.c:    if ( !IS_NPC(ch) && ch->pcdata->clan )
save.c:	save_clan( ch->pcdata->clan );
save.c:    if ( ch->desc && ch->desc->original )
save.c:	ch = ch->desc->original;
save.c:    ch->save_time = current_time;
save.c:    sprintf( strsave, "%s%c/%s", PLAYER_DIR, tolower(ch->name[0]),
save.c:				 capitalize( ch->name ) );
save.c:	sprintf( strback, "%s%c/%s", BACKUP_DIR, tolower(ch->name[0]),
save.c:				 capitalize( ch->name ) );
save.c:      sprintf( strback, "%s%s", GOD_DIR, capitalize( ch->name ) );
save.c:	fprintf( fp, "Level        %d\n", ch->top_level );
save.c:	fprintf( fp, "Pcflags      %d\n", ch->pcdata->flags );
save.c:	if ( ch->pcdata->r_range_lo && ch->pcdata->r_range_hi )
save.c:	  fprintf( fp, "RoomRange    %d %d\n", ch->pcdata->r_range_lo,
save.c:	  				       ch->pcdata->r_range_hi	);
save.c:	if ( ch->pcdata->o_range_lo && ch->pcdata->o_range_hi )
save.c:	  fprintf( fp, "ObjRange     %d %d\n", ch->pcdata->o_range_lo,
save.c:	  				       ch->pcdata->o_range_hi	);
save.c:	if ( ch->pcdata->m_range_lo && ch->pcdata->m_range_hi )
save.c:	  fprintf( fp, "MobRange     %d %d\n", ch->pcdata->m_range_lo,
save.c:	  				       ch->pcdata->m_range_hi	);
save.c:	if ( ch->first_carrying )
save.c:	  fwrite_obj( ch, ch->last_carrying, fp, 0, OS_CARRY, ch->pcdata->hotboot );
save.c:	if ( ch->comments )                 /* comments */
save.c:    if ( ch->desc && ch->desc->original )
save.c:	ch = ch->desc->original;
save.c:    ch->save_time = current_time;
save.c:    SET_BIT(ch->pcdata->act2, ACT_EXEMPT);
save.c:    sprintf( strsave, "%s%c/%s.clone", PLAYER_DIR, tolower(ch->name[0]),
save.c:				 capitalize( ch->name ) );
save.c:	sprintf( strback, "%s%c/%s", BACKUP_DIR, tolower(ch->name[0]),
save.c:				 capitalize( ch->name ) );
save.c:	if ( ch->comments )                 /* comments */
save.c:    REMOVE_BIT(ch->pcdata->act2, ACT_EXEMPT);
save.c:    fprintf( fp, "Name         %s~\n",	ch->name		);
save.c:	fprintf( fp, "Comfreq      %s~\n",  ch->comfreq   );
save.c:    if ( ch->short_descr && ch->short_descr[0] != '\0' )
save.c:      fprintf( fp, "ShortDescr   %s~\n",	ch->short_descr	);
save.c:    if ( ch->long_descr && ch->long_descr[0] != '\0' )
save.c:      fprintf( fp, "LongDescr    %s~\n",	ch->long_descr	);
save.c:    if ( ch->description && ch->description[0] != '\0' )
save.c:      fprintf( fp, "Description  %s~\n",	ch->description	);
save.c:    fprintf( fp, "Sex          %d\n",	ch->sex			);
save.c:    fprintf( fp, "Race         %d\n",	ch->race		);
save.c:    fprintf( fp, "MainAbility  %d\n",	ch->main_ability	);
save.c:    fprintf( fp, "SecondAbility  %d\n",	ch->secondary_ability	);
save.c:    fprintf( fp, "Languages    %d %d\n", ch->speaks, ch->speaking );
save.c:    fprintf( fp, "Toplevel     %d\n",	ch->top_level		);
save.c:    if ( ch->trust )
save.c:      fprintf( fp, "Trust        %d\n",	ch->trust		);
save.c:    fprintf( fp, "Pheight      %d\n",	ch->pheight		);
save.c:    fprintf( fp, "Build        %d\n",	ch->build		);
save.c:	ch->played + (int) (current_time - ch->logon)		);
save.c:    if (ch->in_room && (ship = ship_from_room (ch->in_room->vnum))) {
save.c:          if ( ch->in_room == sRoom )*/
save.c:      fprintf(fp, "ShipNum          %d\n", ch->in_room->exvnum);
save.c:	(  ch->in_room == get_room_index( ROOM_VNUM_LIMBO )
save.c:	&& ch->was_in_room )
save.c:	    ? ch->was_in_room->vnum
save.c:	    : ch->in_room->vnum );
save.c:    if ( ch->plr_home != NULL )
save.c:       fprintf( fp, "PlrHome      %d\n",          ch->plr_home->vnum );
save.c:	ch->hit, ch->max_hit, ch->move, ch->max_move );
save.c:    fprintf( fp, "Force        %d %d %d %d\n", ch->perm_frc, 0, ch->mana, ch->max_mana );
save.c:    fprintf( fp, "ForceControl %d\n",ch->force_control );
save.c:    fprintf( fp, "ForceSense   %d\n",ch->force_sense );
save.c:    fprintf( fp, "ForceAlter   %d\n",ch->force_alter );
save.c:    fprintf( fp, "ForceChance   %d\n",ch->force_chance );
save.c:    fprintf( fp, "ForceId      %d\n",ch->force_identified );
save.c:    fprintf( fp, "ForceAlign   %d\n",ch->force_align );
save.c:    fprintf( fp, "ForceConverted   %d\n",ch->force_converted );
save.c:    fprintf( fp, "ForceType      %d\n",ch->force_type );
save.c:    fprintf( fp, "ForceLvlStatus %d\n",ch->force_level_status );
save.c:    if ( ch->force_master && ch->force_master[0] != '\0' )
save.c:      fprintf( fp, "ForceMaster  %s~\n",	ch->force_master	);
save.c:        fprintf( fp, "ForceSkill   %d %d\n",ability,ch->force_skill[ability]);
save.c:    fprintf( fp, "Gold         %d\n",	ch->gold		);
save.c:    fprintf( fp, "Bank         %ld\n",	ch->pcdata->bank		);
save.c:    fprintf( fp, "Salary       %d\n",	ch->pcdata->salary		);
save.c:              ability , ch->skill_level[ability] , ch->experience[ability], ch->bonus[ability] );
save.c:    if ( ch->act )
save.c:      fprintf( fp, "Act          %d\n", ch->act			);
save.c:    if ( ch->pcdata->act2 )
save.c:      fprintf( fp, "Act2          %d\n", ch->pcdata->act2			);
save.c:    if ( ch->affected_by )
save.c:      fprintf( fp, "AffectedBy   %d\n",	ch->affected_by		);
save.c:        ch->position == POS_FIGHTING ? POS_STANDING : ch->position );
save.c:    		  ch->saving_poison_death,
save.c:		  ch->saving_wand,
save.c:    		  ch->saving_para_petri,
save.c:    		  ch->saving_breath,
save.c:    		  ch->saving_spell_staff			);
save.c:    fprintf( fp, "Alignment    %d\n",	ch->alignment		);
save.c:    fprintf( fp, "Glory        %d\n",   ch->pcdata->quest_curr  );
save.c:    fprintf( fp, "MGlory       %d\n",   ch->pcdata->quest_accum );
save.c:    fprintf( fp, "Hitroll      %d\n",	ch->hitroll		);
save.c:    fprintf( fp, "Damroll      %d\n",	ch->damroll		);
save.c:    fprintf( fp, "Armor        %d\n",	ch->armor		);
save.c:    if ( ch->rppoints )
save.c:      fprintf( fp, "Rppoints   %d\n",	ch->rppoints		);
save.c:    if ( ch->wimpy )
save.c:      fprintf( fp, "Wimpy        %d\n",	ch->wimpy		);
save.c:    if ( ch->deaf )
save.c:      fprintf( fp, "Deaf         %d\n",	ch->deaf		);
save.c:    if ( ch->resistant )
save.c:      fprintf( fp, "Resistant    %d\n",	ch->resistant		);
save.c:    if ( ch->immune )
save.c:      fprintf( fp, "Immune       %d\n",	ch->immune		);
save.c:    if ( ch->susceptible )
save.c:      fprintf( fp, "Susceptible  %d\n",	ch->susceptible		);
save.c:    if ( ch->pcdata && ch->pcdata->outcast_time )
save.c:      fprintf( fp, "Outcast_time %ld\n",ch->pcdata->outcast_time );
save.c:    if ( ch->pcdata && ch->pcdata->restore_time )
save.c:      fprintf( fp, "Restore_time %ld\n",ch->pcdata->restore_time );
save.c:    if ( ch->mental_state != -10 )
save.c:      fprintf( fp, "Mentalstate  %d\n",	ch->mental_state	);
save.c:	fprintf( fp, "Vnum         %d\n",	ch->pIndexData->vnum	);
save.c:        fprintf( fp, "Mobinvis     %d\n",	ch->mobinvis		);
save.c:	fprintf( fp, "Password     %s~\n",	ch->pcdata->pwd		);
save.c:	if ( ch->pcdata->bamfin && ch->pcdata->bamfin[0] != '\0' )
save.c:	  fprintf( fp, "Bamfin       %s~\n",	ch->pcdata->bamfin	);
save.c:	if ( ch->pcdata->email && ch->pcdata->email[0] != '\0' )
save.c:	  fprintf( fp, "Email       %s~\n",	ch->pcdata->email	);
save.c:	if ( ch->pcdata->bamfout && ch->pcdata->bamfout[0] != '\0' )
save.c:	  fprintf( fp, "Bamfout      %s~\n",	ch->pcdata->bamfout	);
save.c:	if ( ch->rank && ch->rank[0] != '\0' )
save.c:	  fprintf( fp, "Rank         %s~\n",	ch->rank	);
save.c:	if ( ch->pcdata->fiance && ch->pcdata->fiance[0] != '\0' )
save.c:	  fprintf( fp, "Fiance         %s~\n",	ch->pcdata->fiance	);
save.c:	if ( ch->pcdata->last_name && ch->pcdata->last_name[0] != '\0' )
save.c:	  fprintf( fp, "Lastname         %s~\n",	ch->pcdata->last_name	);
save.c:	if ( ch->pcdata->spouse && ch->pcdata->spouse[0] != '\0' )
save.c:	  fprintf( fp, "Spouse         %s~\n",	ch->pcdata->spouse	);
save.c:	if (ch->pcdata->forcerank)
save.c:	  fprintf( fp, "forcerank  %d\n", 	ch->pcdata->forcerank );
save.c:	if ( ch->pcdata->bestowments && ch->pcdata->bestowments[0] != '\0' )
save.c:	  fprintf( fp, "Bestowments  %s~\n", 	ch->pcdata->bestowments );
save.c:	fprintf( fp, "Title        %s~\n",	ch->pcdata->title	);
save.c:	if ( ch->pcdata->disguise && ch->pcdata->disguise[0] != '\0' )
save.c:	 fprintf( fp, "Disguise     %s~\n",	ch->pcdata->disguise	);
save.c:	if ( ch->pcdata->homepage && ch->pcdata->homepage[0] != '\0' )
save.c:	  fprintf( fp, "Homepage     %s~\n",	ch->pcdata->homepage	);
save.c:	if ( ch->pcdata->screenname && ch->pcdata->screenname[0] != '\0' )
save.c:	  fprintf( fp, "Screenname   %s~\n",	ch->pcdata->screenname	);
save.c:	if ( ch->pcdata->image && ch->pcdata->image[0] != '\0' )
save.c:	  fprintf( fp, "Image        %s~\n",	ch->pcdata->image	);
save.c:	if ( ch->pcdata->bio && ch->pcdata->bio[0] != '\0' )
save.c:	  fprintf( fp, "Bio          %s~\n",	ch->pcdata->bio 	);
save.c:	if ( ch->pcdata->authed_by && ch->pcdata->authed_by[0] != '\0' )
save.c:	  fprintf( fp, "AuthedBy     %s~\n",	ch->pcdata->authed_by	);
save.c:	if ( ch->pcdata->min_snoop )
save.c:	  fprintf( fp, "Minsnoop     %d\n",	ch->pcdata->min_snoop	);
save.c:	if ( ch->pcdata->prompt && *ch->pcdata->prompt )
save.c:	  fprintf( fp, "Prompt       %s~\n",	ch->pcdata->prompt	);
save.c:	if ( ch->pcdata->pagerlen != 24 )
save.c:	  fprintf( fp, "Pagerlen     %d\n",	ch->pcdata->pagerlen	);
save.c:	  fprintf( fp, " %d",	ch->pcdata->addiction[drug] );
save.c:	  fprintf( fp, " %d",	ch->pcdata->drug_level[drug] );
save.c:	if ( ch->pcdata->wanted_flags )
save.c:	  fprintf( fp, "Wanted       %d\n",	ch->pcdata->wanted_flags );
save.c:	if ( IS_IMMORTAL( ch ) || ch->pcdata->area )
save.c:	  fprintf( fp, "WizInvis     %d\n", ch->pcdata->wizinvis );
save.c:	  if ( ch->pcdata->r_range_lo && ch->pcdata->r_range_hi )
save.c:	    fprintf( fp, "RoomRange    %d %d\n", ch->pcdata->r_range_lo,
save.c:	  					 ch->pcdata->r_range_hi	);
save.c:	  if ( ch->pcdata->o_range_lo && ch->pcdata->o_range_hi )
save.c:	    fprintf( fp, "ObjRange     %d %d\n", ch->pcdata->o_range_lo,
save.c:	  					 ch->pcdata->o_range_hi	);
save.c:	  if ( ch->pcdata->m_range_lo && ch->pcdata->m_range_hi )
save.c:	    fprintf( fp, "MobRange     %d %d\n", ch->pcdata->m_range_lo,
save.c:	  					 ch->pcdata->m_range_hi	);
save.c:	if ( ch->pcdata->clan_name && ch->pcdata->clan_name[0] != '\0' )
save.c:	  fprintf( fp, "Clan         %s~\n",	ch->pcdata->clan_name	);
save.c:        fprintf( fp, "Flags        %d\n",	ch->pcdata->flags	);
save.c:        if ( ch->pcdata->release_date > current_time )
save.c:        	(int)ch->pcdata->release_date, ch->pcdata->helled_by );
save.c:	if ( ch->pcdata->pkills )
save.c:	  fprintf( fp, "PKills       %d\n",	ch->pcdata->pkills	);
save.c:	if ( ch->pcdata->pdeaths )
save.c:	  fprintf( fp, "PDeaths      %d\n",	ch->pcdata->pdeaths	);
save.c:        fprintf( fp, "MKills       %d\n",	ch->pcdata->mkills	);
save.c:	fprintf( fp, "MDeaths      %d\n",	ch->pcdata->mdeaths	);
save.c:	if ( ch->pcdata->illegal_pk )
save.c:	  fprintf( fp, "IllegalPK    %d\n",	ch->pcdata->illegal_pk	);
save.c:	    ch->perm_str,
save.c:	    ch->perm_int,
save.c:	    ch->perm_wis,
save.c:	    ch->perm_dex,
save.c:	    ch->perm_con,
save.c:	    ch->perm_cha,
save.c:	    ch->perm_lck );
save.c:	    ch->mod_str, 
save.c:	    ch->mod_int, 
save.c:	    ch->mod_wis,
save.c:	    ch->mod_dex, 
save.c:	    ch->mod_con,
save.c:	    ch->mod_cha, 
save.c:	    ch->mod_lck );
save.c:	    ch->pcdata->condition[0],
save.c:	    ch->pcdata->condition[1],
save.c:	    ch->pcdata->condition[2],
save.c:	    ch->pcdata->condition[3] );
save.c:	if ( ch->desc && ch->desc->host )
save.c:            fprintf( fp, "Site         %s\n", ch->desc->host );
save.c:	    if ( skill_table[sn]->name && ch->pcdata->learned[sn] > 0 )
save.c:			  ch->pcdata->learned[sn], skill_table[sn]->name );
save.c:			  ch->pcdata->learned[sn], skill_table[sn]->name );
save.c:			  ch->pcdata->learned[sn], skill_table[sn]->name );
save.c:			  ch->pcdata->learned[sn], skill_table[sn]->name );
save.c:    for(bug=ch->first_bug;bug;bug=bug->next_in_bug)
save.c:    for(contract=ch->first_contract;contract;contract=contract->next_in_contract)
save.c:    for(fellow=ch->first_fellow;fellow;fellow=fellow->next)
save.c:    for ( paf = ch->first_affect; paf; paf = paf->next )
save.c:    track = URANGE( 2, ((ch->top_level+3) * MAX_KILLTRACK)/LEVEL_AVATAR, MAX_KILLTRACK );
save.c:	if ( ch->pcdata->killed[sn].vnum == 0 )
save.c:		ch->pcdata->killed[sn].vnum,
save.c:		ch->pcdata->killed[sn].count );
save.c:            fprintf( fp, "%d ", ch->colors[x] );
save.c:   CREATE( ch->pcdata, PC_DATA, 1 );
save.c:   ch->desc = d;
save.c:   ch->name = STRALLOC( name );
save.c:   ch->act = PLR_BLANK | PLR_COMBINE | PLR_PROMPT;
save.c:   ch->perm_str = 10;
save.c:   ch->perm_int = 10;
save.c:   ch->perm_wis = 10;
save.c:   ch->perm_dex = 10;
save.c:   ch->perm_con = 10;
save.c:   ch->perm_cha = 10;
save.c:   ch->perm_lck = 10;
save.c:   ch->pcdata->condition[COND_THIRST] = 48;
save.c:   ch->pcdata->condition[COND_FULL] = 48;
save.c:   ch->pcdata->condition[COND_BLOODTHIRST] = 10;
save.c:   ch->pcdata->wizinvis = 0;
save.c:   ch->mental_state = -10;
save.c:   ch->mobinvis = 0;
save.c:      ch->pcdata->learned[i] = 0;
save.c:   ch->pcdata->release_date = 0;
save.c:   ch->pcdata->helled_by = NULL;
save.c:   ch->saving_poison_death = 0;
save.c:   ch->saving_wand = 0;
save.c:   ch->saving_para_petri = 0;
save.c:   ch->saving_breath = 0;
save.c:   ch->saving_spell_staff = 0;
save.c:   ch->comments = NULL; /* comments */
save.c:   ch->pcdata->pagerlen = 24;
save.c:   ch->mob_clan = STRALLOC( "" );
save.c:   ch->was_sentinel = NULL;
save.c:   ch->plr_home = NULL;
save.c:   ch->pheight = 0;
save.c:   ch->build = 0;
save.c:   ch->pcdata->hotboot = FALSE; /* Never changed except when PC is saved during hotboot save */
save.c:                  preload ? "Preloading" : "Loading", ch->name, ( int )fst.st_size / 1024 );
save.c:      ch->short_descr = STRALLOC( "" );
save.c:      ch->long_descr = STRALLOC( "" );
save.c:      ch->description = STRALLOC( "" );
save.c:      ch->editor = NULL;
save.c:      ch->pcdata->clan_name = STRALLOC( "" );
save.c:      ch->pcdata->clan = NULL;
save.c:      ch->pcdata->pwd = str_dup( "" );
save.c:      ch->pcdata->email = str_dup( "" );
save.c:      ch->pcdata->bamfin = str_dup( "" );
save.c:      ch->pcdata->bamfout = str_dup( "" );
save.c:      ch->rank = str_dup( "" );
save.c:      ch->pcdata->shipname = STRALLOC( "" );
save.c:      ch->pcdata->bestowments = str_dup( "" );
save.c:      ch->pcdata->title = STRALLOC( "" );
save.c:      ch->pcdata->disguise = STRALLOC( "" );
save.c:      ch->pcdata->homepage = str_dup( "" );
save.c:      ch->pcdata->screenname = str_dup( "" );
save.c:      ch->pcdata->image = str_dup( "" );
save.c:      ch->pcdata->bio = STRALLOC( "" );
save.c:      ch->pcdata->authed_by = STRALLOC( "" );
save.c:      ch->pcdata->prompt = STRALLOC( "" );
save.c:      ch->pcdata->r_range_lo = 0;
save.c:      ch->pcdata->r_range_hi = 0;
save.c:      ch->pcdata->m_range_lo = 0;
save.c:      ch->pcdata->m_range_hi = 0;
save.c:      ch->pcdata->o_range_lo = 0;
save.c:      ch->pcdata->o_range_hi = 0;
save.c:      ch->pcdata->wizinvis = 0;
save.c:      ch->pcdata->wanted_flags = 0;
save.c:      if( !ch->pcdata->clan_name )
save.c:         ch->pcdata->clan_name = STRALLOC( "" );
save.c:         ch->pcdata->clan = NULL;
save.c:      if( !ch->pcdata->bio )
save.c:         ch->pcdata->bio = STRALLOC( "" );
save.c:      if( !ch->pcdata->authed_by )
save.c:         ch->pcdata->authed_by = STRALLOC( "" );
save.c:         if( ch->pcdata->wizinvis < 2 )
save.c:            ch->pcdata->wizinvis = ch->top_level;
save.c:    memcpy( &ch->colors, &default_set, sizeof(default_set) );
save.c:	    KEY( "Act",		ch->act,		fread_number( fp ) );
save.c:            if ( IS_SET(ch->act, ACT_MOUNTED ) ) 
save.c:                REMOVE_BIT(ch->act, ACT_MOUNTED); 
save.c:	    KEY( "Act2",	ch->pcdata->act2,		fread_number( fp ) );
save.c:	    KEY( "AffectedBy",	ch->affected_by,	fread_number( fp ) );
save.c:	    KEY( "Alignment",	ch->alignment,		fread_number( fp ) );
save.c:	    KEY( "Armor",	ch->armor,		fread_number( fp ) );
save.c:		ch->pcdata->addiction[0] = x0;
save.c:		ch->pcdata->addiction[1] = x1;
save.c:		ch->pcdata->addiction[2] = x2;
save.c:		ch->pcdata->addiction[3] = x3;
save.c:		ch->pcdata->addiction[4] = x4;
save.c:		ch->pcdata->addiction[5] = x5;
save.c:		ch->pcdata->addiction[6] = x6;
save.c:		ch->pcdata->addiction[7] = x7;
save.c:		ch->pcdata->addiction[8] = x8;
save.c:		ch->pcdata->addiction[9] = x9;
save.c:		      ch->skill_level[x0] = x1;
save.c:		      ch->experience[x0] = x2;
save.c:		      ch->bonus[x0] = x3;
save.c:		LINK(paf, ch->first_affect, ch->last_affect, next, prev );
save.c:		ch->mod_str = x1;
save.c:		ch->mod_int = x2;
save.c:		ch->mod_wis = x3;
save.c:		ch->mod_dex = x4;
save.c:		ch->mod_con = x5;
save.c:		ch->mod_cha = x6;
save.c:		ch->mod_lck = x7;
save.c:		ch->mod_lck = 0;
save.c:		ch->perm_str = x1;
save.c:		ch->perm_int = x2;
save.c:		ch->perm_wis = x3;
save.c:		ch->perm_dex = x4;
save.c:		ch->perm_con = x5;
save.c:		ch->perm_cha = x6;
save.c:		ch->perm_lck = x7;
save.c:		  ch->perm_lck = 13;
save.c:	    KEY( "AuthedBy",	ch->pcdata->authed_by,	fread_string( fp ) );
save.c:	    	LINK(bug, ch->first_bug, ch->last_bug, next_in_bug, prev_in_bug);
save.c:	    KEY( "Bamfin",	ch->pcdata->bamfin,	fread_string_nohash( fp ) );
save.c:	    KEY( "Bamfout",	ch->pcdata->bamfout,	fread_string_nohash( fp ) );
save.c:	    KEY( "Bestowments", ch->pcdata->bestowments, fread_string_nohash( fp ) );
save.c:	    KEY( "Bio",		ch->pcdata->bio,	fread_string( fp ) );
save.c:	    KEY( "Bank",	ch->pcdata->bank,	fread_number( fp ) );
save.c:	    KEY( "Build",	ch->build,		fread_number( fp ) );
save.c:		 ch->comfreq = fread_string(fp);
save.c:		ch->pcdata->clan_name = fread_string( fp );
save.c:		&&   ch->pcdata->clan_name[0] != '\0'
save.c:		&& ( ch->pcdata->clan = get_clan( ch->pcdata->clan_name )) == NULL )
save.c:		           ch->pcdata->clan_name );
save.c:		  STRFREE( ch->pcdata->clan_name );
save.c:		  ch->pcdata->clan_name = STRALLOC( "" );
save.c:		ch->pcdata->condition[0] = x1;
save.c:		ch->pcdata->condition[1] = x2;
save.c:		ch->pcdata->condition[2] = x3;
save.c:		ch->pcdata->condition[3] = x4;
save.c:                  ch->colors[x] = fread_number( fp );
save.c:                LINK(contract, ch->first_contract, ch->last_contract, next_in_contract, prev_in_contract);
save.c:	    KEY( "Damroll",	ch->damroll,		fread_number( fp ) );
save.c:	    KEY( "Deaf",	ch->deaf,		fread_number( fp ) );
save.c:	    KEY( "Description",	ch->description,	fread_string( fp ) );
save.c:	    KEY( "Disguise",	ch->pcdata->disguise,	fread_string( fp ) );
save.c:		ch->pcdata->drug_level[0] = x0;
save.c:		ch->pcdata->drug_level[1] = x1;
save.c:		ch->pcdata->drug_level[2] = x2;
save.c:		ch->pcdata->drug_level[3] = x3;
save.c:		ch->pcdata->drug_level[4] = x4;
save.c:		ch->pcdata->drug_level[5] = x5;
save.c:		ch->pcdata->drug_level[6] = x6;
save.c:		ch->pcdata->drug_level[7] = x7;
save.c:		ch->pcdata->drug_level[8] = x8;
save.c:		ch->pcdata->drug_level[9] = x9;
save.c:	    KEY( "Flags",	ch->pcdata->flags,	fread_number( fp ) );
save.c:            KEY( "ForceControl",ch->force_control,      fread_number( fp ) );
save.c:            KEY( "ForceSense",ch->force_sense,          fread_number( fp ) );
save.c:            KEY( "ForceAlter",ch->force_alter,          fread_number( fp ) );
save.c:            KEY( "ForceChance",ch->force_chance,          fread_number( fp ) );
save.c:            KEY( "ForceId",ch->force_identified,          fread_number( fp ) );
save.c:            KEY( "ForceType",ch->force_type,          fread_number( fp ) );
save.c:            KEY( "ForceAlign",ch->force_align,          fread_number( fp ) );
save.c:            KEY( "ForceConverted",ch->force_converted,          fread_number( fp ) );
save.c:            KEY( "ForceLvlStatus",ch->force_level_status,          fread_number( fp ) );
save.c:	    KEY( "ForceMaster",	ch->force_master,	fread_string( fp ) );
save.c:		ch->perm_frc = x1;
save.c:		ch->mana = x3;
save.c:		ch->max_mana = x4;
save.c:            	  ch->force_skill[x1] = x2;
save.c:	    KEY( "forcerank",	ch->pcdata->forcerank,	fread_number( fp ) );
save.c:	    KEY( "Fiance",	ch->pcdata->fiance,	fread_string( fp ) );
save.c:		//sprintf(buf, "Player %s knows %s as %s.", ch->name, victim, knownas);
save.c:                LINK(fellow, ch->first_fellow, ch->last_fellow, next, prev);
save.c:	    KEY( "Glory",       ch->pcdata->quest_curr, fread_number( fp ) );
save.c:	    KEY( "Gold",	ch->gold,		fread_number( fp ) );
save.c:		ch->pcdata->clan_name = fread_string( fp );
save.c:		&&   ch->pcdata->clan_name[0] != '\0'
save.c:		&& ( ch->pcdata->clan = get_clan( ch->pcdata->clan_name )) == NULL )
save.c:		           ch->pcdata->clan_name );
save.c:		  STRFREE( ch->pcdata->clan_name );
save.c:		  ch->pcdata->clan_name = STRALLOC( "" );
save.c:	      ch->pcdata->release_date = fread_number(fp);
save.c:	      ch->pcdata->helled_by = fread_string(fp);
save.c:	      if ( ch->pcdata->release_date < current_time )
save.c:	        STRFREE(ch->pcdata->helled_by);
save.c:	        ch->pcdata->helled_by = NULL;
save.c:	        ch->pcdata->release_date = 0;
save.c:	    KEY( "Hitroll",	ch->hitroll,		fread_number( fp ) );
save.c:	    KEY( "Homepage",	ch->pcdata->homepage,	fread_string_nohash( fp ) );
save.c:		ch->hit = x1;
save.c:		ch->max_hit = x2;
save.c:		ch->move = x5;
save.c:		ch->max_move = x6;
save.c:                   ch->perm_frc = number_range( 1 , 20 );
save.c:                   ch->max_mana = x4;
save.c:                   ch->mana     = x4;
save.c:                   ch->perm_frc = 1;
save.c:		   ch->max_mana = x4;
save.c:	    KEY( "IllegalPK",	ch->pcdata->illegal_pk,	fread_number( fp ) );
save.c:	    KEY( "Image",	ch->pcdata->image,	fread_string_nohash( fp ) );
save.c:	    KEY( "Immune",	ch->immune,		fread_number( fp ) );
save.c:		    ch->pcdata->killed[killcnt].vnum    = fread_number( fp );
save.c:		    ch->pcdata->killed[killcnt++].count = fread_number( fp );
save.c:	    KEY( "Lastname",	ch->pcdata->last_name,	fread_string( fp ) );
save.c:	    KEY( "LongDescr",	ch->long_descr,		fread_string( fp ) );
save.c:	    	ch->speaks = fread_number( fp );
save.c:	    	ch->speaking = fread_number( fp );
save.c:	    KEY( "MainAbility",	ch->main_ability,	fread_number( fp ) );
save.c:	    KEY( "MDeaths",	ch->pcdata->mdeaths,	fread_number( fp ) );
save.c:	    KEY( "Mentalstate", ch->mental_state,	fread_number( fp ) );
save.c:	    KEY( "MGlory",      ch->pcdata->quest_accum,fread_number( fp ) );
save.c:	    KEY( "Minsnoop",	ch->pcdata->min_snoop,	fread_number( fp ) );
save.c:	    KEY( "MKills",	ch->pcdata->mkills,	fread_number( fp ) );
save.c:	    KEY( "Mobinvis",	ch->mobinvis,		fread_number( fp ) );
save.c:		ch->pcdata->m_range_lo = fread_number( fp );
save.c:		ch->pcdata->m_range_hi = fread_number( fp );
save.c:	    KEY( "Outcast_time", ch->pcdata->outcast_time, fread_number( fp ) );
save.c:		ch->pcdata->o_range_lo = fread_number( fp );
save.c:		ch->pcdata->o_range_hi = fread_number( fp );
save.c:	    KEY( "Pagerlen",	ch->pcdata->pagerlen,	fread_number( fp ) );
save.c:	    KEY( "Password",	ch->pcdata->pwd,	fread_string_nohash( fp ) );
save.c:	    KEY( "PDeaths",	ch->pcdata->pdeaths,	fread_number( fp ) );
save.c:	    KEY( "Pheight",	ch->pheight,		fread_number( fp ) );
save.c:	    KEY( "PKills",	ch->pcdata->pkills,	fread_number( fp ) );
save.c:	    KEY( "Played",	ch->played,		fread_number( fp ) );
save.c:	    KEY( "Position",	ch->position,		fread_number( fp ) );
save.c:	    KEY( "Prompt",	ch->pcdata->prompt,	fread_string( fp ) );
save.c:		ch->plr_home = get_room_index( fread_number( fp ) );
save.c:		if ( !ch->plr_home )
save.c:		    ch->plr_home = NULL;
save.c:	    KEY( "Race",        ch->race,		fread_number( fp ) );
save.c:	    KEY( "Rank",        ch->rank,		fread_string_nohash( fp ) );
save.c:	    KEY( "Resistant",	ch->resistant,		fread_number( fp ) );
save.c:	    KEY( "Restore_time",ch->pcdata->restore_time, fread_number( fp ) );
save.c:	    KEY( "Rppoints",	ch->rppoints,		fread_number( fp ) );
save.c:		ch->in_room = get_room_index( fread_number( fp ) );
save.c:		if ( !ch->in_room )
save.c:		    ch->in_room = get_room_index( ROOM_VNUM_LIMBO );
save.c:		ch->pcdata->r_range_lo = fread_number( fp );
save.c:		ch->pcdata->r_range_hi = fread_number( fp );
save.c:	    KEY( "Salary",	ch->pcdata->salary,	fread_number( fp ) );
save.c:	    KEY( "Screenname",	ch->pcdata->screenname,	fread_string_nohash( fp ) );
save.c:	    KEY( "Sex",		ch->sex,		fread_number( fp ) );
save.c:	    KEY( "ShipNum",		ch->pcdata->shipnum,		fread_number( fp ) );
save.c:	    KEY( "Ship",		ch->pcdata->shipname,		fread_string( fp ) );
save.c:	    KEY( "SecondAbility",	ch->secondary_ability,		fread_number( fp ) );
save.c:	    KEY( "ShortDescr",	ch->short_descr,	fread_string( fp ) );
save.c:	    KEY( "Spouse",	ch->pcdata->spouse,		fread_string( fp ) );
save.c:	    KEY( "Susceptible",	ch->susceptible,	fread_number( fp ) );
save.c:		ch->saving_wand 	= fread_number( fp );
save.c:		ch->saving_poison_death = ch->saving_wand;
save.c:		ch->saving_para_petri 	= ch->saving_wand;
save.c:		ch->saving_breath 	= ch->saving_wand;
save.c:		ch->saving_spell_staff 	= ch->saving_wand;
save.c:		ch->saving_poison_death = fread_number( fp );
save.c:		ch->saving_wand 	= fread_number( fp );
save.c:		ch->saving_para_petri 	= fread_number( fp );
save.c:		ch->saving_breath 	= fread_number( fp );
save.c:		ch->saving_spell_staff 	= fread_number( fp );
save.c:	          ch->gold = ch->gold + 20000;
save.c:		    ch->pcdata->learned[sn] = value;
save.c:		    ch->pcdata->learned[sn] = value;
save.c:		if (!ch->short_descr)
save.c:		  ch->short_descr	= STRALLOC( "" );
save.c:		if (!ch->long_descr)
save.c:		  ch->long_descr	= STRALLOC( "" );
save.c:		if (!ch->description)
save.c:		  ch->description	= STRALLOC( "" );
save.c:		if (!ch->pcdata->pwd)
save.c:		  ch->pcdata->pwd	= str_dup( "" );
save.c:		if (!ch->pcdata->shipname)
save.c:		  ch->pcdata->shipname  = STRALLOC( "" );
save.c:		if (!ch->pcdata->email)
save.c:		  ch->pcdata->email	= str_dup( "" );
save.c:		if (!ch->pcdata->bamfin)
save.c:		  ch->pcdata->bamfin	= str_dup( "" );
save.c:		if (!ch->pcdata->bamfout)
save.c:		  ch->pcdata->bamfout	= str_dup( "" );
save.c:		if (!ch->pcdata->bio)
save.c:		  ch->pcdata->bio	= STRALLOC( "" );
save.c:		if (!ch->rank)
save.c:		  ch->rank		= str_dup( "" );
save.c:		if (!ch->pcdata->bestowments)
save.c:		  ch->pcdata->bestowments = str_dup( "" );
save.c:		if (!ch->pcdata->title)
save.c:		  ch->pcdata->title	= STRALLOC( "" );
save.c:		if (!ch->pcdata->disguise)
save.c:		  ch->pcdata->disguise	= STRALLOC( "" );
save.c:		if (!ch->pcdata->homepage)
save.c:		  ch->pcdata->homepage	= str_dup( "" );
save.c:		if (!ch->pcdata->screenname)
save.c:		  ch->pcdata->screenname	= str_dup( "" );
save.c:		if (!ch->pcdata->image)
save.c:		  ch->pcdata->image	= str_dup( "" );
save.c:		if (!ch->pcdata->authed_by)
save.c:		  ch->pcdata->authed_by = STRALLOC( "" );
save.c:		if (!ch->pcdata->prompt )
save.c:		  ch->pcdata->prompt	= STRALLOC( "" );
save.c:		ch->editor		= NULL;
save.c:		killcnt = URANGE( 2, ((ch->top_level+3) * MAX_KILLTRACK)/LEVEL_AVATAR, MAX_KILLTRACK );
save.c:		  ch->pcdata->killed[killcnt].vnum = 0;
save.c:		   if ( ch->skill_level[ability] == 0 && ability != FORCE_ABILITY)
save.c:		       ch->skill_level[ability] = 1;
save.c:		if ( !IS_IMMORTAL( ch ) && !ch->speaking )
save.c:		/*	ch->speaking = LANG_BASIC;      */
save.c:			ch->speaking = race_table[ch->race].language;
save.c:			ch->speaks = ~0;
save.c:			if ( ch->speaking == 0 )
save.c:				ch->speaking = ~0;
save.c:		if ( !ch->pcdata->prompt )
save.c:		  ch->pcdata->prompt = STRALLOC("");
save.c:                   ch->hit = URANGE( 1 , ch->hit + hitgain , ch->max_hit );		   
save.c:		   ch->move = URANGE( 1 , ch->move + hitgain , ch->max_move );		   
save.c:		   if ( ch->skill_level[FORCE_ABILITY] > 1 )
save.c:		      ch->mana = URANGE( 0 , ch->mana + hitgain , ch->max_mana );		   
save.c:		   if ( ch->pcdata->learned[sn] > 0 && ch->skill_level[skill_table[sn]->guild] < skill_table[sn]->min_level )
save.c:                      ch->pcdata->learned[sn] = 0;
save.c:	    KEY( "Email",	ch->pcdata->email,	fread_string_nohash( fp ) );
save.c:	    KEY( "Toplevel",	ch->top_level,		fread_number( fp ) );
save.c:		    ch->pcdata->learned[sn] = value;
save.c:	    KEY( "Trust", ch->trust, fread_number( fp ) );
save.c:	    ch->trust = UMIN( ch->trust, MAX_LEVEL - 1 );
save.c:		ch->pcdata->title = fread_string( fp );
save.c:		if ( isalpha(ch->pcdata->title[0])
save.c:		||   isdigit(ch->pcdata->title[0]) )
save.c:		    sprintf( buf, " %s", ch->pcdata->title );
save.c:		    if ( ch->pcdata->title )
save.c:		      STRFREE( ch->pcdata->title );
save.c:		    ch->pcdata->title = STRALLOC( buf );
save.c:                ch->pcdata->version = file_ver;
save.c:		    ch->pcdata->learned[sn] = value;
save.c:	    KEY( "Wimpy",	ch->wimpy,		fread_number( fp ) );
save.c:	    KEY( "WizInvis",	ch->pcdata->wizinvis,	fread_number( fp ) );
save.c:	    KEY( "Wanted",	ch->pcdata->wanted_flags,  fread_number( fp ) );
save.c:    name = ch->name;
save.c:    sprintf( strprofile, "%s%s.htm", PROFILE_DIR, capitalize( ch->name ) );
save.c:	if(ch->pcdata->image && ch->pcdata->image[0] != '\0')
save.c:	  sprintf(image, "%s", show_tilde(ch->pcdata->image));
save.c:	if(ch->sex == 1)
save.c:	else if(ch->sex == 2)
save.c:	if(ch->pcdata->email && ch->pcdata->email[0] != '\0')
save.c:	  sprintf(email, "%s", ch->pcdata->email);
save.c:	if(ch->pcdata->homepage && ch->pcdata->homepage[0] != '\0')
save.c:	  sprintf(homepage, "%s", show_tilde(ch->pcdata->homepage));
save.c:	if(ch->pcdata->screenname && ch->pcdata->screenname[0] != '\0')
save.c:	  sprintf(aimname, "%s", ch->pcdata->screenname);
save.c:	if(ch->description && ch->description[0] != '\0')
save.c:	  sprintf(desc, "%s", ch->description);
save.c:	if(ch->pcdata->bio && ch->pcdata->bio[0] != '\0')
save.c:	  sprintf(bio, "%s", ch->pcdata->bio);
save.c:	fprintf(fp, "<td class='middletd'> Name: %s</td>\n", ch->name);
save.c:	fprintf(fp, "<td class='middletd'> Race: %s </td>\n", race_table[ch->race].race_name);
ships.c:   if ( IS_NPC(ch) || !ch->pcdata )
ships.c:   if ( !ch->pcdata->clan )
ships.c:   clan = ch->pcdata->clan;
ships.c:   mainclan = ch->pcdata->clan->mainclan ? ch->pcdata->clan->mainclan : clan;
ships.c:   if ( ( ch->pcdata->bestowments
ships.c:    &&    is_name("clanbuyship", ch->pcdata->bestowments))
ships.c:    ||   !str_cmp( ch->name, clan->leader  ))
ships.c:		  if(!ch->pcdata->clan && (!str_cmp(ship_prototypes[x].clan, "El Imperio") 
ships.c:		  if(ch->pcdata->clan && str_cmp(ship_prototypes[x].clan, ch->pcdata->clan->name) && str_cmp(ship_prototypes[x].clan, "")) continue;
ships.c:		  if(ch->pcdata->clan && str_cmp(ship_prototypes[x].clan, ch->pcdata->clan->name)) continue;
ships.c:		  if(!ch->pcdata->clan && (!str_cmp(ship_prototypes[x].clan, "El Imperio") 
ships.c:		  if(ch->pcdata->clan && str_cmp(ship_prototypes[x].clan, ch->pcdata->clan->name) && str_cmp(ship_prototypes[x].clan, "")) continue;
ships.c:		  if(ch->pcdata->clan && str_cmp(ship_prototypes[x].clan, ch->pcdata->clan->name)) continue;
ships.c:	 str_cmp(ship_prototypes[ship_type].clan, ch->pcdata->clan->name))
ships.c:    if(ch->pcdata->clan->funds < ship_prototypes[ship_type].cost)
ships.c:   clan = ch->pcdata->clan;
ships.c:   mainclan = ch->pcdata->clan->mainclan ? ch->pcdata->clan->mainclan : clan;
ships.c:   if ( ( ch->pcdata->bestowments
ships.c:    &&    is_name("clanbuyship", ch->pcdata->bestowments))
ships.c:    ||   !str_cmp( ch->name, clan->leader  ))
ships.c:	   if(ch->pcdata->clan == planet->governed_by)
ships.c:    ch->pcdata->clan->funds -= ship_prototypes[ship_type].cost*1.3;
ships.c:    ship->owner = STRALLOC(ch->pcdata->clan->name);
ships.c:   if ( IS_NPC(ch) || !ch->pcdata )
ships.c:   if ( !ch->pcdata->clan )
ships.c:   clan = ch->pcdata->clan;
ships.c:   mainclan = ch->pcdata->clan->mainclan ? ch->pcdata->clan->mainclan : clan;
ships.c:   if ( ( ch->pcdata->bestowments
ships.c:    &&    is_name("clanbuyship", ch->pcdata->bestowments))
ships.c:    ||   !str_cmp( ch->name, clan->leader  ))
ships.c:    if( !IS_SET(ch->in_room->room_flags2,ROOM_SHIPYARD) )
ships.c:		  if(!ch->pcdata->clan && (!str_cmp(ship_prototypes[x].clan, "El Imperio") 
ships.c:		  if(ch->pcdata->clan && str_cmp(ship_prototypes[x].clan, ch->pcdata->clan->name) && str_cmp(ship_prototypes[x].clan, "")) continue;
ships.c:		  if(ch->pcdata->clan && str_cmp(ship_prototypes[x].clan, ch->pcdata->clan->name)) continue;
ships.c:		  if(!ch->pcdata->clan && (!str_cmp(ship_prototypes[x].clan, "El Imperio") 
ships.c:		  if(ch->pcdata->clan && str_cmp(ship_prototypes[x].clan, ch->pcdata->clan->name) && str_cmp(ship_prototypes[x].clan, "")) continue;
ships.c:		  if(ch->pcdata->clan && str_cmp(ship_prototypes[x].clan, ch->pcdata->clan->name)) continue;
ships.c:	 str_cmp(ship_prototypes[ship_type].clan, ch->pcdata->clan->name))
ships.c:    if(ch->pcdata->clan->funds < ship_prototypes[ship_type].cost)
ships.c:    ch->pcdata->clan->funds -= ship_prototypes[ship_type].cost;
ships.c:    ship->owner = ch->pcdata->clan->name;
ships.c:    if( !IS_SET(ch->in_room->room_flags2,ROOM_SHIPYARD) && !IS_SET(ch->in_room->room_flags2, ROOM_BLACKMARKET))
ships.c:   if(!IS_SET(ch->in_room->room_flags2, ROOM_BLACKMARKET))
ships.c:		  if(!ch->pcdata->clan && (!str_cmp(ship_prototypes[x].clan, "El Imperio") 
ships.c:		  if(ch->pcdata->clan && str_cmp(ship_prototypes[x].clan, ch->pcdata->clan->name) && str_cmp(ship_prototypes[x].clan, "")) continue;
ships.c:       if(!IS_SET(ch->in_room->room_flags2, ROOM_BLACKMARKET))
ships.c:     if(!IS_SET(ch->in_room->room_flags2, ROOM_BLACKMARKET))
ships.c:		  if(!ch->pcdata->clan && (!str_cmp(ship_prototypes[x].clan, "El Imperio") 
ships.c:		  if(ch->pcdata->clan && str_cmp(ship_prototypes[x].clan, ch->pcdata->clan->name) && str_cmp(ship_prototypes[x].clan, "")) continue;
ships.c:  if(!IS_SET(ch->in_room->room_flags2, ROOM_BLACKMARKET))
ships.c:     if(!ch->pcdata->clan)
ships.c:     else if(str_cmp(ch->pcdata->clan->name, ship_prototypes[ship_type].clan))
ships.c:   if(!IS_SET(ch->in_room->room_flags2, ROOM_BLACKMARKET))
ships.c:    if(ch->gold < ship_prototypes[ship_type].cost)
ships.c:    if(ch->gold < ship_prototypes[ship_type].cost*3)
ships.c:   if(!IS_SET(ch->in_room->room_flags2, ROOM_BLACKMARKET))
ships.c:    ch->gold -= ship_prototypes[ship_type].cost; 
ships.c:    ch->gold -= ship_prototypes[ship_type].cost*3;
ships.c:    if(ch->in_room->area && ch->in_room->area->planet)
ships.c:        if( ship_prototypes[ship_type].class >= SHIP_CRUISER &&  ch->in_room->area->planet->starsystem )
ships.c:           ship->home = STRALLOC( ch->in_room->area->planet->starsystem->name );
ships.c:           ship->home = STRALLOC( ch->in_room->area->planet->name );
ships.c:        ship->shipyard = ch->in_room->vnum;
ships.c:    ship->owner 	= STRALLOC( ch->name );
ships.c:  switch( ch->substate )
ships.c:    if ( (ship = ship_from_engine(ch->in_room->vnum)) != NULL )
ships.c:      	ship = ship_from_engine(ch->in_room->vnum);
ships.c:     for ( obj = ch->last_carrying; obj; obj = obj->prev_content )
ships.c:     chance = IS_NPC(ch) ? ch->top_level
ships.c:        : (int) (ch->pcdata->learned[gsn_installmodule]);
ships.c:  	ch->dest_buf   = str_dup(arg);
ships.c:    	  if ( !ch->dest_buf )
ships.c:    	  strcpy(arg, ch->dest_buf);
ships.c:    	  DISPOSE( ch->dest_buf);
ships.c:    	  DISPOSE( ch->dest_buf );
ships.c:    	  ch->substate = SUB_NONE;
ships.c:     ch->substate = SUB_NONE;
ships.c:     for ( obj = ch->last_carrying; obj; obj = obj->prev_content )
ships.c:    chance = IS_NPC(ch) ? ch->top_level
ships.c:               : (int) (ch->pcdata->learned[gsn_installmodule]);
ships.c:    ship = ship_from_engine(ch->in_room->vnum);
ships.c:      xpgain = ((ch->skill_level[TECHNICIAN_ABILITY]+1) * 300);
shops.c:    for ( keeper = ch->in_room->first_person;
shops.c:    if ( !knows_language( keeper, ch->speaking, ch ) )
shops.c:    for ( keeper = ch->in_room->first_person;
shops.c:    if ( !knows_language( keeper, ch->speaking, ch ) )
shops.c:    if ( ch->gold > (ch->top_level * ch->top_level * 1000) )
shops.c:	cost = (int) (cost * (80 + UMIN(ch->top_level, LEVEL_AVATAR))) / 100;
shops.c:		  + ((URANGE(5,ch->top_level,LEVEL_AVATAR)-20)/2);
shops.c:    if ( IS_SET(ch->in_room->room_flags, ROOM_PET_SHOP) )
shops.c:      for ( obj = ch->last_carrying; obj; obj = obj->prev_content )        
shops.c:	pRoomIndexNext = get_room_index( ch->in_room->vnum + 1 );
shops.c:	    bug( "Do_buy: bad pet shop at vnum %d.", ch->in_room->vnum );
shops.c:	in_room     = ch->in_room;
shops.c:	ch->in_room = pRoomIndexNext;
shops.c:	ch->in_room = in_room;
shops.c:	if (( ch->gold < 10 * pet->top_level * pet->top_level ) && debit == FALSE)
shops.c:	else if ( (ch->pcdata->bank < 10 * pet->top_level * pet->top_level) && debit == TRUE )
shops.c:	  ch->gold	-= maxgold; /* this was already here, btw */
shops.c:	  ch->pcdata->bank  -= maxgold;
shops.c:	boost_economy( ch->in_room->area, maxgold );
shops.c:	    pet->description, ch->name );
shops.c:	char_to_room( pet, ch->in_room );
shops.c:		ch->reply = keeper;
shops.c:      for ( obj = ch->last_carrying; obj; obj = obj->prev_content )        
shops.c:	if( !IS_NPC(ch) && ch->pcdata->learned[gsn_bargain] > 0 && ch->pcdata->learned[gsn_bargain] > number_percent())
shops.c:	    ch->reply = keeper;
shops.c:	    ch->reply = keeper;
shops.c:	if ( ch->gold < cost && debit == FALSE)
shops.c:	    ch->reply = keeper;
shops.c:        if ( ch->pcdata->bank < cost && debit == TRUE)
shops.c:      	    ch->reply = keeper;
shops.c:	if ( ch->carry_number + get_obj_number( obj ) > can_carry_n( ch ) )
shops.c:	if ( ch->carry_weight + ( get_obj_weight( obj ) * noi )
shops.c:	  ch->gold     -= cost; /* this line was already here, btw */
shops.c:          ch->pcdata->bank     -= cost;
shops.c:    if ( IS_SET(ch->in_room->room_flags, ROOM_PET_SHOP) )
shops.c:	pRoomIndexNext = get_room_index( ch->in_room->vnum + 1 );
shops.c:	    bug( "Do_list: bad pet shop at vnum %d.", ch->in_room->vnum );
shops.c:	ch->reply = keeper;
shops.c:        lower_economy( ch->in_room->area, cost-keeper->gold );
shops.c:    ch->gold     += cost;
shops.c:       ch_exp = UMIN( obj->cost*10 , ( exp_level( ch->skill_level[SMUGGLING_ABILITY]+1) - exp_level( ch->skill_level[SMUGGLING_ABILITY])  ) / 10  );
shops.c:	ch->reply = keeper;
shops.c:    ch->reply = keeper;
shops.c:   else if ( (cost = strcmp("todo",arg) ? cost : 11*cost/10) > ch->gold )
shops.c:      ch->gold     -= cost;
shops.c:	for ( obj = ch->first_carrying; obj ; obj = obj->next_content )
shops.c:	ch->reply = keeper;
shops.c:    for ( obj = ch->first_carrying; obj != NULL ; obj = obj->next_content )
shops.c:	ch->reply = keeper;
shops.c:    if ( cost > ch->gold )
skills.c:	||  ( ch->pcdata->learned[sn] > 0 )) )
skills.c:	if ( !IS_NPC(ch) && ch->mana < mana )
skills.c:	   > (IS_NPC(ch) ? 75 : ch->pcdata->learned[sn]) )
skills.c:		  ch->mana -= mana/2;
skills.c:		ch->mana -= mana;
skills.c:	retcode = (*skill_table[sn]->spell_fun) ( sn, ch->top_level, ch, vo );
skills.c:	    for ( vch = ch->in_room->first_person; vch; vch = vch_next )
skills.c:		vch_next = vch->next_in_room;
skills.c:	  ch->mana -= mana;
skills.c:    ch->prev_cmd = ch->last_cmd;    /* haus, for automapping */
skills.c:    ch->last_cmd = skill_table[sn]->skill_fun;
skills.c:    if ( IS_NPC(ch) || ch->pcdata->learned[sn] == 0 )
skills.c:    if ( sn == skill_lookup( "meditate" ) && ch->skill_level[FORCE_ABILITY] < 2 )
skills.c:    //adept = ( ch->skill_level[skill_table[sn]->guild] - skill_table[sn]->min_level )* 5 + 50;
skills.c:    if ( ch->pcdata->learned[sn] >= adept )
skills.c:    if ( sklvl == 0 || sklvl > ch->skill_level[skill_table[sn]->guild] )
skills.c:      sklvl = ch->skill_level[skill_table[sn]->guild];
skills.c:    if ( ch->pcdata->learned[sn] < 100 )
skills.c:	chance = ch->pcdata->learned[sn] + (5 * skill_table[sn]->difficulty);
skills.c:	ch->pcdata->learned[sn] = UMIN( adept, ch->pcdata->learned[sn] + learn );
skills.c:	if ( ch->pcdata->learned[sn] == 100 )	 /* fully learned! */
skills.c:            if ( !ch->fighting && sn != gsn_hide && sn != gsn_sneak )
skills.c:    if ( IS_NPC(ch) || ch->pcdata->learned[sn] == 0 )
skills.c:    if ( sn == skill_lookup( "meditate" ) && ch->skill_level[FORCE_ABILITY] < 2 )
skills.c:    //adept = ( ch->skill_level[skill_table[sn]->guild] - skill_table[sn]->min_level )* 5 + 50;
skills.c:    if ( ch->pcdata->learned[sn] >= adept )
skills.c:    if ( sklvl == 0 || sklvl > ch->skill_level[skill_table[sn]->guild] )
skills.c:      sklvl = ch->skill_level[skill_table[sn]->guild];
skills.c:    if ( ch->pcdata->learned[sn] < 50 )
skills.c:	chance = ch->pcdata->learned[sn] + (5 * skill_table[sn]->difficulty);
skills.c:	ch->pcdata->learned[sn] = UMIN( adept, ch->pcdata->learned[sn] + learn );
skills.c:            if ( !ch->fighting && sn != gsn_hide && sn != gsn_sneak )
skills.c:    if ( !IS_NPC(ch) && !ch->pcdata->learned[gsn_gouge] )
skills.c:    if ( ch->mount )
skills.c:    if ( IS_NPC(ch) || percent < ch->pcdata->learned[gsn_gouge] )
skills.c:	dam = number_range( 1, ch->skill_level[COMBAT_ABILITY] );
skills.c:		  af.duration  = 3 + (ch->skill_level[COMBAT_ABILITY] / 20);
skills.c:    switch( ch->substate )
skills.c:	    if ( !IS_NPC(ch) && !ch->pcdata->learned[gsn_detrap] )
skills.c:	    if ( ch->mount )
skills.c:	    if ( !ch->in_room->first_content )
skills.c:	    for ( obj = ch->in_room->first_content; obj; obj = obj->next_content )
skills.c:	    ch->dest_buf = str_dup( obj->name );
skills.c:	    if ( !ch->dest_buf )
skills.c:		bug( "do_detrap: ch->dest_buf NULL!", 0 );
skills.c:	    strcpy( arg, ch->dest_buf );
skills.c:	    DISPOSE( ch->dest_buf );
skills.c:	    ch->dest_buf = NULL;
skills.c:	    ch->substate = SUB_NONE;
skills.c:	    DISPOSE(ch->dest_buf);
skills.c:	    ch->substate = SUB_NONE;
skills.c:    if ( !ch->in_room->first_content )
skills.c:    for ( obj = ch->in_room->first_content; obj; obj = obj->next_content )
skills.c:    percent  = number_percent( ) - ( ch->skill_level[SMUGGLING_ABILITY] / 20 ) 
skills.c:    if ( !IS_NPC(ch) || percent > ch->pcdata->learned[gsn_detrap] )
skills.c:    switch( ch->substate )
skills.c:          if ( ch->mount )
skills.c:	      switch( ch->in_room->sector_type )
skills.c:	  ch->dest_buf = str_dup( arg );
skills.c:	  if ( !ch->dest_buf )
skills.c:	  strcpy( arg, ch->dest_buf );  
skills.c:	  DISPOSE( ch->dest_buf );	
skills.c:	  DISPOSE( ch->dest_buf );
skills.c:	  ch->substate = SUB_NONE;
skills.c:    ch->substate = SUB_NONE;
skills.c:    for ( obj = ch->first_carrying; obj; obj = obj->next_content )
skills.c:		 (IS_NPC(ch) ? 80 : ch->pcdata->learned[gsn_dig]) )
skills.c:    startobj = ch->in_room->first_content;
skills.c:	    (IS_NPC(ch) ? 80 : ch->pcdata->learned[gsn_dig]) )
skills.c:    switch( ch->substate )
skills.c:	    if ( ch->mount )
skills.c:	    ch->dest_buf = str_dup( arg );
skills.c:	    if ( !ch->dest_buf )
skills.c:	    strcpy( arg, ch->dest_buf );
skills.c:	    DISPOSE( ch->dest_buf );
skills.c:	    DISPOSE( ch->dest_buf );
skills.c:	    ch->substate = SUB_NONE;
skills.c:    ch->substate = SUB_NONE;
skills.c:	startobj = ch->in_room->first_content;
skills.c:	if ( (pexit = get_exit( ch->in_room, door )) != NULL
skills.c:	&&   percent < (IS_NPC(ch) ? 80 : ch->pcdata->learned[gsn_search]) )
skills.c:       &&   percent < ch->pcdata->learned[gsn_search] )
skills.c:    if ( ch->mount )
skills.c:    if ( IS_SET( ch->in_room->room_flags, ROOM_SAFE ) )
skills.c:    ||   percent > ( IS_NPC(ch) ? 90 : ch->pcdata->learned[gsn_steal] ) ) 
skills.c:	sprintf( buf, "¡Este %s ha intentado robarme!", race_table[ch->race].race_name );
skills.c:		  if ( (mst = ch->master) == NULL )
skills.c:	ch->gold     += amount;
skills.c:        sprintf(logbuf, "%s robó %d créditos a %s.\n\r", ch->name, amount, IS_NPC(victim) ? victim->short_descr : victim->name);
skills.c:          xp = UMIN( amount*10 , ( exp_level( ch->skill_level[SMUGGLING_ABILITY]+1 ) - exp_level( ch->skill_level[SMUGGLING_ABILITY])  ) / 35  );    
skills.c:    if ( ch->carry_number + (get_obj_number(obj)/obj->count) > can_carry_n( ch ) )
skills.c:    if ( ch->carry_weight + (get_obj_weight(obj)/obj->count) > can_carry_w( ch ) )
skills.c:    sprintf(logbuf, "%s robó %s a %s.\n\r", ch->name, obj->name, IS_NPC(victim) ? victim->short_descr : victim->name );
skills.c:      xp = UMIN( obj->cost*10 , ( exp_level( ch->skill_level[SMUGGLING_ABILITY]+1) - exp_level( ch->skill_level[SMUGGLING_ABILITY])  ) / 10  );    
skills.c:    if ( ch->mount )
skills.c:    ||   percent < ch->pcdata->learned[gsn_dualstab] )
skills.c:    if ( ch->mount )
skills.c:          sprintf(buf, "%s backstabbed %s", ch->name, victim->name);
skills.c:    ||   percent < ch->pcdata->learned[gsn_backstab] )
skills.c:    if ( ch->mount )
skills.c:    ch->alignment = ch->alignment + 5;
skills.c:    ch->alignment = URANGE( -1000, ch->alignment, 1000 );
skills.c:    if ( !IS_NPC(ch) && percent > ch->pcdata->learned[gsn_rescue] )
skills.c:    ch->alignment = ch->alignment + 50;
skills.c:    ch->alignment = URANGE( -1000, ch->alignment, 1000 );
skills.c:    if ( ch->fighting )
skills.c:    if ( IS_NPC(ch) || number_percent( ) < ch->pcdata->learned[gsn_kick] )
skills.c:              ((10+ch->skill_level[COMBAT_ABILITY])*2) ), gsn_kick );
skills.c:    &&   ch->pcdata->learned[gsn_punch] <= 0 )
skills.c:    if ( IS_NPC(ch) || number_percent( ) < ch->pcdata->learned[gsn_punch] )
skills.c:                       ((20+ch->skill_level[COMBAT_ABILITY])*2) ), 
skills.c:    &&  ch->pcdata->learned[gsn_bash] <= 0  )
skills.c:    || (number_percent( ) + chance) < ch->pcdata->learned[gsn_bash] )
skills.c:	global_retcode = damage( ch, victim, number_range( 1, ch->skill_level[COMBAT_ABILITY]  ), gsn_bash );
skills.c:    &&  ch->pcdata->learned[gsn_stun] <= 0  )
skills.c:    if ( ch->move < 16 )
skills.c:    chance = ris_save( victim, ch->skill_level[COMBAT_ABILITY] , RIS_PARALYSIS );
skills.c:    || (number_percent( ) + chance) < ch->pcdata->learned[gsn_stun] ) )
skills.c:	ch->move -= 15;
skills.c:	ch->move -= 5;
skills.c:    &&   ch->pcdata->learned[gsn_disarm] <= 0  )
skills.c:    percent = number_percent( ) + victim->skill_level[COMBAT_ABILITY]  - ch->skill_level[COMBAT_ABILITY] 
skills.c:    if ( IS_NPC(ch) || percent < ch->pcdata->learned[gsn_disarm] * 2 / 3 )
skills.c:    if ( ch->mount )
skills.c:    for ( gch = ch->in_room->first_person; gch; gch = gch->next_in_room )
skills.c:	if ( IS_NPC(gch) && IS_AWAKE(gch) && ch->skill_level[SMUGGLING_ABILITY]   < gch->top_level )
skills.c:        if ( !IS_NPC(ch) && x > ch->pcdata->learned[gsn_pick_lock] )
skills.c:	&&   pexit_rev->to_room == ch->in_room )
skills.c:        if ( !IS_NPC(ch) && number_percent( ) > ch->pcdata->learned[gsn_pick_lock] )
skills.c:    if ( ( ship = ship_in_room(ch->in_room, arg ) ) != NULL )
skills.c:   	     if ( IS_NPC(ch) || !ch->pcdata || y > ch->pcdata->learned[gsn_pickshiplock] )
skills.c://        	sprintf ( buf , "[ALARM] %s attempting to pick %s.", ch->name, ship->name ); 
skills.c:    if ( ch->mount )
skills.c:    if ( IS_NPC(ch) || number_percent( ) < ch->pcdata->learned[gsn_sneak] )
skills.c:	af.duration  = ch->skill_level[SMUGGLING_ABILITY]  * DUR_CONV;
skills.c:    if ( ch->mount )
skills.c:	REMOVE_BIT(ch->affected_by, AFF_HIDE);
skills.c:    if ( IS_NPC(ch) || number_percent( ) < ch->pcdata->learned[gsn_hide] )
skills.c:	SET_BIT(ch->affected_by, AFF_HIDE);
skills.c:    if ( ch->mount )
skills.c:	REMOVE_BIT(ch->affected_by, AFF_HIDE);
skills.c:    if ( IS_NPC(ch) || number_percent( ) < ch->pcdata->learned[gsn_concealment] )
skills.c:	SET_BIT(ch->affected_by, AFF_HIDE);
skills.c:    REMOVE_BIT   ( ch->affected_by, AFF_HIDE		);
skills.c:    if (ch->race != RACE_DEFEL) /* Defel has perm invis */
skills.c:    REMOVE_BIT   ( ch->affected_by, AFF_INVISIBLE	);
skills.c:    if (ch->race != RACE_NOGHRI) /* Noghri has perm sneak */
skills.c:    REMOVE_BIT   ( ch->affected_by, AFF_SNEAK		);
skills.c:        if ( !ch->pcdata || !(pArea=ch->pcdata->area) )
skills.c:        if  ( ch->in_room->vnum < pArea->low_r_vnum
skills.c:        || ch->in_room->vnum > pArea->hi_r_vnum )
skills.c:    if ( ch->in_room == location )
skills.c:    if ( IS_SET(ch->in_room->room_flags, ROOM_NO_RECALL) )
skills.c:    if ( IS_SET(ch->affected_by, AFF_CURSE) )
skills.c:    if ( ch->mount )
skills.c:	char_from_room( ch->mount );
skills.c:	char_to_room( ch->mount, location );
skills.c:    if ( ch->on )
skills.c:       ch->on = NULL;
skills.c:       ch->position = POS_STANDING;
skills.c:    if (ch->position != POS_STANDING)
skills.c:       ch->position = POS_STANDING;
skills.c:    if ( ch->mount )
skills.c:    ch->alignment = ch->alignment + 20;
skills.c:    ch->alignment = URANGE( -1000, ch->alignment, 1000 );
skills.c:    if ( !IS_NPC(ch) && percent > ch->pcdata->learned[gsn_aid] )
skills.c:    ch->alignment = ch->alignment + 20;
skills.c:    ch->alignment = URANGE( -1000, ch->alignment, 1000 );
skills.c:    &&   ch->pcdata->learned[gsn_mount] <= 0  )
skills.c:    if ( ch->mount )
skills.c:    if ( IS_NPC(ch) || number_percent( ) < ch->pcdata->learned[gsn_mount] )
skills.c:	ch->mount = victim;
skills.c:	ch->position = POS_MOUNTED;
skills.c:    if ( (victim = ch->mount) == NULL )
skills.c:    if ( IS_NPC(ch) || number_percent( ) < ch->pcdata->learned[gsn_mount] )
skills.c:	ch->mount = NULL;
skills.c:	ch->position = POS_STANDING;
skills.c:	ch->mount = NULL;
skills.c:	ch->position = POS_SITTING;
skills.c:	chances = (int) (ch->force_skill[FORCE_SKILL_PARRY]);
skills.c:         && !IS_SET( ch->pcdata->flags, PCFLAG_GAG) )  /* SB */   
skills.c:    if ( !IS_NPC(ch) && !IS_SET( ch->pcdata->flags, PCFLAG_GAG) ) 
skills.c:  &&  ch->pcdata->learned[gsn_poison_weapon] <= 0  )
skills.c:    if ( ch->fighting )
skills.c:    for ( pobj = ch->first_carrying; pobj; pobj = pobj->next_content )
skills.c:    for ( wobj = ch->first_carrying; wobj; wobj = wobj->next_content )
skills.c:    &&  ( ch->pcdata->condition[COND_DRUNK] > 0 ) ) 
skills.c:    && percent > ch->pcdata->learned[gsn_poison_weapon] )
skills.c:	damage( ch, ch, ch->skill_level[HUNTING_ABILITY] , gsn_poison_weapon );
skills.c:    obj->cost *= ch->skill_level[HUNTING_ABILITY]/2;
skills.c:    obj->timer = 10 + ch->skill_level[HUNTING_ABILITY] ;
skills.c:    if ( number_percent( ) >= chance + victim->top_level - ch->top_level )
skills.c:    if ( ch->mount )
skills.c:    if ( !ch->fighting )
skills.c:    if ( percent < (IS_NPC(ch) ? ch->top_level : ch->pcdata->learned[gsn_circle]) )
skills.c:  if ( !ch->fighting )
skills.c:  percent = IS_NPC(ch) ? 80 : ch->pcdata->learned[gsn_berserk];
skills.c:  af.duration = number_range(ch->top_level/5, ch->top_level*2/5);
skills.c:  if ( IS_SET(ch->in_room->room_flags, ROOM_SAFE) )
skills.c:  if ( !ch->in_room->first_person )
skills.c:  percent = IS_NPC(ch) ? 80 : ch->pcdata->learned[gsn_hitall];
skills.c:  for ( vch = ch->in_room->first_person; vch; vch = vch_next )
skills.c:    vch_next = vch->next_in_room;
skills.c:    if ( ++nvict > ch->skill_level[COMBAT_ABILITY]  / 5 )
skills.c:	  sprintf(buf, "%s hitall'ed and hit %s", ch->name, vch->name);
skills.c:  ch->move = UMAX(0, ch->move-nvict*3+nhit);
skills.c:    ( !IS_NPC( ch ) && !IS_SET( ch->act, PLR_HOLYLIGHT ) ) ) )
skills.c:  was_in_room = ch->in_room;
skills.c:	|| ( number_percent() > ch->pcdata->learned[gsn_scan] ) )  
skills.c:  if ( ( pexit = get_exit( ch->in_room, dir ) ) == NULL )
skills.c:       to_room = generate_exit( ch->in_room , &pexit );
skills.c:    send_to_char( ch->in_room->name, ch );
skills.c:    show_list_to_char( ch->in_room->first_content, ch, FALSE, FALSE );
skills.c:    show_char_to_char( ch->in_room->first_person, ch );
skills.c:    if ( ( pexit = get_exit( ch->in_room, dir ) ) == NULL )
skills.c:    if (  (ship = ship_from_cockpit(ch->in_room->vnum))  == NULL )
skills.c:    if (  (ship = ship_from_pilotseat(ch->in_room->vnum))  == NULL )
skills.c:         chance = IS_NPC(ch) ? ch->top_level: (int)  (ch->pcdata->learned[gsn_chandelle]) ;
slay.c:    if ( (!IS_NPC(victim)) && (victim->top_level >= ch->top_level) && (strcmp(ch->name, "Keberus")) )
slay.c:          || ( ( is_name(ch->name, slay->owner) ) && !str_cmp( type, slay->type ) ) 
slay.c:	  || ( ( ch->top_level == LEVEL_IMPLEMENTOR) && !str_cmp( type, slay->type ) ) )
slay.c:    switch( ch->substate )
slay.c:		slay = (SLAY_DATA*)ch->dest_buf;
slay.c:		ch->substate = ch->tempnum;
slay.c:		slay = (SLAY_DATA*)ch->dest_buf;
slay.c:		ch->substate = ch->tempnum;
slay.c:		slay = (SLAY_DATA*)ch->dest_buf;
slay.c:		ch->substate = ch->tempnum;
slay.c:       if( ch->top_level != LEVEL_IMPLEMENTOR )
slay.c:	if ( ch->substate == SUB_REPEATCMD )
slay.c:	  ch->tempnum = SUB_REPEATCMD;
slay.c:        ch->tempnum = SUB_NONE;
slay.c:      ch->substate = SUB_SLAYCMSG;
slay.c:      ch->dest_buf = slay;
slay.c:	if ( ch->substate == SUB_REPEATCMD )
slay.c:	  ch->tempnum = SUB_REPEATCMD;
slay.c:        ch->tempnum = SUB_NONE;
slay.c:      ch->substate = SUB_SLAYVMSG;
slay.c:      ch->dest_buf = slay;
slay.c:	if ( ch->substate == SUB_REPEATCMD )
slay.c:	  ch->tempnum = SUB_REPEATCMD;
slay.c:        ch->tempnum = SUB_NONE;
slay.c:      ch->substate = SUB_SLAYRMSG;
slay.c:      ch->dest_buf = slay;
slay.c:   if( ( !IS_NPC( victim ) ) && ( victim->top_level >= ch->top_level ) )  
slay.c:             || ( ( is_name( ch->name, slay->owner ) ) && !str_cmp( type, slay->type ) )  
slay.c:             || ( ( ch->top_level == LEVEL_IMPLEMENTOR ) && !str_cmp( type, slay->type ) ) )  
slicers.c:      ch->pcdata->tell_snoop = NULL;
slicers.c:  chance = IS_NPC(ch) ? ch->top_level
slicers.c:    : (int)  (ch->pcdata->learned[gsn_spy]) ;
slicers.c:     ch->pcdata->tell_snoop = STRALLOC(arg);
slicers.c:     sprintf(buf,"Ahora espías las comunicaciones de la frecuencia %s.\n\r", ch->pcdata->tell_snoop);
slicers.c:  name = ch->name;
slicers.c:    name = ch->name;
slicers.c:  switch( ch->substate )
slicers.c:     for ( obj = ch->last_carrying; obj; obj = obj->prev_content )
slicers.c:     if(!IS_SET(ch->in_room->room_flags, ROOM_BANK))
slicers.c:     chance = IS_NPC(ch) ? ch->top_level : (int) (ch->pcdata->learned[gsn_inquire]);
slicers.c:    	  ch->substate = SUB_NONE;
slicers.c:     ch->substate = SUB_NONE;
slicers.c:     chance = IS_NPC(ch) ? ch->top_level
slicers.c:                : (int) (ch->pcdata->learned[gsn_inquire]);
slicers.c: switch( ch->substate )
slicers.c:    if ( !IS_SET( ch->in_room->room_flags, ROOM_FACTORY ) )
slicers.c:    for ( obj = ch->last_carrying; obj; obj = obj->prev_content )
slicers.c:     chance = IS_NPC(ch) ? ch->top_level
slicers.c:        : (int) (ch->pcdata->learned[gsn_makecommsystem]);
slicers.c:    	ch->dest_buf   = str_dup(arg);
slicers.c:    	  if ( !ch->dest_buf )
slicers.c:    	  strcpy(arg, ch->dest_buf);
slicers.c:    	  DISPOSE( ch->dest_buf);
slicers.c:    	  DISPOSE( ch->dest_buf );
slicers.c:    	  ch->substate = SUB_NONE;
slicers.c:    ch->substate = SUB_NONE;
slicers.c:    level = IS_NPC(ch) ? ch->top_level : (int) (ch->pcdata->learned[gsn_makecommsystem]);
slicers.c:    for ( obj = ch->last_carrying; obj; obj = obj->prev_content )
slicers.c:    chance = IS_NPC(ch) ? ch->top_level
slicers.c:                : (int) (ch->pcdata->learned[gsn_makecommsystem]) ;
slicers.c:       ch->hit -= 15;
slicers.c:         xpgain = UMIN( obj->cost*10 ,( exp_level(ch->skill_level[SLICER_ABILITY]+1) - exp_level(ch->skill_level[SLICER_ABILITY]) )
slicers.c: switch( ch->substate )
slicers.c:    if ( !IS_SET( ch->in_room->room_flags, ROOM_FACTORY ) )
slicers.c:    for ( obj = ch->last_carrying; obj; obj = obj->prev_content )
slicers.c:     chance = IS_NPC(ch) ? ch->top_level
slicers.c:        : (int) (ch->pcdata->learned[gsn_makedatapad]);
slicers.c:    	ch->dest_buf   = str_dup(arg);
slicers.c:    	  if ( !ch->dest_buf )
slicers.c:    	  strcpy(arg, ch->dest_buf);
slicers.c:    	  DISPOSE( ch->dest_buf);
slicers.c:    	  DISPOSE( ch->dest_buf );
slicers.c:    	  ch->substate = SUB_NONE;
slicers.c:    ch->substate = SUB_NONE;
slicers.c:    level = IS_NPC(ch) ? ch->top_level : (int) (ch->pcdata->learned[gsn_makedatapad]);
slicers.c:    for ( obj = ch->last_carrying; obj; obj = obj->prev_content )
slicers.c:    chance = IS_NPC(ch) ? ch->top_level
slicers.c:                : (int) (ch->pcdata->learned[gsn_makedatapad]) ;
slicers.c:              ch->hit -= 15;
slicers.c:         xpgain = UMIN( obj->cost*10 ,( exp_level(ch->skill_level[SLICER_ABILITY]+1) - exp_level(ch->skill_level[SLICER_ABILITY]) )
slicers.c:  switch( ch->substate )
slicers.c:    else if( (ship = ship_in_room(ch->in_room, arg)) != NULL)
slicers.c:	ship = ship_in_room(ch->in_room, arg);
slicers.c:     for ( obj = ch->last_carrying; obj; obj = obj->prev_content )
slicers.c:     chance = IS_NPC(ch) ? ch->top_level
slicers.c:        : (int) (ch->pcdata->learned[gsn_codecrack]);
slicers.c:    	if ( (ship = ship_in_room( ch->in_room , arg )) != NULL)
slicers.c:    	  ch->dest_buf   = str_dup(arg);
slicers.c:	ch->pcdata->is_hacking = FALSE;
slicers.c:    	  if ( !ch->dest_buf )
slicers.c:    	  strcpy(arg, ch->dest_buf);
slicers.c:    	  DISPOSE( ch->dest_buf);
slicers.c:    	  DISPOSE( ch->dest_buf );
slicers.c:    	  ch->substate = SUB_NONE;
slicers.c:    	  ch->pcdata->is_hacking = FALSE;
slicers.c:     ch->substate = SUB_NONE;
slicers.c:     for ( obj = ch->last_carrying; obj; obj = obj->prev_content )
slicers.c:     chance = IS_NPC(ch) ? ch->top_level
slicers.c:                : (int) (ch->pcdata->learned[gsn_codecrack]);
slicers.c:    ship = ship_in_room(ch->in_room,arg);
slicers.c:        ch_printf(ch,"&B[&r^O Login           &W^O: %-20.20s           &B^x]&W^x\r\n",ch->name);
slicers.c:       ch->pcdata->is_hacking = FALSE;
slicers.c:    ch->pcdata->is_hacking = FALSE;
slicers.c:        ch_printf(ch,"&B[&r^O Login           &W^O: %-20.20s           &B^x]&W^x\r\n",ch->name);
slicers.c:      //xpgain = UMIN( obj->cost*10 ,( exp_level(ch->skill_level[SLICER_ABILITY]+1) - exp_level(ch->skill_level[SLICER_ABILITY]) ) );
slicers.c:      ch->pcdata->is_hacking = FALSE;
slicers.c: switch( ch->substate )
slicers.c:  if ((ship1 = ship_from_cockpit(ch->in_room->vnum)) == NULL)
slicers.c:  for ( obj = ch->last_carrying; obj; obj = obj->prev_content )
slicers.c:  chance = IS_NPC(ch) ? ch->top_level
slicers.c:   : (int) (ch->pcdata->learned[gsn_disable]);
slicers.c:    ch->dest_buf   = str_dup(arg1);
slicers.c:    ch->dest_buf   = str_dup(arg1);
slicers.c:    ch->dest_buf   = str_dup(arg1);
slicers.c:    ch->dest_buf   = str_dup(arg1);
slicers.c:   if ( !ch->dest_buf )
slicers.c:   strcpy(arg1, ch->dest_buf);
slicers.c:   DISPOSE( ch->dest_buf);
slicers.c:   DISPOSE( ch->dest_buf );
slicers.c:   ch->substate = SUB_NONE;
slicers.c:  for ( obj = ch->last_carrying; obj; obj = obj->prev_content )
slicers.c:  chance = IS_NPC(ch) ? ch->top_level
slicers.c:   : (int) (ch->pcdata->learned[gsn_disable]);
slicers.c:    ch_printf(ch,"&B[&r^O Login           &W^O: %-20.20s           &B^x]&W^x\r\n",ch->name);
slicers.c:  if ( IS_SET(ship->flags, SHIP_NOSLICER))// &&  ch->pcdata->in_room != room)
slicers.c:    ch_printf(ch,"&B[&r^O Login           &W^O: %-20.20s           &B^x]&W^x\r\n",ch->name);
slicers.c:        ch_printf(ch,"&B[^O &rLogin           &W: %-20.20s           &B^x]&W^x\r\n",ch->name);
slicers.c:      //xpgain = UMIN( obj->cost*10 ,( exp_level(ch->skill_level[SLICER_ABILITY]+1) - exp_level(ch->skill_level[SLICER_ABILITY]) ) );
slicers.c: switch( ch->substate )
slicers.c:  if ((ship1 = ship_from_cockpit(ch->in_room->vnum)) == NULL)
slicers.c:  for ( obj = ch->last_carrying; obj; obj = obj->prev_content )
slicers.c:  chance = IS_NPC(ch) ? ch->top_level
slicers.c:   : (int) (ch->pcdata->learned[gsn_assignpilot]);
slicers.c:    ch->dest_buf   = str_dup(arg1);
slicers.c:   if ( !ch->dest_buf )
slicers.c:   strcpy(arg1, ch->dest_buf);
slicers.c:   DISPOSE( ch->dest_buf);
slicers.c:   DISPOSE( ch->dest_buf );
slicers.c:   ch->substate = SUB_NONE;
slicers.c:  for ( obj = ch->last_carrying; obj; obj = obj->prev_content )
slicers.c:  chance = IS_NPC(ch) ? ch->top_level
slicers.c:   : (int) (ch->pcdata->learned[gsn_assignpilot]);
slicers.c:  ship = ship_from_cockpit(ch->in_room->vnum);
slicers.c:    ch_printf(ch,"&B[&r^O Login           &W^O: %-20.20s           &B^x]&W^x\r\n",ch->name);
slicers.c:    ch_printf(ch,"&B[&r^O Login           &W^O: %-20.20s           &B^x]&W^x\r\n",ch->name);
slicers.c:       ch_printf(ch,"&B[&r^O Login           &W^O: %-20.20s           &B^x]&W^x\r\n",ch->name);
slicers.c:      //xpgain = UMIN( obj->cost*10 ,( exp_level(ch->skill_level[SLICER_ABILITY]+1) - exp_level(ch->skill_level[SLICER_ABILITY]) ) );
slicers.c:  switch( ch->substate )
slicers.c:     if ( ch->fighting )
slicers.c:     if(!IS_SET(ch->in_room->room_flags, ROOM_BANK))
slicers.c:     for ( obj = ch->last_carrying; obj; obj = obj->prev_content )
slicers.c:    	  ch->dest_buf   = str_dup(arg);
slicers.c:    	  ch->dest_buf_2   = str_dup(arg2);
slicers.c:    	  if ( !ch->dest_buf )
slicers.c:    	  if ( !ch->dest_buf_2 )
slicers.c:    	  strcpy(arg, ch->dest_buf);
slicers.c:    	  strcpy(arg2, ch->dest_buf_2);
slicers.c:    	  DISPOSE( ch->dest_buf);
slicers.c:    	  DISPOSE( ch->dest_buf_2);
slicers.c:    	  DISPOSE( ch->dest_buf );
slicers.c:    	  DISPOSE( ch->dest_buf_2 );
slicers.c:    	  ch->substate = SUB_NONE;
slicers.c:     ch->substate = SUB_NONE;
slicers.c:     for ( obj = ch->last_carrying; obj; obj = obj->prev_content )
slicers.c:     chance = IS_NPC(ch) ? ch->top_level
slicers.c:                : (int) (ch->pcdata->learned[gsn_slicebank]);
slicers.c:        ch->pcdata->bank+=steal;
slicers.c:      //xpgain = UMIN( obj->cost*10 ,( exp_level(ch->skill_level[SLICER_ABILITY]+1) - exp_level(ch->skill_level[SLICER_ABILITY]) ) );
slicers.c:  switch( ch->substate )
slicers.c:     for ( obj = ch->last_carrying; obj; obj = obj->prev_content )
slicers.c:     if ( ch->fighting )
slicers.c:     obj = get_obj_list( ch, argument, ch->in_room->first_content );
slicers.c:     chance = IS_NPC(ch) ? ch->top_level
slicers.c:        : (int) (ch->pcdata->learned[gsn_checkprints]);
slicers.c:      	  ch->dest_buf   = str_dup(arg);
slicers.c:    	  if ( !ch->dest_buf )
slicers.c:    	  strcpy(arg, ch->dest_buf);
slicers.c:    	  DISPOSE( ch->dest_buf);
slicers.c:    	  DISPOSE( ch->dest_buf );
slicers.c:    	  ch->substate = SUB_NONE;
slicers.c:     ch->substate = SUB_NONE;
slicers.c:     for ( obj = ch->last_carrying; obj; obj = obj->prev_content )
slicers.c:     chance = IS_NPC(ch) ? ch->top_level
slicers.c:                : (int) (ch->pcdata->learned[gsn_checkprints]);
slicers.c:     obj = get_obj_list( ch, arg, ch->in_room->first_content );
slicers.c:        ch_printf(ch,"&B[^O &rLogin           &W: %-20.20s           &B^x]&W^x\r\n",ch->name);
slicers.c:        ch_printf(ch,"&B[^O &rLogin           &W: %-20.20s           &B^x]&W^x\r\n",ch->name);
slicers.c:      //xpgain = UMIN( obj->cost*10 ,( exp_level(ch->skill_level[SLICER_ABILITY]+1) - exp_level(ch->skill_level[SLICER_ABILITY]) ) );
slotm.c:	if( !IS_SET( ch->in_room->room_flags2, ROOM_SLOTS) )
slotm.c:    if(ch->gold < atoi(argument))
slotm.c:	ch->gold -= amount;
slotm.c:		ch->gold += ( (*winningsmult) * (*amount) );
space.c:                    	for ( ch = first_char; ch; ch = ch->next )
space.c:                      	if ( !IS_NPC( ch ) && nifty_is_name( missile->fired_by, ch->name ) )
space.c:        if ( str_cmp(ship->owner, ch->name) )
space.c:           if ( !ch->pcdata || !ch->pcdata->clan || str_cmp(ship->owner,ch->pcdata->clan->name) || ship->class > SHIP_SPACE_STATION )
space.c:        if ( ship->location != ch->in_room->vnum || ship->class > SHIP_SPACE_STATION)
space.c:        if ( str_cmp(ship->owner, ch->name) )
space.c:           if ( !ch->pcdata || !ch->pcdata->clan || str_cmp(ship->owner,ch->pcdata->clan->name) || ship->class <= SHIP_SPACE_STATION )
space.c:        if ( ship->location != ch->in_room->vnum || ship->class != LAND_VEHICLE)
space.c:        if ( ship->location != ch->in_room->vnum || ship->class != LAND_VEHICLE)
space.c:        missile->fired_by = STRALLOC( ch->name );
space.c:   if ( !str_cmp(ch->name,ship->owner) || !str_cmp(ch->name,ship->pilot) 
space.c:   || !str_cmp(ch->name,ship->copilot) || !str_cmp("Public",ship->owner) )
space.c:   if ( !IS_NPC(ch) && ch->pcdata && ch->pcdata->clan )
space.c:      if ( !str_cmp(ch->pcdata->clan->name,ship->owner) ) 
space.c:        if ( !str_cmp(ch->pcdata->clan->leader,ch->name) )
space.c:        if ( !str_cmp(ch->pcdata->clan->number1,ch->name) )
space.c:        if ( !str_cmp(ch->pcdata->clan->number2,ch->name) )
space.c:        if ( ch->pcdata->bestowments && is_name( "pilot", ch->pcdata->bestowments) )
space.c:    xp = ( exp_level( ch->skill_level[PILOTING_ABILITY]+1) - exp_level( ch->skill_level[PILOTING_ABILITY]) ) / 25 ;
space.c:    if(ch->pcdata->learned[gsn_spacecombat] > 1 && ch->pcdata->learned[gsn_spacecombat2] < 1 && ch->pcdata->learned[gsn_spacecombat3] < 1 )
space.c:    else if(ch->pcdata->learned[gsn_spacecombat] > 1 && ch->pcdata->learned[gsn_spacecombat2] > 1 && ch->pcdata->learned[gsn_spacecombat3] < 1 )
space.c:    else if(ch->pcdata->learned[gsn_spacecombat] > 1 && ch->pcdata->learned[gsn_spacecombat2] > 1 && ch->pcdata->learned[gsn_spacecombat3] > 1 )
space.c:       xp =  ( exp_level( ch->skill_level[PILOTING_ABILITY]+1) - exp_level( ch->skill_level[PILOTING_ABILITY]) );
space.c:    xp = ( exp_level( ch->skill_level[PILOTING_ABILITY]+1) - exp_level( ch->skill_level[PILOTING_ABILITY]) ) / 25;
space.c:    ch ? ch->name : "No CH", reason);
space.c:            sprintf(buf, "%s killed in space, onboard %s.", rch->name, ship->name);
space.c:   if ( ( ship = ship_in_room( ch->in_room , argument ) ) == NULL )
space.c:   if ( IS_SET( ch->act, ACT_MOUNTED ) )
space.c:       if ( ch->gold < price )
space.c:       ch->gold -= price;
space.c:    fromroom = ch->in_room;
space.c:    	        if ( (ship = ship_from_cockpit(ch->in_room->vnum)) == NULL )  
space.c:    	        if ( (ship = ship_from_pilotseat(ch->in_room->vnum)) == NULL )  
space.c:               	  ch->hit-=number_range(0,50);
space.c:                    chance = IS_NPC(ch) ? ch->top_level
space.c:	                 : (int)  (ch->pcdata->learned[gsn_smallspace]) ;
space.c:                    chance = IS_NPC(ch) ? ch->top_level
space.c:	                 : (int)  (ch->pcdata->learned[gsn_mediumspace]) ;
space.c:                    chance = IS_NPC(ch) ? ch->top_level
space.c:	                 : (int) (ch->pcdata->learned[gsn_largespace]);
space.c:    	          if ( ch->pcdata && ch->pcdata->clan && !str_cmp(ch->pcdata->clan->name,ship->owner) ) 
space.c:                   if ( ch->pcdata->clan->funds < price )
space.c:                       ch_printf(ch, "&R%s no parece tener créditos suficientes para preparar la nave para el despegue.\n\r", ch->pcdata->clan->name );
space.c:                   ch->pcdata->clan->funds -= price;
space.c:                   ch_printf(ch, "&G%s paga %ld créditos para preparar la nave para el despegue.\n\r", ch->pcdata->clan->name, price );   
space.c:		    if ( ch->gold < price )
space.c:                    ch->gold -= price;
space.c:    	        if ( (ship = ship_from_pilotseat(ch->in_room->vnum)) == NULL )
space.c:                               	   && ch->pcdata->clan
space.c:                               	   && str_cmp(room->area->planet->governed_by->name, ch->pcdata->clan->name)  )
space.c:                                  if(!ch->pcdata->clan)
space.c:	                 : (int)  (ch->pcdata->learned[gsn_shipsystems]) ;
space.c:                      int xp =  (exp_level( ch->skill_level[PILOTING_ABILITY]+1) - exp_level( ch->skill_level[PILOTING_ABILITY])) ;
space.c:    	        if (  (ship = ship_from_cockpit(ch->in_room->vnum))  == NULL )
space.c:                if (  (ship = ship_from_pilotseat(ch->in_room->vnum))  == NULL )
space.c:                    chance = IS_NPC(ch) ? ch->top_level
space.c:	                 : (int)  (ch->pcdata->learned[gsn_smallspace]) ;
space.c:                    chance = IS_NPC(ch) ? ch->top_level
space.c:	                 : (int)  (ch->pcdata->learned[gsn_mediumspace]) ;
space.c:                    chance = IS_NPC(ch) ? ch->top_level
space.c:	                 : (int) (ch->pcdata->learned[gsn_largespace]);
space.c:    	        if (  (ship = ship_from_cockpit(ch->in_room->vnum))  == NULL )
space.c:                if (  (ship = ship_from_pilotseat(ch->in_room->vnum))  == NULL )
space.c:                    chance = IS_NPC(ch) ? ch->top_level
space.c:	                 : (int)  (ch->pcdata->learned[gsn_smallspace]) ;
space.c:                    chance = IS_NPC(ch) ? ch->top_level
space.c:	                 : (int)  (ch->pcdata->learned[gsn_mediumspace]) ;
space.c:                    chance = IS_NPC(ch) ? ch->top_level
space.c:	                 : (int) (ch->pcdata->learned[gsn_largespace]);
space.c:   if ( IS_NPC(ch) || !ch->pcdata )
space.c:   ship = ship_in_room( ch->in_room , argument );
space.c:      ship = ship_from_cockpit( ch->in_room->vnum );
space.c:        if ( !ch->pcdata->clan || str_cmp( ch->pcdata->clan->name , "el imperio" ) )
space.c:         if ( !ch->pcdata->clan || !ch->pcdata->clan->mainclan || str_cmp( ch->pcdata->clan->mainclan->name , "El Imperio" ) )
space.c:        if ( !ch->pcdata->clan || str_cmp( ch->pcdata->clan->name , "La Nueva República" ) )
space.c:         if ( !ch->pcdata->clan || !ch->pcdata->clan->mainclan || str_cmp( ch->pcdata->clan->mainclan->name , "La Nueva República" ) ) 
space.c:    if ( ch->gold < price )
space.c:    ch->gold -= price;
space.c:	ship->owner = STRALLOC( ch->name );
space.c:   if ( IS_NPC(ch) || !ch->pcdata )
space.c:   if ( !ch->pcdata->clan )
space.c:   clan = ch->pcdata->clan;
space.c:   mainclan = ch->pcdata->clan->mainclan ? ch->pcdata->clan->mainclan : clan;
space.c:   if ( ( ch->pcdata->bestowments
space.c:    &&    is_name("clanbuyship", ch->pcdata->bestowments))
space.c:    ||   !str_cmp( ch->name, clan->leader  ))
space.c:   ship = ship_in_room( ch->in_room , argument );
space.c:      ship = ship_from_cockpit( ch->in_room->vnum );
space.c:    if ( ch->pcdata->clan->funds < price )
space.c:   ship = ship_in_room( ch->in_room , argument );
space.c:   if ( str_cmp( ship->owner , ch->name ) )
space.c:   if (!IS_NPC(ch) && ch->top_level < 11)
space.c:    ch->gold += ( price - price/10 );
space.c:    if (  (ship = ship_from_cockpit(ch->in_room->vnum))  == NULL )
space.c:            ship = ship_in_room( ch->in_room , argument );
space.c:    if(!str_cmp(target->owner, ch->name) || !str_cmp(target->pilot, ch->name) || !str_cmp(target->copilot, ch->name))
space.c:	else if(ch->pcdata->clan)
space.c:		if(!str_cmp(target->owner, ch->pcdata->clan->name))
space.c:        if (  (ship = ship_from_cockpit(ch->in_room->vnum))  == NULL )
space.c:        if (  (ship = ship_from_coseat(ch->in_room->vnum))  == NULL )
space.c:        chance = IS_NPC(ch) ? ch->top_level
space.c:             : (int)  (ch->pcdata->learned[gsn_shipsystems]) ;
space.c:        if (  (ship = ship_from_cockpit(ch->in_room->vnum))  == NULL )
space.c:        if (  (ship = ship_from_pilotseat(ch->in_room->vnum))  == NULL )
space.c:       ship = ship_from_entrance( ch->in_room->vnum );
space.c:   ship = ship_in_room( ch->in_room , arg1 );
space.c:   	ch->hit-=number_range(0,75);
space.c:       ship = ship_from_entrance( ch->in_room->vnum );
space.c:   ship = ship_in_room( ch->in_room , argument );
space.c:    if (  (ship = ship_from_cockpit(ch->in_room->vnum))  == NULL )
space.c:    chance = IS_NPC(ch) ? ch->top_level
space.c:        : (int)  (ch->pcdata->learned[gsn_shipsystems]) ;
space.c:        if (  (ship = ship_from_cockpit(ch->in_room->vnum))  == NULL )
space.c:        if (  (ship = ship_from_pilotseat(ch->in_room->vnum))  == NULL )
space.c:                    chance = IS_NPC(ch) ? ch->top_level
space.c:	                 : (int)  (ch->pcdata->learned[gsn_smallspace]) ;
space.c:                    chance = IS_NPC(ch) ? ch->top_level
space.c:	                 : (int)  (ch->pcdata->learned[gsn_mediumspace]) ;
space.c:                    chance = IS_NPC(ch) ? ch->top_level
space.c:	                 : (int) (ch->pcdata->learned[gsn_largespace]);
space.c:    switch( ch->substate )
space.c:    	        if (  (ship = ship_from_turret(ch->in_room->vnum))  == NULL )
space.c:    	            if ( ch->in_room->vnum == ship->gunseat )
space.c:    	            if ( ch->in_room->vnum == ship->turret1 )
space.c:    	            if ( ch->in_room->vnum == ship->turret2 )
space.c:					if ( ch->in_room->vnum == ship->turret3 )
space.c:					if ( ch->in_room->vnum == ship->turret4 )
space.c:					if ( ch->in_room->vnum == ship->turret5 )
space.c:					if ( ch->in_room->vnum == ship->turret6 )
space.c:					if ( ch->in_room->vnum == ship->turret7 )
space.c:					if ( ch->in_room->vnum == ship->turret8 )
space.c:					if ( ch->in_room->vnum == ship->turret9 )
space.c:					if ( ch->in_room->vnum == ship->turret10 )
space.c:                chance = IS_NPC(ch) ? ch->top_level
space.c:	                 : (int)  (ch->pcdata->learned[gsn_weaponsystems]) ;
space.c:    		   ch->dest_buf = str_dup(arg);
space.c:    		if ( !ch->dest_buf )
space.c:    		strcpy(arg, ch->dest_buf);
space.c:    		DISPOSE( ch->dest_buf);
space.c:    		DISPOSE( ch->dest_buf );
space.c:    		ch->substate = SUB_NONE;
space.c:    		if ( (ship = ship_from_cockpit(ch->in_room->vnum)) == NULL )
space.c:    ch->substate = SUB_NONE;
space.c:    if ( (ship = ship_from_turret(ch->in_room->vnum)) == NULL )
space.c:    if ( ch->in_room->vnum == ship->gunseat )
space.c:    if ( ch->in_room->vnum == ship->turret1 )
space.c:    if ( ch->in_room->vnum == ship->turret2 )
space.c:	if ( ch->in_room->vnum == ship->turret3 )
space.c:	if ( ch->in_room->vnum == ship->turret4 )
space.c:	if ( ch->in_room->vnum == ship->turret5 )
space.c:	if ( ch->in_room->vnum == ship->turret6 )
space.c:	if ( ch->in_room->vnum == ship->turret7 )
space.c:	if ( ch->in_room->vnum == ship->turret8 )
space.c:	if ( ch->in_room->vnum == ship->turret9 )
space.c:	if ( ch->in_room->vnum == ship->turret10 )
space.c:    sound_to_room( ch->in_room , "!!SOUND(targetlock)" );   	         
space.c:        if (  (ship = ship_from_turret(ch->in_room->vnum))  == NULL )
space.c:        chance = IS_NPC(ch) ? ch->top_level
space.c:                 : (int) ( ch->perm_dex*2 + ch->pcdata->learned[gsn_spacecombat]/3
space.c:                           + ch->pcdata->learned[gsn_spacecombat2]/3 + ch->pcdata->learned[gsn_spacecombat3]/3 );        
space.c:    	if ( ch->in_room->vnum == ship->gunseat && !str_prefix( arg , "primaria") )
space.c:                if ( ch->in_room->vnum == ship->gunseat && !str_prefix( arg , "secundaria") )
space.c:        if ( ch->in_room->vnum == ship->gunseat && !str_prefix( arg , "misil") )
space.c:        if ( ch->in_room->vnum == ship->gunseat && !str_prefix( arg , "torpedo") )
space.c:        if ( ch->in_room->vnum == ship->gunseat && !str_prefix( arg , "cohete") )
space.c:        if ( (ch->in_room->vnum == ship->turret1  && !str_prefix(argument, "laseres")) ||
space.c:             (ch->in_room->vnum == ship->turret2  && !str_prefix(argument, "laseres")) ||
space.c:             (ch->in_room->vnum == ship->turret3  && !str_prefix(argument, "laseres")) ||
space.c:             (ch->in_room->vnum == ship->turret4  && !str_prefix(argument, "laseres")) ||
space.c:             (ch->in_room->vnum == ship->turret5  && !str_prefix(argument, "laseres")) ||
space.c:             (ch->in_room->vnum == ship->turret5  && !str_prefix(argument, "laseres")) ||
space.c:             (ch->in_room->vnum == ship->turret6  && !str_prefix(argument, "laseres")) ||
space.c:             (ch->in_room->vnum == ship->turret7  && !str_prefix(argument, "laseres")) ||
space.c:             (ch->in_room->vnum == ship->turret8  && !str_prefix(argument, "laseres")) ||
space.c:             (ch->in_room->vnum == ship->turret9  && !str_prefix(argument, "laseres")) ||
space.c:             (ch->in_room->vnum == ship->turret10 && !str_prefix(argument, "laseres"))   )
space.c:    if(ch->in_room->vnum == ship->turret1)   		iTurret = 1;
space.c:    else if(ch->in_room->vnum == ship->turret2)   	iTurret = 2;
space.c:    else if(ch->in_room->vnum == ship->turret3)		iTurret = 3;
space.c:    else if(ch->in_room->vnum == ship->turret4)		iTurret = 4;
space.c:    else if(ch->in_room->vnum == ship->turret5)		iTurret = 5;
space.c:    else if(ch->in_room->vnum == ship->turret6)		iTurret = 6;
space.c:    else if(ch->in_room->vnum == ship->turret7)		iTurret = 7;
space.c:    else if(ch->in_room->vnum == ship->turret8)		iTurret = 8;
space.c:    else if(ch->in_room->vnum == ship->turret9)		iTurret = 9;
space.c:    else if(ch->in_room->vnum == ship->turret10)	iTurret = 10;
space.c:    	        if (  (ship = ship_from_cockpit(ch->in_room->vnum))  == NULL )
space.c:                if (  (ship = ship_from_navseat(ch->in_room->vnum))  == NULL )
space.c:                chance = IS_NPC(ch) ? ch->top_level
space.c:	                 : (int)  (ch->pcdata->learned[gsn_navigation]) ;
space.c:    sound_to_room( ch->in_room , "!!SOUND(computer)" );
space.c:        if (  (ship = ship_from_cockpit(ch->in_room->vnum))  == NULL )
space.c:        if (  (ship = ship_from_coseat(ch->in_room->vnum))  == NULL )
space.c:        chance = IS_NPC(ch) ? ch->top_level
space.c:                 : (int) (ch->pcdata->learned[gsn_shipsystems]);
space.c:   if (  (ship = ship_from_cockpit(ch->in_room->vnum))  == NULL )
space.c:   if ( str_cmp( ship->owner , ch->name ) )
space.c:     if ( !IS_NPC(ch) && ch->pcdata && ch->pcdata->clan && !str_cmp(ch->pcdata->clan->name,ship->owner) ) 
space.c:         if ( !str_cmp(ch->pcdata->clan->leader,ch->name) )
space.c:         else if ( !str_cmp(ch->pcdata->clan->number1,ch->name) )
space.c:         else if ( !str_cmp(ch->pcdata->clan->number2,ch->name) )
space.c:   if (  (ship = ship_from_cockpit(ch->in_room->vnum))  == NULL )
space.c:   if ( str_cmp( ship->owner , ch->name ) )
space.c:     if ( !IS_NPC(ch) && ch->pcdata && ch->pcdata->clan && !str_cmp(ch->pcdata->clan->name,ship->owner) ) 
space.c:         if ( !str_cmp(ch->pcdata->clan->leader,ch->name) )
space.c:         else if ( !str_cmp(ch->pcdata->clan->number1,ch->name) )
space.c:         else if ( !str_cmp(ch->pcdata->clan->number2,ch->name) )
space.c:        if (   (ship = ship_from_cockpit(ch->in_room->vnum))  == NULL )
space.c:        chance = IS_NPC(ch) ? ch->top_level
space.c:             : (int)  (ch->pcdata->learned[gsn_navigation]) ;
space.c:   if (  (ship = ship_from_cockpit(ch->in_room->vnum))  == NULL )
space.c:   if (  (ship = ship_from_pilotseat(ch->in_room->vnum))  == NULL )
space.c:   chance = IS_NPC(ch) ? ch->top_level
space.c:             : (int)  (ch->pcdata->learned[gsn_shipsystems]) ;
space.c: 	if( (ship = ship_from_pilotseat(ch->in_room->vnum)) == NULL )
space.c:	if ( (ship = ship_from_cockpit(ch->in_room->vnum)) == NULL )
space.c:	  if ( (ship = ship_from_pilotseat(ch->in_room->vnum)) == NULL )
space.c:	chance = IS_NPC(ch) ? ch->top_level
space.c:	: (int)  (ch->pcdata->learned[gsn_tractorbeams]);
space.c:	chance = IS_NPC(ch) ? ch->top_level
space.c:	: (int)  (ch->pcdata->learned[gsn_tractorbeams]);
space.c:     for ( obj = ch->last_carrying; obj; obj = obj->prev_content )
space.c:        if (  (ship = ship_from_cockpit(ch->in_room->vnum))  == NULL )
space.c:      if ( IS_DRUNK( ch, 2 ) && ( ch->position != POS_SHOVE )
space.c:	&& ( ch->position != POS_DRAG ) )
space.c:	sprintf( buf, "drive_ship: %s to door %d", ch->name, pexit->vdir );
space.c:    &&  ch->in_room->area != to_room->area )
space.c:	if ( ch->top_level < to_room->area->low_hard_range )
space.c:	    switch( to_room->area->low_hard_range - ch->top_level )
space.c:	if ( ch->top_level > to_room->area->hi_hard_range )
space.c:    for ( rch = ch->in_room->last_person ; rch ; rch = next_rch )
space.c:        next_rch = rch->prev_in_room;
space.c:        original = rch->in_room;
space.c:	|| ( ch->mount && !IS_AFFECTED( ch->mount, AFF_FLOATING ) ) )
space.c:  if ( (ship = ship_from_cockpit(ch->in_room->vnum)) == NULL ){
space.c:  chance = IS_NPC(ch) ? ch->top_level : (int)(ch->pcdata->learned[gsn_bomb]) ;
space.c:	obj->armed_by = ch->name;
space.c:        if (  (ship = ship_from_cockpit(ch->in_room->vnum))  == NULL )
space.c:        if (  (ship = ship_from_coseat(ch->in_room->vnum))  == NULL )
space.c:                chance = IS_NPC(ch) ? ch->top_level
space.c:                 : (int)  (ch->pcdata->learned[gsn_weaponsystems]) ;
space.c:    ship = ship_in_room( ch->in_room, argument );
space.c:    if (str_cmp(ship->owner, ch->name)){
space.c:   if (!IS_NPC(ch) && ch->top_level < 11)
space.c:    //sprintf(buf,"%s: removeship %s",ch->name,argument);
space.c:    if (!IS_SET(ch->in_room->room_flags2, ROOM_SHIPYARD) && !IS_SET(ch->in_room->room_flags2, ROOM_BLACKMARKET)){
space.c:   if(!IS_SET(ch->in_room->room_flags2, ROOM_BLACKMARKET))
space.c:    ch->gold+=value;
space.c:    ch->gold+=value;
space.c:    ship = ship_in_room( ch->in_room, argument );
space.c:   if ( !ch->pcdata->clan )
space.c:   clan = ch->pcdata->clan;
space.c:   if ( ( ch->pcdata->bestowments
space.c:    &&    is_name("clanbuyship", ch->pcdata->bestowments))
space.c:    ||   nifty_is_name( ch->name, clan->leader  ))
space.c:    if (str_cmp(ch->pcdata->clan->name,ship->owner) ) 
space.c:    if (!IS_SET(ch->in_room->room_flags2, ROOM_SHIPYARD))
space.c:  if ( (ship = ship_from_cockpit(ch->in_room->vnum)) == NULL )
space.c: ship = ship_in_room(ch->in_room, arg1);
space.c: if(str_cmp(ship->owner,ch->name))
space.c: if (!IS_NPC(ch) && ch->top_level < 11)
space.c: ch_printf(victim, "&R&G%s te da %s.\n\r", ch->name, ship->name);
space.c: sprintf(logbuf, "%s gave the ship %s to %s.\n\r", ch->name, ship->name, victim->name);
space.c: ship = ship_in_room(ch->in_room, arg1);
space.c: if(str_cmp(ship->owner,ch->name))
space.c: if (!IS_NPC(ch) && ch->top_level < 11)
space.c:  sprintf(logbuf, "%s gave the ship %s to %s.\n\r", ch->name, ship->name, clan->name);
space.c: 	if((ship = ship_from_pilotseat(ch->in_room->vnum)) == NULL)
space.c:	if(!str_cmp(ch->name, target->owner)) open = TRUE;
space.c: 	if(ch->pcdata->clan)
space.c:  	 if(!str_cmp(ch->pcdata->clan->name, target->owner))
space.c:   if( str_cmp( ship->owner, ch->name ) && ( ch->top_level < 57 ) && str_cmp( ship->owner, "public" ) ) 
space.c:   ship->sim_vnum = ch->in_room->vnum; 
space.c:    switch( ch->substate )
space.c:            if (  (ship = ship_from_engine(ch->in_room->vnum))  == NULL )
space.c:            chance = IS_NPC(ch) ? ch->top_level
space.c:                : (int) (ch->pcdata->learned[gsn_sabotage]);
space.c:                ch->dest_buf = str_dup(arg);
space.c:    		if ( !ch->dest_buf )
space.c:    		strcpy(arg, ch->dest_buf);
space.c:    		DISPOSE( ch->dest_buf);
space.c:    		DISPOSE( ch->dest_buf );
space.c:    		ch->substate = SUB_NONE;
space.c:    		if ( (ship = ship_from_engine(ch->in_room->vnum))  == NULL )
space.c:    ch->substate = SUB_NONE;
space.c:    if ( (ship = ship_from_engine(ch->in_room->vnum)) == NULL )
space.c:    switch( ch->substate )
space.c:                if ( !IS_SET(  ch->in_room->room_flags, ROOM_FACTORY ) )
space.c:                for ( obj = ch->last_carrying; obj; obj = obj->prev_content ) 
space.c:    	        chance = IS_NPC(ch) ? ch->top_level
space.c:	                 : (int) (ch->pcdata->learned[gsn_makeshipbomb]);
space.c:    		   ch->dest_buf   = str_dup(arg);
space.c:    		if ( !ch->dest_buf )
space.c:    		strcpy(arg, ch->dest_buf);
space.c:    		DISPOSE( ch->dest_buf);
space.c:    		DISPOSE( ch->dest_buf );
space.c:    		ch->substate = SUB_NONE;    		                                   
space.c:    ch->substate = SUB_NONE;
space.c:    level = IS_NPC(ch) ? ch->top_level : (int) (ch->pcdata->learned[gsn_makeshipbomb]);
space.c:    for ( obj = ch->last_carrying; obj; obj = obj->prev_content )     
space.c:    chance = IS_NPC(ch) ? ch->top_level
space.c:                : (int) (ch->pcdata->learned[gsn_makeshipbomb]) ;
space.c:         xpgain = UMIN( obj->cost*50 ,( exp_level(ch->skill_level[ENGINEERING_ABILITY]+1) - exp_level(ch->skill_level[ENGINEERING_ABILITY]) ) );
space.c:    if( (ch->pcdata->learned[gsn_shiprepair]) <= 0)
space.c:    switch( ch->substate )
space.c:				   if( (ship = ship_from_engine(ch->in_room->vnum)) == NULL)
space.c:				   if( (ship = ship_from_turret(ch->in_room->vnum)) == NULL)
space.c:        if(ch->in_room->vnum == ship->turret1) {if(ship->statet1 == LASER_READY){send_to_char("&GEsta torreta funciona correctamente.\n\r", ch); return;}}
space.c:		else if(ch->in_room->vnum == ship->turret2) {if(ship->statet2 == LASER_READY){send_to_char("&GEsta torreta funciona correctamente.\n\r", ch); return;}}
space.c:		else if(ch->in_room->vnum == ship->turret3) {if(ship->statet3 == LASER_READY){send_to_char("&GEsta torreta funciona correctamente.\n\r", ch); return;}}
space.c:		else if(ch->in_room->vnum == ship->turret4) {if(ship->statet4 == LASER_READY){send_to_char("&GEsta torreta funciona correctamente.\n\r", ch); return;}}
space.c:		else if(ch->in_room->vnum == ship->turret5) {if(ship->statet5 == LASER_READY){send_to_char("&GEsta torreta funciona correctamente.\n\r", ch); return;}}
space.c:		else if(ch->in_room->vnum == ship->turret6) {if(ship->statet6 == LASER_READY){send_to_char("&GEsta torreta funciona correctamente.\n\r", ch); return;}}
space.c:		else if(ch->in_room->vnum == ship->turret7) {if(ship->statet7 == LASER_READY){send_to_char("&GEsta torreta funciona correctamente.\n\r", ch); return;}}
space.c:		else if(ch->in_room->vnum == ship->turret8) {if(ship->statet8 == LASER_READY){send_to_char("&GEsta torreta funciona correctamente.\n\r", ch); return;}}
space.c:		else if(ch->in_room->vnum == ship->turret9) {if(ship->statet9 == LASER_READY){send_to_char("&GEsta torreta funciona correctamente.\n\r", ch); return;}}
space.c:		else if(ch->in_room->vnum == ship->turret10) {if(ship->statet10 == LASER_READY){send_to_char("&GEsta torreta funciona correctamente.\n\r", ch); return;}}
space.c:                chance = IS_NPC(ch) ? ch->top_level
space.c:	                 : (int) (ch->pcdata->learned[gsn_shiprepair]);
space.c:    		   ch->dest_buf = str_dup(arg);
space.c:    		if ( !ch->dest_buf )
space.c:    		strcpy(arg, ch->dest_buf);
space.c:    		DISPOSE( ch->dest_buf);
space.c:    		DISPOSE( ch->dest_buf );
space.c:    		ch->substate = SUB_NONE;
space.c:    ch->substate = SUB_NONE;
space.c:    if ( (ship = ship_from_engine(ch->in_room->vnum)) == NULL && (ship = ship_from_turret(ch->in_room->vnum)) == NULL)
space.c:                         number_range( (int) ( ch->pcdata->learned[gsn_shiprepair] / 2 ) , (int) (ch->pcdata->learned[gsn_shiprepair]) ),
space.c:        if(ch->in_room->vnum == ship->turret1) ship->statet1 = LASER_READY;
space.c:		if(ch->in_room->vnum == ship->turret2) ship->statet2 = LASER_READY;
space.c:		if(ch->in_room->vnum == ship->turret3) ship->statet3 = LASER_READY;
space.c:		if(ch->in_room->vnum == ship->turret4) ship->statet4 = LASER_READY; 
space.c:		if(ch->in_room->vnum == ship->turret5) ship->statet5 = LASER_READY; 
space.c:		if(ch->in_room->vnum == ship->turret6) ship->statet6 = LASER_READY; 
space.c:		if(ch->in_room->vnum == ship->turret7) ship->statet7 = LASER_READY; 
space.c:		if(ch->in_room->vnum == ship->turret8) ship->statet8 = LASER_READY; 
space.c:		if(ch->in_room->vnum == ship->turret9) ship->statet9 = LASER_READY; 
space.c:		if(ch->in_room->vnum == ship->turret10) ship->statet10 = LASER_READY; 
space.c:    sprintf(buf,"%s: removeship %s",ch->name,argument);
space.c:    if ( (ship = ship_from_cockpit(ch->in_room->vnum)) == NULL )
space.c:  if ((ship = ship_from_cockpit(ch->in_room->vnum)) == NULL)
space.c: switch( ch->substate )
space.c: ch->substate = SUB_NONE;    		                                   
space.c:	    for ( obj = ch->last_carrying; obj; obj = obj->prev_content )
space.c:		if ( IS_SET( ch->in_room->room_flags, ROOM_SILENCE ) )
space.c:    switch( ch->substate )
space.c:	    for ( obj = ch->last_carrying; obj; obj = obj->prev_content )
space.c:	 if (!IS_NPC(ch) && IS_SET(ch->pcdata->act2, ACT_GAGGED))
space.c:		&& ( IS_SET(ch->act, PLR_SILENCE) ))
space.c:		if ( IS_SET( ch->in_room->room_flags, ROOM_SILENCE ) )
space.c:        if ( !IS_SET( ch->in_room->room_flags, ROOM_CAN_LAND ) )
space.c:       roomloc = ch->in_room->vnum;
space.c:       ch->dest_buf = str_dup(argument);
space.c:    	 if ( !ch->dest_buf )
space.c:    	argument = str_dup(ch->dest_buf);
space.c:    	 DISPOSE( ch->dest_buf);
space.c:    	 if ( !ch->dest_buf )
space.c:    	argument = str_dup(ch->dest_buf);
space.c:    	 DISPOSE( ch->dest_buf);
space.c:    ch->substate = SUB_NONE;
space.c:    if ( !IS_SET( ch->in_room->room_flags, ROOM_CAN_LAND ) )
space.c:    roomloc = ch->in_room->vnum;
space.c:	   for ( obj = ch->last_carrying; obj; obj = obj->prev_content )
space.c:	 if (!IS_NPC(ch) && IS_SET(ch->pcdata->act2, ACT_BOUND))
space.c:         if ( IS_SET( ch->in_room->room_flags, ROOM_SILENCE ) )
space.c:	    for ( obj = ch->last_carrying; obj; obj = obj->prev_content )
space.c:	 if (!IS_NPC(ch) && IS_SET(ch->pcdata->act2, ACT_GAGGED))
space.c:		&& ( IS_SET(ch->act, PLR_SILENCE) ))
space.c:		if ( IS_SET( ch->in_room->room_flags, ROOM_SILENCE ) )
space.c:    original = ch->in_room;
space.c:    for ( wch = first_char; wch; wch = wch->next )
space.c: if( (ship = ship_from_cockpit(ch->in_room->vnum)) == NULL )
space.c:	chance = IS_NPC(ch) ? ch->top_level*2 : ch->pcdata->learned[gsn_split_s]-5;
space.c:  chance = IS_NPC(ch) ? ch->top_level*2 : ch->pcdata->learned[gsn_split_s];
space.c:   target = ship_in_room( ch->in_room , argument );
space.c:   if ( !IS_SET( ch->in_room->room_flags2, ROOM_IMPORT )
space.c:        && !IS_SET( ch->in_room->room_flags, ROOM_SPACECRAFT ))
space.c:   planet = ch->in_room->area->planet;
space.c:      ship = ship_from_hanger( ch->in_room->vnum );
space.c:   ch->gold += cost;
space.c:   target = ship_in_room( ch->in_room , arg1 );
space.c:   if ( !IS_SET( ch->in_room->room_flags2, ROOM_IMPORT )
space.c:        && !IS_SET( ch->in_room->room_flags, ROOM_SPACECRAFT ))
space.c:   planet = ch->in_room->area->planet;
space.c:      ship = ship_from_hanger( ch->in_room->vnum );
space.c:   if (ch->gold < cost)
space.c:   ch->gold -= cost;
special.c:    for ( victim = ch->in_room->first_person; victim; victim = v_next )
special.c:    for ( victim = ch->in_room->first_person; victim; victim = v_next )
special.c:    for ( victim = ch->in_room->first_person; victim; victim = v_next )
special.c:    for ( victim = ch->in_room->first_person; victim; victim = v_next )
special.c:                 echo_to_room( AT_ACTION , ch->in_room, buf );
special.c:                 echo_to_room( AT_ACTION , ch->in_room, "After a brief journey the shuttle docks with the Serin Pluogus.\n\r\n\r" );
special.c:        echo_to_room( AT_ACTION , ch->in_room, buf );
special.c:    if ( !IS_AWAKE(ch) || ch->fighting )
special.c:    for ( victim = ch->in_room->first_person; victim; victim = v_next )
special.c:               && ch->mob_clan && str_cmp( ch->mob_clan , victim->pcdata->clan->name ) )
special.c:  if ( !IS_AWAKE(ch) || ch->fighting )
special.c:    for ( victim = ch->in_room->first_person; victim; victim = v_next )
special.c:               && str_cmp( ch->mob_clan , victim->pcdata->clan->name ) )
special.c:              sprintf(buf, "You are not loyal to %s", ch->mob_clan);
special.c:        if ( IS_NPC(victim) && IS_AWAKE(victim) && str_cmp( ch->mob_clan , victim->mob_clan) )
special.c:              sprintf(buf, "You are not loyal to %s", ch->mob_clan);
special.c:    if ( !IS_AWAKE(ch) || ch->position == POS_FIGHTING )
special.c:    for ( victim = ch->in_room->first_person; victim; victim = v_next )
special.c:    if ( !IS_AWAKE(ch) || ch->position == POS_FIGHTING )
special.c:    for ( victim = ch->in_room->first_person; victim; victim = v_next )
special.c:      if (  victim->pcdata && victim->pcdata->clan && (!str_cmp(victim->pcdata->clan->name , ch->mob_clan) || (ch->in_room->area && ch->in_room->area->planet && ch->in_room->area->planet->governed_by && ch->in_room->area->planet->governed_by == victim->pcdata->clan)))
special.c:    if ( !IS_AWAKE(ch) || ch->position == POS_FIGHTING )
special.c:    for ( victim = ch->in_room->first_person; victim; victim = v_next )
special.c:    if ( !IS_AWAKE(ch) || ch->position == POS_FIGHTING )
special.c:    for ( victim = ch->in_room->first_person; victim; victim = v_next )
special.c:    if ( !IS_AWAKE(ch) || ch->fighting )
special.c:    for ( victim = ch->in_room->first_person; victim; victim = v_next )
special.c:          if ( IS_SET ( ch->vip_flags , 1 << vip ) &&  IS_SET( victim->pcdata->wanted_flags , 1 << vip) && victim->hit >= 50) 
special.c:              if ( ch->top_level >= victim->top_level ) 
special.c:    if ( !IS_AWAKE(ch) || ch->fighting )
special.c:    for ( victim = ch->in_room->first_person; victim; victim = v_next )
special.c:          if ( IS_SET ( ch->vip_flags , 1 << vip ) &&  IS_SET( victim->pcdata->wanted_flags , 1 << vip) && victim->hit >= 50) 
special.c:    if ( !IS_AWAKE(ch) || ch->fighting )
special.c:    for ( victim = ch->in_room->first_person; victim; victim = v_next )
special.c:          if ( IS_SET ( ch->vip_flags , 1 << vip ) &&  IS_SET( victim->pcdata->wanted_flags , 1 << vip) ) 
special.c:    if ( !IS_AWAKE(ch) || ch->fighting )
special.c:    for ( victim = ch->in_room->first_person; victim; victim = v_next )
special.c:          if ( IS_SET ( ch->vip_flags , 1 << vip ) &&  IS_SET( victim->pcdata->wanted_flags , 1 << vip) ) 
special.c:    for ( victim = ch->in_room->first_person; victim; victim = v_next )
special.c:	spell_smaug( skill_lookup( "armor" ), ch->top_level, ch, victim );
special.c:	spell_smaug( skill_lookup( "good fortune" ), ch->top_level, ch, victim );
special.c:	    ch->top_level, ch, victim );
special.c:	    ch->top_level, ch, victim );
special.c:	    ch->top_level, ch, victim );
special.c:	spell_smaug( skill_lookup( "refresh" ), ch->top_level, ch, victim );
special.c:    if ( ch->position != POS_FIGHTING )
special.c:    for ( victim = ch->in_room->first_person; victim; victim = v_next )
special.c:	if ( ch->top_level >= min_level )
special.c:    (*skill_table[sn]->spell_fun) ( sn, ch->top_level, ch, victim );
special.c:    for ( corpse = ch->in_room->first_content; corpse; corpse = c_next )
special.c:	    obj_to_room( obj, ch->in_room );
special.c:    if ( !IS_AWAKE(ch) || ch->fighting )
special.c:    for ( victim = ch->in_room->first_person; victim; victim = v_next )
special.c:    if ( !IS_AWAKE(ch) || ch->fighting )
special.c:    for ( victim = ch->in_room->first_person; victim; victim = v_next )
special.c:    if ( !IS_AWAKE(ch) || ch->fighting )
special.c:    for ( victim = ch->in_room->first_person; victim; victim = v_next )
special.c:    if ( victim && IS_SET( ch->in_room->room_flags, ROOM_SAFE ) )
special.c:    for ( trash = ch->in_room->first_content; trash; trash = trash_next )
special.c:        if( IS_OBJ_STAT( trash, ITEM_PROTOTYPE ) && !IS_SET( ch->act, ACT_PROTOTYPE ) )
special.c:    if ( ch->position != POS_FIGHTING
special.c:    ||   number_percent( ) > 2 * ch->top_level )
special.c:    spell_poison( gsn_poison, ch->top_level, ch, victim );
special.c:    if ( ch->position != POS_STANDING )
special.c:    for ( victim = ch->in_room->first_person; victim; victim = v_next )
special.c:	if ( IS_AWAKE(victim) && number_range( 0, ch->top_level ) == 0 )
special.c:	    maxgold = ch->top_level * ch->top_level * 1000;
special.c:	    	 * number_range( 1, URANGE(2, ch->top_level/4, 10) ) / 100;
special.c:	    ch->gold     += 9 * gold / 10;
special.c:	    if ( ch->gold > maxgold )
special.c:		boost_economy( ch->in_room->area, ch->gold - maxgold/2 );
special.c:		ch->gold = maxgold/2;
special.c:    for ( victim = ch->in_room->first_person; victim; victim = v_next )
special.c:            victim->pcdata->authed_by = QUICKLINK( ch->name );
special.c:            sprintf( buf, "%s authorized %s", ch->name,
special.c:            to_channel( buf, CHANNEL_MONITOR, "Monitor", ch->top_level );
special.c:    for ( victim = ch->in_room->first_person; victim; victim = v_next )
special.c:            sprintf( buf, "%s gave a slug to %s", ch->name,victim->name );
special.c:            to_channel( buf, CHANNEL_MONITOR, "Monitor", ch->top_level );
swskills.c:    switch( ch->substate )
swskills.c:                if ( !IS_SET( ch->in_room->room_flags, ROOM_FACTORY ) )
swskills.c:                for ( obj = ch->last_carrying; obj; obj = obj->prev_content )     
swskills.c:    	        chance = IS_NPC(ch) ? ch->top_level
swskills.c:	                 : (int) (ch->pcdata->learned[gsn_makeblade]);
swskills.c:    		   ch->dest_buf = str_dup(arg);
swskills.c:    		if ( !ch->dest_buf )
swskills.c:    		strcpy(arg, ch->dest_buf);
swskills.c:    		DISPOSE( ch->dest_buf);
swskills.c:    		DISPOSE( ch->dest_buf );
swskills.c:    		ch->substate = SUB_NONE;    		                                   
swskills.c:    ch->substate = SUB_NONE;
swskills.c:    level = IS_NPC(ch) ? ch->top_level : (int) (ch->pcdata->learned[gsn_makeblade]);
swskills.c:    for ( obj = ch->last_carrying; obj; obj = obj->prev_content )     
swskills.c:    chance = IS_NPC(ch) ? ch->top_level
swskills.c:                : (int) (ch->pcdata->learned[gsn_makeblade]) ;
swskills.c:         xpgain = UMIN( obj->cost*200 ,( exp_level(ch->skill_level[ENGINEERING_ABILITY]+1) - exp_level(ch->skill_level[ENGINEERING_ABILITY]) ) );
swskills.c:    switch( ch->substate )
swskills.c:                if ( !IS_SET( ch->in_room->room_flags, ROOM_FACTORY ) )
swskills.c:                for ( obj = ch->last_carrying; obj; obj = obj->prev_content )     
swskills.c:    	        chance = IS_NPC(ch) ? ch->top_level
swskills.c:	                 : (int) (ch->pcdata->learned[gsn_makeblaster]);
swskills.c:    		   ch->dest_buf   = str_dup(arg);
swskills.c:    		if ( !ch->dest_buf )
swskills.c:    		strcpy(arg, ch->dest_buf);
swskills.c:    		DISPOSE( ch->dest_buf);
swskills.c:    		DISPOSE( ch->dest_buf );
swskills.c:    		ch->substate = SUB_NONE;    		                                   
swskills.c:    ch->substate = SUB_NONE;
swskills.c:    level = IS_NPC(ch) ? ch->top_level : (int) (ch->pcdata->learned[gsn_makeblaster]);
swskills.c:    for ( obj = ch->last_carrying; obj; obj = obj->prev_content )     
swskills.c:    chance = IS_NPC(ch) ? ch->top_level
swskills.c:                : (int) (ch->pcdata->learned[gsn_makeblaster]) ;
swskills.c:         xpgain = UMIN( obj->cost*50 ,( exp_level(ch->skill_level[ENGINEERING_ABILITY]+1) - exp_level(ch->skill_level[ENGINEERING_ABILITY]) ) );
swskills.c:    switch( ch->substate )
swskills.c:                if ( !IS_SET( ch->in_room->room_flags, ROOM_SAFE ) || !IS_SET( ch->in_room->room_flags, ROOM_SILENCE ))
swskills.c:                for ( obj = ch->last_carrying; obj; obj = obj->prev_content )     
swskills.c:    	        chance = IS_NPC(ch) ? ch->top_level
swskills.c:	                 : (int) (ch->pcdata->learned[gsn_makelightsaber]);
swskills.c:    		   ch->dest_buf = str_dup(arg);
swskills.c:    		if ( !ch->dest_buf )
swskills.c:    		strcpy(arg, ch->dest_buf);
swskills.c:    		DISPOSE( ch->dest_buf);
swskills.c:    		DISPOSE( ch->dest_buf );
swskills.c:    		ch->substate = SUB_NONE;    		                                   
swskills.c:    ch->substate = SUB_NONE;
swskills.c:    level = IS_NPC(ch) ? ch->top_level : (int) (ch->pcdata->learned[gsn_makelightsaber]);
swskills.c:    for ( obj = ch->last_carrying; obj; obj = obj->prev_content )     
swskills.c:    chance = IS_NPC(ch) ? ch->top_level
swskills.c:                : (int) (ch->pcdata->learned[gsn_makelightsaber]) ;
swskills.c:	 xpgain = UMIN( obj->cost*50 , (ch->pcdata->learned[gsn_makelightsaber] * 50));
swskills.c://         xpgain = UMIN( obj->cost*50 ,( exp_level(ch->skill_level[FORCE_ABILITY]+1) - exp_level(ch->skill_level[ENGINEERING_ABILITY]) ) );
swskills.c:    switch( ch->substate )
swskills.c:    	        if ( !IS_SET( ch->in_room->room_flags, ROOM_REFINERY ) )
swskills.c:    	        chance = IS_NPC(ch) ? ch->top_level
swskills.c:	                 : (int) (ch->pcdata->learned[gsn_spice_refining]);
swskills.c:    		   ch->dest_buf = str_dup(arg);
swskills.c:    		if ( !ch->dest_buf )
swskills.c:    		strcpy(arg, ch->dest_buf);
swskills.c:    		DISPOSE( ch->dest_buf);
swskills.c:    		DISPOSE( ch->dest_buf );
swskills.c:    		ch->substate = SUB_NONE;    		                                   
swskills.c:    ch->substate = SUB_NONE;
swskills.c:    obj->value[1] = URANGE (10, obj->value[1], ( IS_NPC(ch) ? ch->top_level
swskills.c:	                 : (int) (ch->pcdata->learned[gsn_spice_refining]) ) +10);
swskills.c:         xpgain = UMIN( obj->cost*50 ,( exp_level(ch->skill_level[ENGINEERING_ABILITY]+1) - exp_level(ch->skill_level[ENGINEERING_ABILITY]) ) );
swskills.c:    switch( ch->substate )
swskills.c:                if ( !IS_SET( ch->in_room->room_flags, ROOM_FACTORY ) )
swskills.c:                for ( obj = ch->last_carrying; obj; obj = obj->prev_content )     
swskills.c:    	        chance = IS_NPC(ch) ? ch->top_level
swskills.c:	                 : (int) (ch->pcdata->learned[gsn_makegrenade]);
swskills.c:    		   ch->dest_buf   = str_dup(arg);
swskills.c:    		if ( !ch->dest_buf )
swskills.c:    		strcpy(arg, ch->dest_buf);
swskills.c:    		DISPOSE( ch->dest_buf);
swskills.c:    		DISPOSE( ch->dest_buf );
swskills.c:    		ch->substate = SUB_NONE;    		                                   
swskills.c:    ch->substate = SUB_NONE;
swskills.c:    level = IS_NPC(ch) ? ch->top_level : (int) (ch->pcdata->learned[gsn_makegrenade]);
swskills.c:    for ( obj = ch->last_carrying; obj; obj = obj->prev_content )     
swskills.c:    chance = IS_NPC(ch) ? ch->top_level
swskills.c:                : (int) (ch->pcdata->learned[gsn_makegrenade]) ;
swskills.c:         xpgain = UMIN( obj->cost*50 ,( exp_level(ch->skill_level[ENGINEERING_ABILITY]+1) - exp_level(ch->skill_level[ENGINEERING_ABILITY]) ) );
swskills.c:    switch( ch->substate )
swskills.c:                if ( !IS_SET( ch->in_room->room_flags, ROOM_FACTORY ) )
swskills.c:                for ( obj = ch->last_carrying; obj; obj = obj->prev_content )     
swskills.c:    	        chance = IS_NPC(ch) ? ch->top_level
swskills.c:	                 : (int) (ch->pcdata->learned[gsn_makelandmine]);
swskills.c:    		   ch->dest_buf   = str_dup(arg);
swskills.c:    		if ( !ch->dest_buf )
swskills.c:    		strcpy(arg, ch->dest_buf);
swskills.c:    		DISPOSE( ch->dest_buf);
swskills.c:    		DISPOSE( ch->dest_buf );
swskills.c:    		ch->substate = SUB_NONE;    		                                   
swskills.c:    ch->substate = SUB_NONE;
swskills.c:    level = IS_NPC(ch) ? ch->top_level : (int) (ch->pcdata->learned[gsn_makelandmine]);
swskills.c:    for ( obj = ch->last_carrying; obj; obj = obj->prev_content )     
swskills.c:    chance = IS_NPC(ch) ? ch->top_level
swskills.c:                : (int) (ch->pcdata->learned[gsn_makelandmine]) ;
swskills.c:         xpgain = UMIN( obj->cost*50 ,( exp_level(ch->skill_level[ENGINEERING_ABILITY]+1) - exp_level(ch->skill_level[ENGINEERING_ABILITY]) ) );
swskills.c:    switch( ch->substate )
swskills.c:                if ( !IS_SET( ch->in_room->room_flags, ROOM_FACTORY ) )
swskills.c:                for ( obj = ch->last_carrying; obj; obj = obj->prev_content )     
swskills.c:    	        chance = IS_NPC(ch) ? ch->top_level
swskills.c:	                 : (int) (ch->pcdata->learned[gsn_makelight]);
swskills.c:    		   ch->dest_buf   = str_dup(arg);
swskills.c:    		if ( !ch->dest_buf )
swskills.c:    		strcpy(arg, ch->dest_buf);
swskills.c:    		DISPOSE( ch->dest_buf);
swskills.c:    		DISPOSE( ch->dest_buf );
swskills.c:    		ch->substate = SUB_NONE;    		                                   
swskills.c:    ch->substate = SUB_NONE;
swskills.c:    level = IS_NPC(ch) ? ch->top_level : (int) (ch->pcdata->learned[gsn_makelight]);
swskills.c:    for ( obj = ch->last_carrying; obj; obj = obj->prev_content )     
swskills.c:    chance = IS_NPC(ch) ? ch->top_level
swskills.c:                : (int) (ch->pcdata->learned[gsn_makelight]) ;
swskills.c:         xpgain = UMIN( obj->cost*100 ,( exp_level(ch->skill_level[ENGINEERING_ABILITY]+1) - exp_level(ch->skill_level[ENGINEERING_ABILITY]) ) );
swskills.c:    switch( ch->substate )
swskills.c:                if ( !IS_SET( ch->in_room->room_flags, ROOM_FACTORY ) )
swskills.c:                for ( obj = ch->last_carrying; obj; obj = obj->prev_content )     
swskills.c:    	        chance = IS_NPC(ch) ? ch->top_level
swskills.c:	                 : (int) (ch->pcdata->learned[gsn_makejewelry]);
swskills.c:    		   ch->dest_buf = str_dup(arg);
swskills.c:    		   ch->dest_buf_2 = str_dup(arg2);
swskills.c:    		if ( !ch->dest_buf )
swskills.c:    		if ( !ch->dest_buf_2 )
swskills.c:    		strcpy(arg, ch->dest_buf);
swskills.c:    		DISPOSE( ch->dest_buf);
swskills.c:    		strcpy(arg2, ch->dest_buf_2);
swskills.c:    		DISPOSE( ch->dest_buf_2);
swskills.c:    		DISPOSE( ch->dest_buf );
swskills.c:    		DISPOSE( ch->dest_buf_2 );
swskills.c:    		ch->substate = SUB_NONE;    		                                   
swskills.c:    ch->substate = SUB_NONE;
swskills.c:    level = IS_NPC(ch) ? ch->top_level : (int) (ch->pcdata->learned[gsn_makejewelry]);
swskills.c:    for ( obj = ch->last_carrying; obj; obj = obj->prev_content )     
swskills.c:    chance = IS_NPC(ch) ? ch->top_level
swskills.c:                : (int) (ch->pcdata->learned[gsn_makejewelry]) ;
swskills.c:    obj->value[1] = (int)((ch->pcdata->learned[gsn_makejewelry])/20) + metal->value[1];
swskills.c:         xpgain = UMIN( obj->cost*100 ,( exp_level(ch->skill_level[ENGINEERING_ABILITY]+1) - exp_level(ch->skill_level[ENGINEERING_ABILITY]) ) );
swskills.c:    switch( ch->substate )
swskills.c:                if ( !IS_SET( ch->in_room->room_flags, ROOM_FACTORY ) )
swskills.c:                for ( obj = ch->last_carrying; obj; obj = obj->prev_content )     
swskills.c:    	        chance = IS_NPC(ch) ? ch->top_level
swskills.c:	                 : (int) (ch->pcdata->learned[gsn_makearmor]);
swskills.c:    		   ch->dest_buf = str_dup(arg);
swskills.c:    		   ch->dest_buf_2 = str_dup(arg2);
swskills.c:    		if ( !ch->dest_buf )
swskills.c:    		if ( !ch->dest_buf_2 )
swskills.c:    		strcpy(arg, ch->dest_buf);
swskills.c:    		DISPOSE( ch->dest_buf);
swskills.c:    		strcpy(arg2, ch->dest_buf_2);
swskills.c:    		DISPOSE( ch->dest_buf_2);
swskills.c:    		DISPOSE( ch->dest_buf );
swskills.c:    		DISPOSE( ch->dest_buf_2 );
swskills.c:    		ch->substate = SUB_NONE;    		                                   
swskills.c:    ch->substate = SUB_NONE;
swskills.c:    level = IS_NPC(ch) ? ch->top_level : (int) (ch->pcdata->learned[gsn_makearmor]);
swskills.c:    for ( obj = ch->last_carrying; obj; obj = obj->prev_content )     
swskills.c:    chance = IS_NPC(ch) ? ch->top_level
swskills.c:                : (int) (ch->pcdata->learned[gsn_makearmor]) ;
swskills.c:         xpgain = UMIN( obj->cost*100 ,( exp_level(ch->skill_level[ENGINEERING_ABILITY]+1) - exp_level(ch->skill_level[ENGINEERING_ABILITY]) ) );
swskills.c:	switch( ch->substate )
swskills.c:                if ( !IS_SET( ch->in_room->room_flags, ROOM_FACTORY ) )
swskills.c:                for ( obj = ch->last_carrying; obj; obj = obj->prev_content )     
swskills.c:    	        chance = IS_NPC(ch) ? ch->top_level
swskills.c:	                 : (int) (ch->pcdata->learned[gsn_makecomlink]);
swskills.c:    		   ch->dest_buf = str_dup(arg);
swskills.c:    		   ch->dest_buf_2 = str_dup(arg2);
swskills.c:    		if ( !ch->dest_buf )
swskills.c:    		strcpy(arg, ch->dest_buf);
swskills.c:    		DISPOSE( ch->dest_buf);
swskills.c:			strcpy(arg2, ch->dest_buf_2);
swskills.c:			DISPOSE( ch->dest_buf_2);
swskills.c:    		DISPOSE( ch->dest_buf );
swskills.c:    		ch->substate = SUB_NONE;    		                                   
swskills.c:    ch->substate = SUB_NONE;
swskills.c:    for ( obj = ch->last_carrying; obj; obj = obj->prev_content )     
swskills.c:    chance = IS_NPC(ch) ? ch->top_level
swskills.c:                : (int) (ch->pcdata->learned[gsn_makecomlink]) ;
swskills.c:    obj = create_object( pObjIndex, ch->top_level );
swskills.c:         xpgain = UMIN( obj->cost*100 ,( exp_level(ch->skill_level[ENGINEERING_ABILITY]+1) - exp_level(ch->skill_level[ENGINEERING_ABILITY]) ) );
swskills.c:    switch( ch->substate )
swskills.c:                if ( !IS_SET( ch->in_room->room_flags, ROOM_FACTORY ) )
swskills.c:                for ( obj = ch->last_carrying; obj; obj = obj->prev_content )     
swskills.c:    	        chance = IS_NPC(ch) ? ch->top_level
swskills.c:	                 : (int) (ch->pcdata->learned[gsn_makeshield]);
swskills.c:    		   ch->dest_buf = str_dup(arg);
swskills.c:    		if ( !ch->dest_buf )
swskills.c:    		strcpy(arg, ch->dest_buf);
swskills.c:    		DISPOSE( ch->dest_buf);
swskills.c:    		DISPOSE( ch->dest_buf );
swskills.c:    		ch->substate = SUB_NONE;    		                                   
swskills.c:    ch->substate = SUB_NONE;
swskills.c:    level = IS_NPC(ch) ? ch->top_level : (int) (ch->pcdata->learned[gsn_makeshield]);
swskills.c:    for ( obj = ch->last_carrying; obj; obj = obj->prev_content )     
swskills.c:    chance = IS_NPC(ch) ? ch->top_level
swskills.c:                : (int) (ch->pcdata->learned[gsn_makeshield]) ;
swskills.c:         xpgain = UMIN( obj->cost*50 ,( exp_level(ch->skill_level[ENGINEERING_ABILITY]+1) - exp_level(ch->skill_level[ENGINEERING_ABILITY]) ) );
swskills.c:    switch( ch->substate )
swskills.c:                if ( !IS_SET( ch->in_room->room_flags, ROOM_FACTORY ) )
swskills.c:                for ( obj = ch->last_carrying; obj; obj = obj->prev_content )     
swskills.c:    	        chance = IS_NPC(ch) ? ch->top_level
swskills.c:	                 : (int) (ch->pcdata->learned[gsn_makecontainer]);
swskills.c:    		   ch->dest_buf = str_dup(arg);
swskills.c:    		   ch->dest_buf_2 = str_dup(arg2);
swskills.c:    		if ( !ch->dest_buf )
swskills.c:    		if ( !ch->dest_buf_2 )
swskills.c:    		strcpy(arg, ch->dest_buf);
swskills.c:    		DISPOSE( ch->dest_buf);
swskills.c:    		strcpy(arg2, ch->dest_buf_2);
swskills.c:    		DISPOSE( ch->dest_buf_2);
swskills.c:    		DISPOSE( ch->dest_buf );
swskills.c:    		DISPOSE( ch->dest_buf_2 );
swskills.c:    		ch->substate = SUB_NONE;    		                                   
swskills.c:    ch->substate = SUB_NONE;
swskills.c:    level = IS_NPC(ch) ? ch->top_level : (int) (ch->pcdata->learned[gsn_makecontainer]);
swskills.c:    for ( obj = ch->last_carrying; obj; obj = obj->prev_content )     
swskills.c:    chance = IS_NPC(ch) ? ch->top_level
swskills.c:                : (int) (ch->pcdata->learned[gsn_makecontainer]) ;
swskills.c:         xpgain = UMIN( obj->cost*100 ,( exp_level(ch->skill_level[ENGINEERING_ABILITY]+1) - exp_level(ch->skill_level[ENGINEERING_ABILITY]) ) );
swskills.c:    if ( IS_NPC( ch ) || !ch->pcdata )
swskills.c:    switch( ch->substate )
swskills.c:    	        if ( ch->backup_wait )
swskills.c:    	        if ( !ch->pcdata->clan )
swskills.c:    	        if ( ch->gold < ch->skill_level[POLITICIAN_ABILITY] * 50 )
swskills.c:    	        chance = (int) (ch->pcdata->learned[gsn_reinforcements]);
swskills.c:    		   ch->dest_buf = str_dup(arg);
swskills.c:    		if ( !ch->dest_buf )
swskills.c:    		strcpy(arg, ch->dest_buf);
swskills.c:    		DISPOSE( ch->dest_buf);
swskills.c:    		DISPOSE( ch->dest_buf );
swskills.c:    		ch->substate = SUB_NONE;    		                                   
swskills.c:    ch->substate = SUB_NONE;
swskills.c:    credits = ch->skill_level[POLITICIAN_ABILITY] * 50;
swskills.c:    ch->gold -= UMIN( credits , ch->gold );
swskills.c:    if ( nifty_is_name( "empire" , ch->pcdata->clan->name ) )
swskills.c:       ch->backup_mob = MOB_VNUM_STORMTROOPER;
swskills.c:    else if ( nifty_is_name( "republic" , ch->pcdata->clan->name ) )
swskills.c:       ch->backup_mob = MOB_VNUM_NR_TROOPER;
swskills.c:       ch->backup_mob = MOB_VNUM_MERCINARY;
swskills.c:    ch->backup_wait = number_range(1,2);
swskills.c:    if ( IS_NPC( ch ) || !ch->pcdata )
swskills.c:    switch( ch->substate )
swskills.c:    	        if ( ch->backup_wait )
swskills.c:    	        if ( !ch->pcdata->clan )
swskills.c:    	        if ( ch->gold < ch->skill_level[POLITICIAN_ABILITY] * 30 )
swskills.c:    	        chance = (int) (ch->pcdata->learned[gsn_postguard]);
swskills.c:    		   ch->dest_buf = str_dup(arg);
swskills.c:    		if ( !ch->dest_buf )
swskills.c:    		strcpy(arg, ch->dest_buf);
swskills.c:    		DISPOSE( ch->dest_buf);
swskills.c:    		DISPOSE( ch->dest_buf );
swskills.c:    		ch->substate = SUB_NONE;    		                                   
swskills.c:    ch->substate = SUB_NONE;
swskills.c:    credits = ch->skill_level[POLITICIAN_ABILITY] * 30;
swskills.c:    ch->gold -= UMIN( credits , ch->gold );
swskills.c:    if ( nifty_is_name( "empire" , ch->pcdata->clan->name ) )
swskills.c:       ch->backup_mob = MOB_VNUM_IMP_GUARD;
swskills.c:    else if ( nifty_is_name( "republic" , ch->pcdata->clan->name ) )
swskills.c:       ch->backup_mob = MOB_VNUM_NR_GUARD;
swskills.c:       ch->backup_mob = MOB_VNUM_BOUNCER;
swskills.c:    ch->backup_wait = 1;
swskills.c:     if ( ( pMobIndex = get_mob_index( ch->backup_mob ) ) == NULL )
swskills.c:     if ( ch->backup_mob == MOB_VNUM_STORMTROOPER ||
swskills.c:          ch->backup_mob == MOB_VNUM_NR_TROOPER   ||
swskills.c:          ch->backup_mob == MOB_VNUM_MERCINARY    ||
swskills.c:       	  ch->backup_mob == MOB_VNUM_IMP_FORCES   ||
swskills.c:	  ch->backup_mob == MOB_VNUM_NR_FORCES	  ||
swskills.c:      	  ch->backup_mob == MOB_VNUM_MERC_FORCES )
swskills.c:        if( ch->backup_mob == MOB_VNUM_STORMTROOPER || ch->backup_mob ==  
swskills.c:	    MOB_VNUM_NR_TROOPER || ch->backup_mob == MOB_VNUM_MERCINARY )
swskills.c:            char_to_room( mob[mob_cnt], ch->in_room );
swskills.c:            mob[mob_cnt]->top_level = ch->skill_level[POLITICIAN_ABILITY]/3;
swskills.c:        char_to_room( mob, ch->in_room );
swskills.c:        if ( ch->pcdata && ch->pcdata->clan )
swskills.c:          //mob->name = STRALLOC( ch->pcdata->clan->name );
swskills.c:          sprintf( tmpbuf , "(%s) %s" , ch->pcdata->clan->name  , mob->long_descr );
swskills.c:        mob->top_level = UMIN(ch->skill_level[POLITICIAN_ABILITY], 30);
swskills.c:        if ( ch->pcdata && ch->pcdata->clan )   
swskills.c:           mob->mob_clan = STRALLOC( ch->pcdata->clan->name );
swskills.c:    &&  ch->pcdata->learned[gsn_torture] <= 0  )
swskills.c:    if ( ch->mount )
swskills.c:    ch->alignment = ch->alignment -= 100;
swskills.c:    ch->alignment = URANGE( -1000, ch->alignment, 1000 );
swskills.c:    chance = ris_save( victim, ch->skill_level[POLITICIAN_ABILITY], RIS_PARALYSIS );
swskills.c:    || (number_percent( ) + chance) < ch->pcdata->learned[gsn_torture] +20 ) ) || ((!IS_NPC(victim)) && (IS_SET(victim->pcdata->act2, ACT_BOUND))))
swskills.c:        dam = dice( ch->skill_level[POLITICIAN_ABILITY]/10 , 4 );
swskills.c:    if ( IS_SET( ch->pcdata->flags, PCFLAG_NOTITLE ))
swskills.c:        STRFREE(ch->pcdata->disguise);
swskills.c:        ch->pcdata->disguise = STRALLOC( "" );
swskills.c:    chance = (int) (ch->pcdata->learned[gsn_disguise]);
swskills.c:    STRFREE( ch->pcdata->disguise );
swskills.c:    ch->pcdata->disguise = STRALLOC( argument );
swskills.c:    if ( IS_SET( ch->pcdata->flags, PCFLAG_NOTITLE ))
swskills.c:        STRFREE(ch->pcdata->disguise);
swskills.c:        ch->pcdata->disguise = STRALLOC( "" );
swskills.c:    chance = (int) (ch->pcdata->learned[gsn_deception]);
swskills.c:    STRFREE( ch->pcdata->disguise );
swskills.c:    ch->pcdata->disguise = STRALLOC( argument );
swskills.c:   if ( ch->pcdata->learned[gsn_mine] <= 0 )
swskills.c:    for ( obj = ch->first_carrying; obj; obj = obj->next_content )
swskills.c:    obj = get_obj_list_rev( ch, arg, ch->in_room->last_content );
swskills.c:    switch( ch->in_room->sector_type )
swskills.c:    if ( move > ch->move )
swskills.c:    ch->move -= move;
swskills.c:    obj->armed_by = STRALLOC ( ch->name );
swskills.c:   if ( ch->position == POS_FIGHTING )
swskills.c:   if ( IS_SET(ch->in_room->room_flags2, ROOM_ARENA) )
swskills.c:   if ( heal > ch->pcdata->learned[gsn_first_aid]*2 )
swskills.c:   if ( IS_SET( ch->in_room->room_flags, ROOM_SAFE ) )
swskills.c:   if ( ( pexit = get_exit( ch->in_room, dir ) ) == NULL )
swskills.c:   was_in_room = ch->in_room;
swskills.c:       to_room = generate_exit( ch->in_room , &pexit );
swskills.c:     if ( ( pexit = get_exit( ch->in_room, dir ) ) == NULL )
swskills.c:    if ( IS_AFFECTED(ch, AFF_CHARM) && ch->master == victim )
swskills.c:    if ( ch->position == POS_FIGHTING )
swskills.c:    if ( !IS_NPC( victim ) && IS_SET( ch->act, PLR_NICE ) )
swskills.c:           : (int)  (ch->pcdata->learned[gsn_snipe]) ; 
swskills.c:   	if ( number_percent() < ch->pcdata->learned[gsn_third_attack] )
swskills.c:   	else if ( number_percent() < ch->pcdata->learned[gsn_second_attack] )
swskills.c:   was_in_room = ch->in_room;
swskills.c:   if ( ch->position == POS_FIGHTING )
swskills.c:      if ( ( pexit = get_exit( ch->in_room, dir ) ) == NULL )
swskills.c:       to_room = generate_exit( ch->in_room , &pexit );
swskills.c:        if ( IS_AFFECTED(ch, AFF_CHARM) && ch->master == victim )
swskills.c:        if ( !IS_NPC( victim ) && IS_SET( ch->act, PLR_NICE ) )
swskills.c:        if ( IS_SET( ch->in_room->room_flags, ROOM_SAFE ) )
swskills.c:           to_room = generate_exit( ch->in_room , &pexit );
swskills.c:        if ( IS_AFFECTED(ch, AFF_CHARM) && ch->master == victim )
swskills.c:        if ( !IS_NPC( victim ) && IS_SET( ch->act, PLR_NICE ) )
swskills.c:     if (( ship = ship_in_room( ch->in_room , arg2 ) ) == NULL )
swskills.c:        sprintf(buf, "%s lanza %s a %s.\n\r", ch->name, obj->short_descr, ship->name);
swskills.c:   obj = obj_to_room( obj, ch->in_room );
swskills.c:   if ( ch->in_room !=  was_in_room )
swskills.c:       if ( IS_NPC(ch) || number_percent( ) < ch->pcdata->learned[gsn_throw] )
swskills.c:	 global_retcode = damage( ch, victim, number_range( obj->weight*2 , (obj->weight*2 + ch->perm_str) ), TYPE_HIT );
swskills.c:    if ( ch->mount )
swskills.c:    if ( IS_SET( ch->in_room->room_flags, ROOM_SAFE ) )
swskills.c:    if ( ch->position == POS_FIGHTING )
swskills.c:    if ( ch->position <= POS_SLEEPING )
swskills.c:    percent  = number_percent( ) + ch->skill_level[SMUGGLING_ABILITY] + victim->top_level;
swskills.c:    if ( percent > ch->pcdata->learned[gsn_beg]  ) 
swskills.c:        if ( victim->alignment < 0 && victim->top_level >= ch->top_level+5 )
swskills.c:	  sprintf( buf, "¡%s está molestándome y necesita aprender una lección!", ch->name );
swskills.c:        do_look( victim , ch->name );
swskills.c:	ch->gold     += amount;
swskills.c:	xp = UMIN( amount*10 , ( exp_level( ch->skill_level[SMUGGLING_ABILITY]+1) - exp_level( ch->skill_level[SMUGGLING_ABILITY])  )  );    
swskills.c:    	        if ( (ship = ship_from_cockpit(ch->in_room->vnum)) == NULL )  
swskills.c:	                 : (int)  (ch->pcdata->learned[gsn_hijack]) ;
swskills.c:	                 : (int)  (ch->pcdata->learned[gsn_shipsystems]) ;
swskills.c:    if ( IS_NPC( ch ) || !ch->pcdata )
swskills.c:    switch( ch->substate )
swskills.c:    	        if ( ch->backup_wait )
swskills.c:    	        if ( !ch->pcdata->clan )
swskills.c:    	        if ( ch->gold < ch->skill_level[POLITICIAN_ABILITY] * 350 )
swskills.c:    	        chance = (int) (ch->pcdata->learned[gsn_specialforces]);
swskills.c:    		   ch->dest_buf = str_dup(arg);
swskills.c:    		if ( !ch->dest_buf )
swskills.c:    		strcpy(arg, ch->dest_buf);
swskills.c:    		DISPOSE( ch->dest_buf);
swskills.c:    		DISPOSE( ch->dest_buf );
swskills.c:    		ch->substate = SUB_NONE;
swskills.c:    ch->substate = SUB_NONE;
swskills.c:    credits = ch->skill_level[POLITICIAN_ABILITY] * 175;
swskills.c:    ch->gold -= UMIN( credits , ch->gold );
swskills.c:    if ( nifty_is_name( "empire" , ch->pcdata->clan->name ) )
swskills.c:       ch->backup_mob = MOB_VNUM_IMP_FORCES;
swskills.c:    else if ( nifty_is_name( "republic" , ch->pcdata->clan->name ) )
swskills.c:       ch->backup_mob = MOB_VNUM_NR_FORCES;
swskills.c:       ch->backup_mob = MOB_VNUM_MERC_FORCES;
swskills.c:    ch->backup_wait = number_range(1,2);
swskills.c:    if ( IS_NPC( ch ) || !ch->pcdata )
swskills.c:    switch( ch->substate )
swskills.c:    	        if ( ch->backup_wait )
swskills.c:    	        if ( !ch->pcdata->clan )
swskills.c:    	        if ( ch->gold < ch->skill_level[POLITICIAN_ABILITY] * 200 )
swskills.c:    	        chance = (int) (ch->pcdata->learned[gsn_eliteguard]);
swskills.c:    		   ch->dest_buf = str_dup(arg);
swskills.c:    		if ( !ch->dest_buf )
swskills.c:    		strcpy(arg, ch->dest_buf);
swskills.c:    		DISPOSE( ch->dest_buf);
swskills.c:    		DISPOSE( ch->dest_buf );
swskills.c:    		ch->substate = SUB_NONE;
swskills.c:    ch->substate = SUB_NONE;
swskills.c:    credits = ch->skill_level[POLITICIAN_ABILITY] * 200;
swskills.c:    ch->gold -= UMIN( credits , ch->gold );
swskills.c:    if ( nifty_is_name( "empire" , ch->pcdata->clan->name ) )
swskills.c:       ch->backup_mob = MOB_VNUM_IMP_ELITE;
swskills.c:    else if ( nifty_is_name( "republic" , ch->pcdata->clan->name ) )
swskills.c:       ch->backup_mob = MOB_VNUM_NR_ELITE;
swskills.c:       ch->backup_mob = MOB_VNUM_MERC_ELITE;
swskills.c:    ch->backup_wait = 1;
swskills.c:    if ( IS_NPC( ch ) || !ch->pcdata )
swskills.c:    switch( ch->substate )
swskills.c:    	        if ( ch->backup_wait )
swskills.c:    	        if ( !ch->pcdata->clan )
swskills.c:    	        if ( ch->gold < ch->skill_level[POLITICIAN_ABILITY] * 30 )
swskills.c:    	        chance = (int) (ch->pcdata->learned[gsn_addpatrol]);
swskills.c:    		   ch->dest_buf = str_dup(arg);
swskills.c:    		if ( !ch->dest_buf )
swskills.c:    		strcpy(arg, ch->dest_buf);
swskills.c:    		DISPOSE( ch->dest_buf);
swskills.c:    		DISPOSE( ch->dest_buf );
swskills.c:    		ch->substate = SUB_NONE;    		                                   
swskills.c:    ch->substate = SUB_NONE;
swskills.c:    credits = ch->skill_level[POLITICIAN_ABILITY] * 30;
swskills.c:    ch->gold -= UMIN( credits , ch->gold );
swskills.c:    if ( nifty_is_name( "empire" , ch->pcdata->clan->name ) )
swskills.c:       ch->backup_mob = MOB_VNUM_IMP_PATROL;
swskills.c:    else if ( nifty_is_name( "republic" , ch->pcdata->clan->name ) )
swskills.c:       ch->backup_mob = MOB_VNUM_NR_PATROL;
swskills.c:       ch->backup_mob = MOB_VNUM_MERC_PATROL;
swskills.c:    ch->backup_wait = 1;
swskills.c:    if ( !ch->pcdata || ( clan = ch->pcdata->clan ) == NULL )
swskills.c:    if ( ch->mount )
swskills.c:    if ( IS_SET( ch->in_room->room_flags, ROOM_SAFE ) )
swskills.c:    if ( ch->position == POS_FIGHTING )
swskills.c:    if ( ch->position <= POS_SLEEPING )
swskills.c:   if ( IS_NPC(ch) || !ch->pcdata )
swskills.c:    if ( ch->mount )
swskills.c:    if ( IS_SET( ch->in_room->room_flags, ROOM_SAFE ) )
swskills.c:    if ( ch->position == POS_FIGHTING )
swskills.c:    if ( ch->position <= POS_SLEEPING )
swskills.c:    if ( percent - ch->skill_level[POLITICIAN_ABILITY] + victim->top_level > ch->pcdata->learned[gsn_smalltalk]  ) 
swskills.c:        if ( victim->alignment < -500 && victim->top_level >= ch->top_level+5 )
swskills.c:	  sprintf( buf, "¡Cállate %s!", ch->name );
swskills.c:    if ( IS_NPC(ch) || !ch->pcdata || !ch->pcdata->clan || !ch->in_room->area || !ch->in_room->area->planet )
swskills.c:    if ( ( clan = ch->pcdata->clan->mainclan ) == NULL )
swskills.c:       clan = ch->pcdata->clan;
swskills.c:    planet = ch->in_room->area->planet;
swskills.c:   if ( IS_NPC(ch) || !ch->pcdata || !ch->pcdata->clan || !ch->in_room->area || !ch->in_room->area->planet )
swskills.c:    if ( ch->mount )
swskills.c:    if ( IS_SET( ch->in_room->room_flags, ROOM_SAFE ) )
swskills.c:    if ( ch->position == POS_FIGHTING )
swskills.c:    if ( ch->position <= POS_SLEEPING )
swskills.c:    if ( ( clan = ch->pcdata->clan->mainclan ) == NULL )
swskills.c:       clan = ch->pcdata->clan;
swskills.c:    planet = ch->in_room->area->planet;
swskills.c:    ch_printf( ch, "Le hablas sobre los beneficios de %s%s.\n\r", ch->pcdata->clan->name,
swskills.c:    if ( percent - get_curr_cha(ch) + victim->top_level > ch->pcdata->learned[gsn_propeganda]  ) 
swskills.c:	  sprintf( buf, "¡%s nos ha traicionado!" , ch->name);
swskills.c:       planet->pop_support += .5 + ch->top_level/15;
swskills.c:       planet->pop_support -= .5 + ch->top_level/15;
swskills.c:    if ( IS_NPC(ch) || !ch->pcdata || !ch->pcdata->clan || !ch->in_room->area || !ch->in_room->area->planet )
swskills.c:    if ( ch->mount )
swskills.c:    if ( IS_SET( ch->in_room->room_flags, ROOM_SAFE ) )
swskills.c:    if ( amount > ch->gold)
swskills.c:    if ( ch->position == POS_FIGHTING )
swskills.c:    if ( ch->position <= POS_SLEEPING )
swskills.c:    ch->gold -= amount;
swskills.c:	ch_printf( ch, "Le das un pequeño regalo en nombre de %s.\n\r", ch->pcdata->clan->name );
swskills.c:    if ( percent - amount + victim->top_level > ch->pcdata->learned[gsn_bribe]  ) 
swskills.c:    if ( ( clan = ch->pcdata->clan->mainclan ) == NULL )
swskills.c:       clan = ch->pcdata->clan;
swskills.c:    planet = ch->in_room->area->planet;
swskills.c:      amount = UMIN( amount ,( exp_level(ch->skill_level[POLITICIAN_ABILITY]+1) - exp_level(ch->skill_level[POLITICIAN_ABILITY]) ) );
swskills.c:	sprintf(buf, "%s trata de seducirte sin éxito.\n\r", ch->name);
swskills.c:	sprintf(buf, "%s trata de seducirte.\n\r", ch->name);
swskills.c:    level = !IS_NPC(ch) ? (int)ch->pcdata->learned[gsn_seduce] : ch->top_level;
swskills.c:    if ( IS_AFFECTED(victim, AFF_CHARM) ||   chance == 1000 || IS_AFFECTED(ch, AFF_CHARM) || ch->top_level < victim->top_level || circle_follow( victim, ch ) || saves_spell_staff( chance, victim ) || ch->sex == victim->sex )
swskills.c:	sprintf(buf, "%s trata de seducirte.\n\r", ch->name);
swskills.c:    for(rch = ch->in_room->first_person; rch; rch = rch->next_in_room)
swskills.c:     if(rch->master == ch && IS_AFFECTED(rch, AFF_CHARM) && rch != victim)
swskills.c:    sprintf( buf, "%s ha seducido a %s.", ch->name, victim->name);
swskills.c:    log_string_plus( buf, LOG_NORMAL, ch->top_level );
swskills.c:    if ( IS_NPC(ch) || !ch->pcdata || !ch->pcdata->clan || !ch->in_room->area || !ch->in_room->area->planet )
swskills.c:    if ( ch->mount )
swskills.c:    if ( IS_SET( ch->in_room->room_flags, ROOM_SAFE ) )
swskills.c:    if ( ch->position == POS_FIGHTING )
swskills.c:    if ( ch->position <= POS_SLEEPING )
swskills.c:    if ( ( clan = ch->pcdata->clan->mainclan ) == NULL )
swskills.c:       clan = ch->pcdata->clan;
swskills.c:    planet = ch->in_room->area->planet;
swskills.c:    ch_printf( ch, "Hablas a la gente acerca de los beneficios de %s%s.\n\r", ch->pcdata->clan->name,
swskills.c:    if ( number_percent() < ch->pcdata->learned[gsn_masspropeganda]  ) 
swskills.c:        for ( rch = ch->in_room->first_person; rch; rch = rch->next_in_room )
swskills.c:            if ( rch->vip_flags == 0 )
swskills.c:            planet->pop_support += (.5 + ch->top_level/10)*victims;
swskills.c:            planet->pop_support -= (ch->top_level/10)*victims;
swskills.c:        gain_exp(ch, ch->top_level*100, POLITICIAN_ABILITY);
swskills.c:        ch_printf( ch , "Recibes %d puntos de experiencia en diplomacia.\n\r", ch->top_level*100 );
swskills.c: switch( ch->substate )
swskills.c: if ( !IS_SET( ch->in_room->room_flags, ROOM_FACTORY ) )
swskills.c: for ( cobj = ch->last_carrying; cobj; cobj = cobj->prev_content )
swskills.c:   ch->dest_buf   = str_dup(arg);
swskills.c:    	  if ( !ch->dest_buf )
swskills.c:    	  strcpy(arg, ch->dest_buf);
swskills.c:    	  DISPOSE( ch->dest_buf);
swskills.c:    	  DISPOSE( ch->dest_buf );
swskills.c:    	  ch->substate = SUB_NONE;
swskills.c:    ch->substate = SUB_NONE;
swskills.c:    chance = IS_NPC(ch) ? ch->top_level : (int)(ch->pcdata->learned[gsn_repair]);
swskills.c:         xpgain =  (number_percent( ) * 6) * ch->skill_level[ENGINEERING_ABILITY];
swskills.c:    switch( ch->substate )
swskills.c:                if ( !IS_SET( ch->in_room->room_flags, ROOM_SAFE ) || !IS_SET( ch->in_room->room_flags, ROOM_SILENCE ))
swskills.c:                for ( obj = ch->last_carrying; obj; obj = obj->prev_content )     
swskills.c:    	        chance = IS_NPC(ch) ? ch->top_level
swskills.c:	                 : (int) (ch->pcdata->learned[gsn_makeduallightsaber]);
swskills.c:    		   ch->dest_buf = str_dup(arg);
swskills.c:    		if ( !ch->dest_buf )
swskills.c:    		strcpy(arg, ch->dest_buf);
swskills.c:    		DISPOSE( ch->dest_buf);
swskills.c:    		DISPOSE( ch->dest_buf );
swskills.c:    		ch->substate = SUB_NONE;    		                                   
swskills.c:    ch->substate = SUB_NONE;
swskills.c:    level = IS_NPC(ch) ? ch->top_level : (int) (ch->pcdata->learned[gsn_makeduallightsaber]);
swskills.c:    for ( obj = ch->last_carrying; obj; obj = obj->prev_content )     
swskills.c:    chance = IS_NPC(ch) ? ch->top_level
swskills.c:                : (int) (ch->pcdata->learned[gsn_makeduallightsaber]) ;
swskills.c:         xpgain = UMIN( obj->cost*50 ,( exp_level(ch->skill_level[FORCE_ABILITY]+1) - exp_level(ch->skill_level[ENGINEERING_ABILITY]) ) );
swskills.c:    switch( ch->substate )
swskills.c:                if ( !IS_SET( ch->in_room->room_flags, ROOM_FACTORY ) )
swskills.c:                for ( obj = ch->last_carrying; obj; obj = obj->prev_content )     
swskills.c:    	        chance = IS_NPC(ch) ? ch->top_level
swskills.c:	                 : (int) (ch->pcdata->learned[gsn_makepike]);
swskills.c:    		   ch->dest_buf = str_dup(arg);
swskills.c:    		if ( !ch->dest_buf )
swskills.c:    		strcpy(arg, ch->dest_buf);
swskills.c:    		DISPOSE( ch->dest_buf);
swskills.c:    		DISPOSE( ch->dest_buf );
swskills.c:    		ch->substate = SUB_NONE;    		                                   
swskills.c:    ch->substate = SUB_NONE;
swskills.c:    level = IS_NPC(ch) ? ch->top_level : (int) (ch->pcdata->learned[gsn_makepike]);
swskills.c:    for ( obj = ch->last_carrying; obj; obj = obj->prev_content )     
swskills.c:    chance = IS_NPC(ch) ? ch->top_level
swskills.c:                : (int) (ch->pcdata->learned[gsn_makepike]) ;
swskills.c:         xpgain = UMIN( obj->cost*200 ,( exp_level(ch->skill_level[ENGINEERING_ABILITY]+1) - exp_level(ch->skill_level[ENGINEERING_ABILITY]) ) );
swskills.c:    switch( ch->substate )
swskills.c:                if ( !IS_SET( ch->in_room->room_flags, ROOM_FACTORY ) )
swskills.c:                for ( obj = ch->last_carrying; obj; obj = obj->prev_content )     
swskills.c:    	        chance = IS_NPC(ch) ? ch->top_level
swskills.c:	                 : (int) (ch->pcdata->learned[gsn_makebug]);
swskills.c:    		   ch->dest_buf   = str_dup("blah");
swskills.c:    		if ( !ch->dest_buf )
swskills.c:			ch->dest_buf = str_dup("blah");
swskills.c:    		DISPOSE( ch->dest_buf);
swskills.c:    		DISPOSE( ch->dest_buf );
swskills.c:    		ch->substate = SUB_NONE;    		                                   
swskills.c:    ch->substate = SUB_NONE;
swskills.c:    level = IS_NPC(ch) ? ch->top_level : (int) (ch->pcdata->learned[gsn_makebug]);
swskills.c:    for ( obj = ch->last_carrying; obj; obj = obj->prev_content )     
swskills.c:    chance = IS_NPC(ch) ? ch->top_level
swskills.c:                : (int) (ch->pcdata->learned[gsn_makebug]) ;
swskills.c:    switch( ch->substate )
swskills.c:                if ( !IS_SET( ch->in_room->room_flags, ROOM_FACTORY ) )
swskills.c:                for ( obj = ch->last_carrying; obj; obj = obj->prev_content )     
swskills.c:    	        chance = IS_NPC(ch) ? ch->top_level
swskills.c:	                 : (int) (ch->pcdata->learned[gsn_makebeacon]);
swskills.c:    		   ch->dest_buf   = str_dup("blah");
swskills.c:    		if ( !ch->dest_buf )
swskills.c:			ch->dest_buf = str_dup("blah");
swskills.c:    		DISPOSE( ch->dest_buf);
swskills.c:    		DISPOSE( ch->dest_buf );
swskills.c:    		ch->substate = SUB_NONE;    		                                   
swskills.c:    ch->substate = SUB_NONE;
swskills.c:    level = IS_NPC(ch) ? ch->top_level : (int) (ch->pcdata->learned[gsn_makebeacon]);
swskills.c:    for ( obj = ch->last_carrying; obj; obj = obj->prev_content )     
swskills.c:    chance = IS_NPC(ch) ? ch->top_level
swskills.c:                : (int) (ch->pcdata->learned[gsn_makebeacon]) ;
swskills.c:	if ((ship = ship_in_room(ch->in_room, argument)) == NULL){
swskills.c:	if(is_name(ch->name, ship->pbeacon)){
swskills.c:        for(obj = ch->last_carrying; obj; obj = obj->prev_content)
swskills.c:    if (number_percent() < ch->pcdata->learned[gsn_plantbeacon]){
swskills.c:      sprintf(buf, "%s coloca un localizador en el casco de %s.", ch->name, ship->name);
swskills.c:	  sprintf(buf, "%s %s", ship->pbeacon, ch->name);
swskills.c:        for(obj = ch->last_carrying; obj; obj = obj->prev_content)
swskills.c:  if (number_percent() > ch->pcdata->learned[gsn_showbeacons])
swskills.c:   if(is_name(ch->name, ship->pbeacon))
swskills.c:switch( ch->substate )
swskills.c:   if((ship = ship_in_room(ch->in_room, arg)) == NULL)
swskills.c:   chance = IS_NPC(ch) ? ch->top_level : (int)(ch->pcdata->learned[gsn_checkbeacons]);
swskills.c:    ch->dest_buf = str_dup(arg);
swskills.c: 	if ( !ch->dest_buf )
swskills.c:	 strcpy(arg, ch->dest_buf);
swskills.c: 	 DISPOSE( ch->dest_buf);
swskills.c:	 ch->dest_buf = NULL;
swskills.c:	DISPOSE( ch->dest_buf );
swskills.c:	 ch->dest_buf = NULL;
swskills.c:	ch->substate = SUB_NONE;                                       
swskills.c:    ch->substate = SUB_NONE;
swskills.c:   if((ship = ship_in_room(ch->in_room, arg)) == NULL)
swskills.c:         xpgain = (ch->experience[TECHNICIAN_ABILITY]/30);
swskills.c:switch( ch->substate )
swskills.c:   if((ship = ship_in_room(ch->in_room, arg)) == NULL)
swskills.c:   chance = IS_NPC(ch) ? ch->top_level : (int)(ch->pcdata->learned[gsn_nullifybeacons]);
swskills.c:    ch->dest_buf = str_dup(arg);
swskills.c: 	if ( !ch->dest_buf )
swskills.c:	 strcpy(arg, ch->dest_buf);
swskills.c: 	 DISPOSE( ch->dest_buf);
swskills.c:	 ch->dest_buf = NULL;
swskills.c:    ch->substate = SUB_NONE;
swskills.c: chance = IS_NPC(ch) ? ch->top_level : (int)(ch->pcdata->learned[gsn_nullifybeacons]);
swskills.c:   if((ship = ship_in_room(ch->in_room, arg)) == NULL)
swskills.c:         xpgain = (ch->experience[TECHNICIAN_ABILITY]/25);
swskills.c:    switch( ch->substate )
swskills.c:                if ( !IS_SET( ch->in_room->room_flags, ROOM_FACTORY ) )
swskills.c:                for ( obj = ch->last_carrying; obj; obj = obj->prev_content )     
swskills.c:    	        chance = IS_NPC(ch) ? ch->top_level
swskills.c:	                 : (int) (ch->pcdata->learned[gsn_makebinders]);
swskills.c:    		   ch->dest_buf   = str_dup("blah");
swskills.c:    		if ( !ch->dest_buf )
swskills.c:			ch->dest_buf = str_dup("blah");
swskills.c:    		DISPOSE( ch->dest_buf);
swskills.c:    		DISPOSE( ch->dest_buf );
swskills.c:    		ch->substate = SUB_NONE;    		                                   
swskills.c:    ch->substate = SUB_NONE;
swskills.c:    level = IS_NPC(ch) ? ch->top_level : (int) (ch->pcdata->learned[gsn_makebinders]);
swskills.c:    for ( obj = ch->last_carrying; obj; obj = obj->prev_content )     
swskills.c:    chance = IS_NPC(ch) ? ch->top_level
swskills.c:                : (int) (ch->pcdata->learned[gsn_makebinders]) ;
swskills.c:	SET_BIT(ch->affected_by,AFF_INFRARED);
swskills.c:	REMOVE_BIT(ch->affected_by, AFF_INFRARED);
swskills.c: chance = ch->pcdata->learned[gsn_battle_command];
swskills.c: for ( gch = ch->in_room->first_person; gch; gch = gch->next_in_room )
swskills.c:        af.duration  = (number_fuzzy( (ch->pcdata->learned[gsn_battle_command] + 1) / 3 ) + 1) * DUR_CONV;
swskills.c:        af.modifier  = -(ch->pcdata->learned[gsn_battle_command]/2);
swskills.c:	af.modifier = ch->pcdata->learned[gsn_battle_command]/2;
tech.c:    switch( ch->substate )
tech.c:                if ( !IS_SET( ch->in_room->room_flags, ROOM_FACTORY ) )
tech.c:                for ( obj = ch->last_carrying; obj; obj = obj->prev_content )     
tech.c:    	        chance = IS_NPC(ch) ? ch->top_level
tech.c:	                 : (int) (ch->pcdata->learned[gsn_makemodule]);
tech.c:    		   ch->dest_buf = str_dup(arg);
tech.c:    		if ( !ch->dest_buf )
tech.c:    		strcpy(arg, ch->dest_buf);
tech.c:    		DISPOSE( ch->dest_buf);
tech.c:    		DISPOSE( ch->dest_buf );
tech.c:    		ch->substate = SUB_NONE;    		                                   
tech.c:    ch->substate = SUB_NONE;
tech.c:    level = IS_NPC(ch) ? ch->top_level : (int) (ch->pcdata->learned[gsn_makemodule]);
tech.c:    for ( obj = ch->last_carrying; obj; obj = obj->prev_content )     
tech.c:    chance = IS_NPC(ch) ? ch->top_level
tech.c:                : (int) (ch->pcdata->learned[gsn_makemodule]) ;            
tech.c:         xpgain = ((ch->skill_level[TECHNICIAN_ABILITY]+1) * 200);
tech.c:  chance = IS_NPC(ch) ? ch->top_level
tech.c:     : (int) (ch->pcdata->learned[gsn_showmodules]);
tech.c:  if((ship = ship_from_engine(ch->in_room->vnum)) == NULL){
tech.c:  switch( ch->substate )
tech.c:    if ( (ship = ship_from_engine(ch->in_room->vnum)) != NULL )
tech.c:      	ship = ship_from_engine(ch->in_room->vnum);
tech.c:     for ( obj = ch->last_carrying; obj; obj = obj->prev_content )
tech.c:     chance = IS_NPC(ch) ? ch->top_level
tech.c:        : (int) (ch->pcdata->learned[gsn_removemodule]);
tech.c:  	ch->dest_buf   = str_dup(arg);
tech.c:    	  if ( !ch->dest_buf )
tech.c:    	  strcpy(arg, ch->dest_buf);
tech.c:    	  DISPOSE( ch->dest_buf);
tech.c:    	  DISPOSE( ch->dest_buf );
tech.c:    	  ch->substate = SUB_NONE;
tech.c:     ch->substate = SUB_NONE;
tech.c:     for ( obj = ch->last_carrying; obj; obj = obj->prev_content )
tech.c:    chance = IS_NPC(ch) ? ch->top_level
tech.c:               : (int) (ch->pcdata->learned[gsn_removemodule]);
tech.c:    ship = ship_from_engine(ch->in_room->vnum);
tech.c:      xpgain = ((ch->skill_level[TECHNICIAN_ABILITY]+1) * 300);
tech.c:    if( (ch->pcdata->learned[gsn_shipmaintenance]) <= 0)
tech.c:    switch( ch->substate )
tech.c:    	        if (  (ship = ship_from_engine(ch->in_room->vnum))  == NULL )
tech.c:                chance = IS_NPC(ch) ? ch->top_level
tech.c:	                 : (int) (ch->pcdata->learned[gsn_shipmaintenance]);
tech.c:    		   ch->dest_buf = str_dup(arg);
tech.c:    		if ( !ch->dest_buf )
tech.c:    		strcpy(arg, ch->dest_buf);
tech.c:    		DISPOSE( ch->dest_buf);
tech.c:    		DISPOSE( ch->dest_buf );
tech.c:    		ch->substate = SUB_NONE;
tech.c:    ch->substate = SUB_NONE;
tech.c:    if ( (ship = ship_from_engine(ch->in_room->vnum)) == NULL )
tech.c:                         number_range( (int) ( ch->pcdata->learned[gsn_shipmaintenance] / 2 ) , (int) (ch->pcdata->learned[gsn_shipmaintenance]) ),
tech.c:	for(obj = ch->last_carrying; obj; obj = obj->prev_content )
tech.c:switch( ch->substate )
tech.c:   chance = IS_NPC(ch) ? ch->top_level : (int)(ch->pcdata->learned[gsn_scanbugs]);
tech.c:    ch->dest_buf = str_dup(arg);
tech.c: 	if ( !ch->dest_buf )
tech.c:	 strcpy(arg, ch->dest_buf);
tech.c: 	 DISPOSE( ch->dest_buf);
tech.c:	 ch->dest_buf = NULL;
tech.c:	DISPOSE( ch->dest_buf );
tech.c:	 ch->dest_buf = NULL;
tech.c:	ch->substate = SUB_NONE;                                       
tech.c:    ch->substate = SUB_NONE;
tech.c: chance = IS_NPC(ch) ? ch->top_level : (int)(ch->pcdata->learned[gsn_scanbugs]);
tech.c:         xpgain = (ch->experience[TECHNICIAN_ABILITY]/30);
tech.c:switch( ch->substate )
tech.c:   chance = IS_NPC(ch) ? ch->top_level : (int)(ch->pcdata->learned[gsn_scanbugs]);
tech.c:    ch->dest_buf = str_dup(arg);
tech.c: 	if ( !ch->dest_buf )
tech.c:	 strcpy(arg, ch->dest_buf);
tech.c: 	 DISPOSE( ch->dest_buf);
tech.c:	 ch->dest_buf = NULL;
tech.c:	DISPOSE( ch->dest_buf );
tech.c:	 ch->dest_buf = NULL;
tech.c:	ch->substate = SUB_NONE;                                       
tech.c:    ch->substate = SUB_NONE;
tech.c: chance = IS_NPC(ch) ? ch->top_level : (int)(ch->pcdata->learned[gsn_scanbugs]);
tech.c:         xpgain = (ch->experience[TECHNICIAN_ABILITY]/25);
tech.c:    switch( ch->substate )
tech.c:                if ( !IS_SET( ch->in_room->room_flags, ROOM_FACTORY ) )
tech.c:                for ( obj = ch->last_carrying; obj; obj = obj->prev_content )
tech.c:                chance = IS_NPC(ch) ? ch->top_level : (int) (ch->pcdata->learned[gsn_makejetpack]);
tech.c:                   ch->dest_buf   = str_dup(arg);
tech.c:                if ( !ch->dest_buf )
tech.c:                strcpy(arg, ch->dest_buf);
tech.c:                DISPOSE( ch->dest_buf);
tech.c:                DISPOSE( ch->dest_buf );
tech.c:                ch->substate = SUB_NONE;
tech.c:    ch->substate = SUB_NONE;
tech.c:    level = IS_NPC(ch) ? ch->top_level : (int) (ch->pcdata->learned[gsn_makejetpack]);
tech.c:    for ( obj = ch->last_carrying; obj; obj = obj->prev_content )
tech.c:    chance = IS_NPC(ch) ? ch->top_level : (int) (ch->pcdata->learned[gsn_makejetpack]) ;
tech.c:            ( exp_level(ch->skill_level[ENGINEERING_ABILITY]+1) -
tech.c:              exp_level(ch->skill_level[ENGINEERING_ABILITY]) ) );
track.c:   if ( !IS_NPC(ch) && !ch->pcdata->learned[gsn_track] )
track.c:   maxdist = 100 + ch->top_level * 30;
track.c:     maxdist = (maxdist * ch->pcdata->learned[gsn_track]) / 100;
track.c:   dir = find_first_step(ch->in_room, vict->in_room, maxdist);
track.c:     if ( IS_SET( ch->in_room->room_flags, ROOM_SAFE ) )
track.c:   if (!ch || !ch->hunting || !ch->hunting->who )
track.c:      if (ch->hunting->who == tmp)
track.c:   if ( ch->in_room == ch->hunting->who->in_room )
track.c:     if ( ch->fighting )
track.c:     found_prey( ch, ch->hunting->who );
track.c:	  if ( mob_snipe( ch, ch->hunting->who ) == TRUE ) 
track.c:        else if ( !IS_SET( ch->act, ACT_DROID ) )
track.c:   ret = find_first_step(ch->in_room, ch->hunting->who->in_room, 5000);
track.c:	  if ( ( pexit = get_exit(ch->in_room, ret) ) == NULL
track.c:      move_char( ch, get_exit( ch->in_room, ret), FALSE );
track.c:      if ( !ch->hunting )
track.c:        if ( !ch->in_room )
track.c:          sprintf( buf, "Hunt_victim: no ch->in_room!  Mob #%d, name: %s.  Placing mob in limbo.",
track.c:                   ch->pIndexData->vnum, ch->name );
track.c:      if (ch->in_room == ch->hunting->who->in_room)
track.c:	found_prey( ch, ch->hunting->who );
track.c: if ( !ch->in_room || !victim->in_room )
track.c: if ( IS_SET( ch->in_room->room_flags, ROOM_SAFE ) )
track.c:   if ( ( pexit = get_exit( ch->in_room, dir ) ) == NULL )
track.c:   was_in_room = ch->in_room;
track.c:       to_room = generate_exit( ch->in_room , &pexit );
track.c:     if ( ch->in_room == victim->in_room )
track.c:     if ( ( pexit = get_exit( ch->in_room, dir ) ) == NULL )
track.c:    if ( IS_AFFECTED(ch, AFF_CHARM) && ch->master == victim )
track.c:    if ( ch->position == POS_FIGHTING )
update.c:       if ( ch->main_ability == ability ) level = 30;
update.c:       if ( ch->main_ability == ENGINEERING_ABILITY ) level = 3;
update.c:       if ( ch->main_ability == TECHNICIAN_ABILITY ) level = 3;
update.c:       if ( ch->main_ability == HUNTING_ABILITY ) level = 12;
update.c:	   if ( ch->main_ability == ASSASSIN_ABILITY ) level = 12;
update.c:       if ( ch->main_ability == SMUGGLING_ABILITY ) level = 5;
update.c:       if ( ch->secondary_ability == ability ) level = 25;
update.c:              level +=  (ch->perm_con / 5) + (ch->perm_dex / 5);
update.c:       if ( ch->main_ability == ability ) level = 30;
update.c:       if ( ch->main_ability == ENGINEERING_ABILITY ) level = 10;
update.c:       if ( ch->main_ability == TECHNICIAN_ABILITY ) level = 10;
update.c:       if ( ch->main_ability == HUNTING_ABILITY ) level = 5;
update.c:	   if ( ch->main_ability == ASSASSIN_ABILITY ) level = 5;
update.c:       if ( ch->main_ability == SMUGGLING_ABILITY ) level = 10;
update.c:       if ( ch->secondary_ability == ability ) level = 25;
update.c:       level += (ch->perm_dex/2) + (ch->perm_int/3);
update.c:       if ( ch->main_ability == ability ) level = 30;
update.c:       if ( ch->main_ability == TECHNICIAN_ABILITY ) level = 10;
update.c:       if ( ch->main_ability == PILOTING_ABILITY ) level = 8;
update.c:       if ( ch->main_ability == SLICER_ABILITY ) level = 5;
update.c:       if ( ch->secondary_ability == ability ) level = 25;
update.c:       level += ch->perm_int / 2;
update.c:       if ( ch->main_ability == ability) level = 30;
update.c:       if ( ch->main_ability == SMUGGLING_ABILITY) level = 12;
update.c:		if( ch->main_ability == ASSASSIN_ABILITY ) level = 1;
update.c:		if( ch->main_ability == HUNTING_ABILITY ) level = 1;
update.c:		if( ch->main_ability == ENGINEERING_ABILITY) level = 5;
update.c:       if ( ch->secondary_ability == ability ) level = 25;
update.c:       level += ((ch->perm_wis / 8) + (ch->perm_cha / 8) + (ch->perm_int / 8));
update.c:       if ( ch->main_ability == ability ) level = 30;
update.c:       if ( ch->secondary_ability == ability ) level = 25;
update.c:       if ( ch->main_ability == ability ) level = 30;
update.c:       if ( ch->secondary_ability == ability ) level = 25;
update.c:       if ( ch->main_ability == ability ) level = 30;
update.c:       if ( ch->main_ability == PILOTING_ABILITY ) level = 10;
update.c:       if ( ch->main_ability == SLICER_ABILITY ) level = 7;
update.c:       if ( ch->main_ability == HUNTING_ABILITY ) level = 3;
update.c:       if ( ch->secondary_ability == ability ) level = 25;
update.c:       level += ch->perm_lck/2;
update.c:       if ( ch->main_ability == ability )    level = 30;
update.c:       if ( ch->main_ability == PILOTING_ABILITY ) level = 10;
update.c:       if ( ch->secondary_ability == ability ) level = 25;
update.c:       level += ch->perm_cha/3 + ch->perm_wis/3;
update.c:       if ( ch->main_ability == ability ) level = 30;
update.c:       if ( ch->main_ability == ENGINEERING_ABILITY ) level = 12;
update.c:       if ( ch->main_ability == PILOTING_ABILITY ) level = 10;
update.c:       if ( ch->main_ability == SLICER_ABILITY ) level = 8;
update.c:       if ( ch->secondary_ability == ability ) level = 25;
update.c:       level += (ch->perm_int/2) + (ch->perm_wis/6);
update.c:    level += ch->bonus[ability];
update.c:      if ( ch->main_ability == ability )
update.c:       level += ch->perm_frc*5;
update.c:    if ( ch->top_level < ch->skill_level[ability] && ch->top_level < 30 )
update.c:          ch->top_level = URANGE( 1 , ch->skill_level[ability] , 30 );
update.c:	REMOVE_BIT( ch->act, PLR_BOUGHT_PET );
update.c:    ch->experience[ability] = UMAX( 0, ch->experience[ability] + gain );
update.c:    while ( ch->experience[ability] >= exp_level( ch->skill_level[ability]+1))
update.c:        if ( ch->skill_level[ability] >= max_level(ch , ability) )
update.c:          ch->experience[ability] = (exp_level( ch->skill_level[ability]+1 ) - 1);
update.c:        ++ch->skill_level[ability]; 
update.c:    ch->experience[ability] = UMAX( 0, ch->experience[ability] + gain );
update.c:    if (NOT_AUTHED(ch) && ch->experience[ability] >= exp_level(ch->skill_level[ability]+1))
update.c:	ch->experience[ability] = (exp_level( ch->skill_level[ability]+1 ) - 1);
update.c:    while ( ch->experience[ability] >= exp_level( ch->skill_level[ability]+1))
update.c:        if ( ch->skill_level[ability] >= max_level(ch , ability) )
update.c:          ch->experience[ability] = (exp_level( ch->skill_level[ability]+1 ) - 1);
update.c:	ch_printf( ch, "¡Alcanzas el nivel %d en %s!\n\r", ++ch->skill_level[ability], ability_name[ability]);
update.c:	gain = ch->top_level;
update.c:	gain = UMIN( 5, ch->top_level );
update.c:	switch ( ch->position )
update.c:	if ( ch->pcdata->condition[COND_FULL]   == 0 )
update.c:	if ( ch->pcdata->condition[COND_THIRST] == 0 )
update.c:    if ( ch->race == RACE_TRANDOSHAN )
update.c:    return UMIN(gain, ch->max_hit - ch->hit);
update.c:	gain = ch->top_level;
update.c:	if ( ch->position < POS_SLEEPING )
update.c:	switch ( ch->position )
update.c:	if ( ch->pcdata->condition[COND_FULL]   == 0 )
update.c:	if ( ch->pcdata->condition[COND_THIRST] == 0 )
update.c:    return UMIN(gain, ch->max_mana - ch->mana);
update.c:	gain = ch->top_level;
update.c:	gain = UMAX( 15, 2 * ch->top_level );
update.c:	switch ( ch->position )
update.c:	if ( ch->pcdata->condition[COND_FULL]   == 0 )
update.c:	if ( ch->pcdata->condition[COND_THIRST] == 0 )
update.c:    return UMIN(gain, ch->max_move - ch->move);
update.c:       if ( ch->pcdata->addiction[drug] < ch->pcdata->drug_level[drug] )
update.c:          ch->pcdata->addiction[drug]++;
update.c:       if ( ch->pcdata->addiction[drug] > ch->pcdata->drug_level[drug]+150 )
update.c:          switch (ch->pcdata->addiction[drug])
update.c:	      		af.duration  = ch->pcdata->addiction[drug];
update.c:	      		af.duration  = ch->pcdata->addiction[drug];
update.c:	      		af.duration  = ch->pcdata->addiction[drug];
update.c:	      		af.duration  = ch->pcdata->addiction[drug];
update.c:       if ( ch->pcdata->addiction[drug] > ch->pcdata->drug_level[drug]+200 )
update.c:       else if ( ch->pcdata->addiction[drug] > ch->pcdata->drug_level[drug]+100 )
update.c:       else if ( ch->pcdata->addiction[drug] > ch->pcdata->drug_level[drug]+50 )
update.c:       else if ( ch->pcdata->addiction[drug] > ch->pcdata->drug_level[drug]+25 )
update.c:       else if ( ch->pcdata->addiction[drug] < ch->pcdata->drug_level[drug]-50 )
update.c:           ch->pcdata->drug_level[drug] -=10;
update.c:       if ( ch->pcdata->drug_level[drug] > 1 )
update.c:          ch->pcdata->drug_level[drug] -=2;
update.c:       else if ( ch->pcdata->drug_level[drug] > 0 )
update.c:          ch->pcdata->drug_level[drug] -=1;
update.c:       else if ( ch->pcdata->addiction[drug] > 0 && ch->pcdata->drug_level[drug] <= 0 )
update.c:          ch->pcdata->addiction[drug]--;
update.c:    condition	        	    = ch->pcdata->condition[iCond];
update.c:    ch->pcdata->condition[iCond]    = URANGE( 0, condition + value, 48 );
update.c:    if ( ch->pcdata->condition[iCond] == 0 )
update.c:            if( ch->top_level <= LEVEL_IMMORTAL )
update.c:               ch->hit = (ch->hit - 5);
update.c:            if( ch->top_level <= LEVEL_IMMORTAL )
update.c:               ch->hit = (ch->hit - 5);
update.c:    if ( ch->pcdata->condition[iCond] == 1 )
update.c:          if ( ch->top_level <= LEVEL_AVATAR )
update.c:          if ( ch->top_level <= LEVEL_AVATAR  )
update.c:    if ( ch->pcdata->condition[iCond] == 2 )
update.c:          if ( ch->top_level <= LEVEL_AVATAR )
update.c:          if ( ch->top_level <= LEVEL_AVATAR )
update.c:    if ( ch->pcdata->condition[iCond] == 3 )
update.c:          if ( ch->top_level <= LEVEL_AVATAR )
update.c:          if ( ch->top_level <= LEVEL_AVATAR )
update.c:	if ( ch == first_char && ch->prev )
update.c:	    ch->prev = NULL;
update.c:	gch_prev = ch->prev;
update.c:		ch->name );
update.c:	    ch->prev = NULL;
update.c:          if(ch->wait_state > 0)
update.c:              ch->wait_state--;
update.c:          if(ch->wait_state < 0)
update.c:              ch->wait_state = 0;
update.c:	if ( !ch->in_room
update.c:        if ( ch->pIndexData->vnum == 5 && !IS_AFFECTED(ch, AFF_CHARM) )
update.c:	  if(ch->in_room->first_person)
update.c:	if ( !IS_SET( ch->act, ACT_RUNNING )
update.c:	&&   !IS_SET( ch->act, ACT_SENTINEL )
update.c:	&&   !ch->fighting && ch->hunting )
update.c:	  if (  ch->top_level < 20 )
update.c:	  else	if (  ch->top_level < 40 )
update.c:	  else if (  ch->top_level < 60 )
update.c:	  else	if (  ch->top_level < 80 )
update.c:	  else	if (  ch->top_level < 100 )
update.c:        else if ( !ch->fighting && !ch->hunting 
update.c:        && !IS_SET( ch->act, ACT_RUNNING)
update.c:        && ch->was_sentinel && ch->position >= POS_STANDING )
update.c:	   char_to_room( ch , ch->was_sentinel );
update.c:	   SET_BIT( ch->act , ACT_SENTINEL );            
update.c:	   ch->was_sentinel = NULL;
update.c:	if ( !IS_SET( ch->act, ACT_RUNNING )
update.c:	&&    ch->spec_fun )
update.c:	    if ( (*ch->spec_fun) ( ch ) )
update.c:        if ( !IS_SET( ch->act, ACT_RUNNING )
update.c:	&&    ch->spec_2 )
update.c:	    if ( (*ch->spec_2) ( ch ) )
update.c:	if ( IS_SET( ch->pIndexData->progtypes, SCRIPT_PROG ) )
update.c:	if ( ch->position != POS_STANDING )
update.c:	if ( IS_SET(ch->act, ACT_MOUNTED ) )
update.c:	    if ( IS_SET(ch->act, ACT_AGGRESSIVE) )
update.c:	if ( IS_SET(ch->in_room->room_flags, ROOM_SAFE )
update.c:	&&   IS_SET(ch->act, ACT_AGGRESSIVE) )
update.c:	if ( ch->in_room->area && ch->in_room->area->nplayer > 0 )
update.c:	    if ( ch->position < POS_STANDING )
update.c:	if ( ch->position < POS_STANDING )
update.c:	if ( IS_SET(ch->act, ACT_SCAVENGER)
update.c:	&&   ch->in_room->first_content
update.c:	    for ( obj = ch->in_room->first_content; obj; obj = obj->next_content )
update.c:                if ( IS_OBJ_STAT( obj, ITEM_PROTOTYPE ) && !IS_SET( ch->act, ACT_PROTOTYPE ) )
update.c:	if ( !IS_SET(ch->act, ACT_RUNNING)
update.c:	&&   !IS_SET(ch->act, ACT_SENTINEL)
update.c:	&&   !IS_SET(ch->act, ACT_PROTOTYPE)
update.c:	&& ( pexit = get_exit(ch->in_room, door) ) != NULL
update.c:	&& (( !IS_SET(ch->act, ACT_STAY_AREA) && pexit->to_room->area)
update.c:	||   pexit->to_room->area == ch->in_room->area ) ) 
update.c:	    if ( retcode != rNONE || IS_SET(ch->act, ACT_SENTINEL)
update.c:	    ||    ch->position < POS_STANDING )
update.c:	if ( ch->hit < ch->max_hit / 2
update.c:	&& ( pexit = get_exit(ch->in_room,door) ) != NULL
update.c:	    for ( rch  = ch->in_room->first_person;
update.c:		  rch  = rch->next_in_room )
update.c:			  sprintf( buf, "¡Aléjate de mi, %s!", rch->name );
update.c:			  sprintf( buf, "¡Déjame en paz, %s!", rch->name );
update.c:			  sprintf( buf, "¡%s está intentando matarme! ¡Ayuda!", rch->name );
update.c:			  sprintf( buf, "¡Que alguien me salve de %s!", rch->name );
update.c:	if ( ch == first_char && ch->prev )
update.c:	    ch->prev = NULL;
update.c:	gch_prev = ch->prev;
update.c:	    bug( "char_update: ch->prev->next != ch", 0 );
update.c:	&&    current_time - ch->save_time > (sysdata.save_frequency*60) )
update.c:        if ( (ch->perm_frc == 0 && !IS_IMMORTAL(ch)) || ch->skill_level[FORCE_ABILITY] == 0)
update.c:	   ch->skill_level[FORCE_ABILITY] = 0;
update.c:	if ( ch->position >= POS_STUNNED )
update.c:	    if ( ch->hit  < ch->max_hit )
update.c:		ch->hit  += hit_gain(ch);
update.c:	    if ( ch->mana < ch->max_mana || ch->skill_level[FORCE_ABILITY] == 1 )
update.c:		ch->mana += mana_gain(ch);
update.c:	    if ( ch->move < ch->max_move )
update.c:		ch->move += move_gain(ch);
update.c:	if ( ch->position == POS_STUNNED )
update.c:        if ( ch->pcdata )
update.c:	if ( !IS_NPC(ch) && ch->top_level < LEVEL_IMMORTAL )
update.c:		if ( --obj->value[2] == 0 && ch->in_room )
update.c:		    ch->in_room->light -= obj->count;
update.c:	    if ( ch->pcdata->condition[COND_DRUNK] > 8 )
update.c:		worsen_mental_state( ch, ch->pcdata->condition[COND_DRUNK]/8 );
update.c:	    if ( ch->pcdata->condition[COND_FULL] > 1 )
update.c:		switch( ch->position )
update.c:	    if ( ch->pcdata->condition[COND_THIRST] > 1 )
update.c:		switch( ch->position )
update.c:	    if ( ch->in_room )
update.c:	      switch( ch->in_room->sector_type )
update.c:		ch->mental_state = URANGE( 20, ch->mental_state
update.c:	    if ( ch->position == POS_INCAP )
update.c:	    if ( ch->position == POS_MORTAL )
update.c:	    if ( ch->mental_state >= 30 )
update.c:		switch( (ch->mental_state+5) / 10 )
update.c:	    if ( ch->mental_state <= -30 )
update.c:		switch( (abs(ch->mental_state)+5) / 10 )
update.c:			if ( ch->position > POS_SLEEPING )
update.c:			   if ( (ch->position == POS_STANDING
update.c:			   ||    ch->position < POS_FIGHTING)
update.c:			   &&    number_percent()+10 < abs(ch->mental_state) )
update.c:			if ( ch->position > POS_SLEEPING )
update.c:			   if ( (ch->position == POS_STANDING
update.c:			   ||    ch->position < POS_FIGHTING)
update.c:			   &&   (number_percent()+20) < abs(ch->mental_state) )
update.c:			if ( ch->position > POS_SLEEPING )
update.c:			   if ( ch->position < POS_SITTING
update.c:			   &&  (number_percent()+30) < abs(ch->mental_state) )
update.c:			if ( ch->position > POS_RESTING )
update.c:			if ( ch->position > POS_RESTING )
update.c:			if ( ch->position > POS_RESTING )
update.c:			if ( ch->position > POS_RESTING )
update.c:			if ( ch->position > POS_RESTING )
update.c:	    if ( ch->backup_wait > 0 )
update.c:	       --ch->backup_wait;
update.c:	       if ( ch->backup_wait == 0 )
update.c:            if ( !IS_NPC(ch) && time_info.hour == 1 && ch->pcdata->salary && ch->pcdata->clan && ch->pcdata->salary < ch->pcdata->clan->funds )
update.c:		  ch->pcdata->bank += ch->pcdata->salary;
update.c:		  ch->pcdata->clan->funds -= ch->pcdata->salary;
update.c:		  ch_printf(ch, "&B[&YINformación bancaria&W: %s&B] &WTu salario de %d créditos ha sido depositado en tu cuenta.\n\r", ch->name, ch->pcdata->salary);
update.c:	    if ( !IS_NPC(ch) && ch->pcdata->bank && (time_info.day == 5 || time_info.day == 15 || time_info.day == 25 || time_info.day == 10 || time_info.day == 20 || time_info.day == 30) && time_info.hour == 1)
update.c:		  amount = ch->pcdata->bank * .02;
update.c:		  ch->pcdata->bank += amount;
update.c:		  sprintf(buf, "&B[&YInformación bancaria&W: %s&B] &WTienes&W: &Y%ld&W intereses este mes.\n\r", ch->name, amount);
update.c:	     if ( ++ch->timer > 15 && !ch->desc )
update.c:		if ( ch->in_room && IS_SET(ch->in_room->room_flags , ROOM_HOTEL ) )
update.c:                  ch->hit = UMAX ( 1 , ch->hit ); 
update.c:                  // ch->position = POS_RESTING;
update.c:                  //ch->position = POS_RESTING;
update.c:                  ch->hit = UMAX ( 1 , ch->hit ); 
update.c:	ch_next = ch->next;
update.c:	    if ( IS_SET(ch->act, ACT_RUNNING) )
update.c:		if ( !IS_SET( ch->act, ACT_SENTINEL )
update.c:		&&   !ch->fighting && ch->hunting )
update.c:		if ( ch->spec_fun )
update.c:		    if ( (*ch->spec_fun) ( ch ) )
update.c:                if ( ch->spec_2 )
update.c:		    if ( (*ch->spec_2) ( ch ) )
update.c:		if ( !IS_SET(ch->act, ACT_SENTINEL)
update.c:		&&   !IS_SET(ch->act, ACT_PROTOTYPE)
update.c:		&& ( pexit = get_exit(ch->in_room, door) ) != NULL
update.c:		&& ( ( !IS_SET(ch->act, ACT_STAY_AREA) && pexit->to_room->area)
update.c:		||   pexit->to_room->area == ch->in_room->area ) ) 
update.c:		    if ( retcode != rNONE || IS_SET(ch->act, ACT_SENTINEL)
update.c:		    ||    ch->position < POS_STANDING )
update.c:	    if ( ch->mount
update.c:	    &&   ch->in_room != ch->mount->in_room )
update.c:		REMOVE_BIT( ch->mount->act, ACT_MOUNTED );
update.c:		ch->mount = NULL;
update.c:		ch->position = POS_STANDING;
update.c:	    if ( ( ch->in_room && ch->in_room->sector_type == SECT_UNDERWATER )
update.c:	    || ( ch->in_room && ch->in_room->sector_type == SECT_OCEANFLOOR ) )
update.c:			dam = number_range( ch->max_hit / 50 , ch->max_hit / 30 );
update.c:			if(  ch->hit <= 0 )
update.c:	    if ( ch->in_room
update.c:	    && (( ch->in_room->sector_type == SECT_WATER_NOSWIM )
update.c:	    ||  ( ch->in_room->sector_type == SECT_WATER_SWIM ) ) )
update.c:		&& !ch->mount )
update.c:			    if ( ch->move > 0 )
update.c:				    ch->move--;
update.c:				dam = number_range( ch->max_hit / 50, ch->max_hit / 30 );
update.c:				if(  ch->hit <= 0 )
update.c:        if ( IS_NPC( wch ) && wch->mpactnum > 0 && wch->in_room->area &&
update.c:	    && wch->in_room->area->nplayer > 0 )
update.c:	    for ( tmp_act = wch->mpact; tmp_act;
update.c:	    for ( tmp_act = wch->mpact; tmp_act; tmp_act = tmp2_act )
update.c:            wch->mpactnum = 0;
update.c:            wch->mpact    = NULL;
update.c:	if ( !char_died(wch) && wch->mpactnum > 0 )
update.c:	    while ( (tmp_act = wch->mpact) != NULL )
update.c:		wch->mpact = tmp_act->next;
update.c:	    wch->mpactnum = 0;
update.c:	    wch->mpact    = NULL;
update.c:	||   wch->top_level >= LEVEL_IMMORTAL
update.c:	||  !wch->in_room )
update.c:	for ( ch = wch->in_room->first_person; ch; ch = ch_next )
update.c:	    ch_next	= ch->next_in_room;
update.c:	    ||   ch->fighting
update.c:	    ||   ( IS_SET(ch->act, ACT_WIMPY) )
update.c:	    if ( !IS_SET(ch->act, ACT_AGGRESSIVE)
update.c:	    ||    IS_SET(ch->act, ACT_MOUNTED)
update.c:	    ||    IS_SET(ch->in_room->room_flags, ROOM_SAFE ) )
update.c:	    if ( IS_NPC(ch) && IS_SET(ch->attacks, ATCK_BACKSTAB ) )
update.c:		if ( !ch->mount
update.c:		    ||   number_percent( )+5 < ch->top_level )
update.c:    if ( IS_NPC( ch ) || ch->pcdata->condition[COND_DRUNK] <= 0 )
update.c:    drunk = ch->pcdata->condition[COND_DRUNK];
update.c:    position = ch->position;
update.c:    ch->position = POS_STANDING;
update.c:	for ( vch = ch->in_room->first_person; vch; vch = vch->next_in_room )
update.c:	check_social( ch, "puke", (rvch ? rvch->name : "") );
update.c:    ch->position = position;
update.c:    if ( ch->mental_state >= 30 && number_bits(5 - (ch->mental_state >= 50) - (ch->mental_state >= 75)) == 0 )
update.c:	switch( number_range( 1, UMIN(20, (ch->mental_state+5) / 5)) )
update.c:    for ( vch = first_char; vch; vch = vch->next )
update.c:       for ( vch = first_char; vch; vch = vch->next )
